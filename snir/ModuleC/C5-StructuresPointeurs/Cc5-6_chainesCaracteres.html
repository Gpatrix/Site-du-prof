<!DOCTYPE html>

<html 
  data-module="C"
  data-pagetype="Chapitre"
  data-modulepartnumber="5"
  data-pagenumber="VI"
  data-pageState="travaux"
  data-pageheadtitle="ChaÃ®nes caractÃ¨res"
  data-pagefulltitle="Les chaÃ®nes de caractÃ¨res"
  data-authorname="FranÃ§oisÂ GIRAULT"
  data-authormail="francois.girault@ac-versailles.fr"
  lang="fr">

<script src="../../js/operateData.js"></script>

<!-- The following script MUST be coded here and not anywhere else! -->
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>

<head> 
  <meta charset="utf-8">
  <script src="../../js/makeHead.js"></script>
</head>

<body>

<nav id="navPannel" style="display: block">
  <script src="../../js/makeNavPannel.js"></script>
</nav>

<div id="mainFrame">
  
<header class="band">
  <script src="../../js/makeHeader.js"></script>
</header> 

<div id="scrollingFrame">

<footer class="band">
  <script src="../../js/makeFooter.js"></script>
</footer>

<section>

<div id="mainTitle">
  <script src="../../js/makeTitle.js"></script>
</div>





<!-- relecture partielle 2023 -->


<div class="exergue">

<div style="display: inline-block">
  <img class="top-right" src="../img/stringGCC.png" width="200px" style="margin-top: 1.5em">
<p class="square"> La notion de <strong class="title">chaÃ®ne de caractÃ¨res</strong> a Ã©tÃ© <strong class="cons">superficiellement prÃ©sentÃ©e</strong> au chapitreÂ C2â€‘VIÂ <a class="previous" href="../C2-ElementsLangage/Cc2-6_entreesSortiesStandards.html#chaineCaracteres" target="_BLANK"></a>. En effet, bien que <strong class="warning">complexe</strong>, cet Ã©lÃ©ment de langage est <strong class="defin">indispensable</strong> pour mettre en Å“uvre des interactions avec un utilisateur â€“Â notamment <strong>afficher un message</strong>Â â€“ dans un programme s'exÃ©cutant dans un terminal de commandes en ligne. </p>
</div><!-- display -->

<p> Maintenant que les notions de <strong class="specialLB">pointeur</strong> et de <strong class="specialLB">tableau</strong> ont Ã©tÃ© abordÃ©es, il est possible d'entamer une <strong class="pros">Ã©tude approfondie</strong> des <strong class="title">chaÃ®nes de caractÃ¨res</strong>. </p>

<p class="square"> Pour bien commencer cette Ã©tude, il importe de prendre conscience de ce qui fait la <strong class="title">complexitÃ©</strong> de la <strong>notion de chaÃ®ne de caractÃ¨res</strong>. En effet, dans un programme, une variable de ce type doit en principe pouvoir mÃ©moriser un <strong class="defin">nombre de caractÃ¨res</strong> potentiellement <strong class="warning">trÃ¨s grand</strong>, mais aussi Ã©ventuellement <strong class="warning">trÃ¨s petit</strong>. Il est donc <strong class="cons">impossible</strong> de dÃ©terminer une <strong class="cons">taille fixe par dÃ©faut</strong> qui serait satisfaisante dans tous les cas de figure.  </p>

<p> C'est pourquoi, en matiÃ¨re de gestion des chaÃ®nes de caractÃ¨res, la plupart des langages de programmation ont recours Ã  des mÃ©canismes d'<strong class="defin">allocation dynamique de mÃ©moire</strong>Â <a class="external" href="https://fr.wikipedia.org/wiki/Allocation_de_mÃ©moire#Allocation_sur_le_tas" target="_BLANK">W</a> (aspect qui sera abordÃ© seulement dans la partieÂ <span class="partie">C6</span> de ce module). Une telle solution <strong class="pros">existe</strong> dans la bibliothÃ¨que standard du <strong>langageÂ C++</strong> avec la <strong>classe</strong>Â <code class="type">string</code>, mais <strong class="warning">pas en langageÂ C</strong>.  </p>

<p> En effet, la Â«Â philosophieÂ Â» du langageÂ <strong>C</strong> privilÃ©gie le recours aux <strong class="pros">objets les plus simples possibles</strong>. Dans le noyau du langage, il n'y a pas de notion de chaÃ®ne de caractÃ¨res de taille dynamique. Ã€ la place, on recourt Ã  celle de <strong class="defin">tableau de caractÃ¨res</strong> et Ã  l'usage du <strong>caractÃ¨re</strong>Â <strong class="specialDR"><em class="sigle">NUL</em></strong> comme <strong class="specialDR">marque de fin de chaÃ®ne</strong>. On parle de <strong class="title">chaÃ®ne de styleÂ C</strong> â€“Â en anglais, <strong>Câ€‘style string</strong> ou <strong>nullâ€‘terminated string</strong>. </p>

<p class="square"> MÃªme si la notion de <strong class="title">chaÃ®ne de styleÂ C</strong> pourraient sembler constituer un concept aujourd'hui trop Â«Â rudimentaireÂ Â» voire Â«Â archaÃ¯queÂ Â», elle reste un Ã©lÃ©ment de langage <strong class="pros">incontournable</strong>, et encore pour longtemps massivement utilisÃ© pour la programmation des <strong>entrÃ©esâ€‘sorties textuelles</strong> et des <strong>systÃ¨mes Ã  mÃ©moire limitÃ©e</strong>. </p>

<p> C'est donc l'<strong class="title">objectif principal</strong> de ce prÃ©sent chapitre qui dÃ©roule l'Ã©tude des chaÃ®nes de caractÃ¨res via les points suivantsÂ : </p>
<ul>
  <li> les <strong class="specialLB">constantes littÃ©rales</strong> de Â«Â typeÂ Â» <strong class="defin">chaÃ®ne de styleÂ C</strong>Â ; outre leur <strong>syntaxe de codage</strong>, on aborde la question de leur <strong>type</strong> et de leur <strong>reprÃ©sentation en mÃ©moire</strong>Â ;   </li>

  <li> les <strong class="specialLB">donnÃ©es dÃ©clarÃ©es</strong> de Â«Â typeÂ Â» <strong class="defin">chaÃ®ne de styleÂ C</strong>, comme un <strong>tableau</strong> de caractÃ¨res ou comme un <strong>pointeur</strong> sur une constante littÃ©raleÂ ; on y aborde la syntaxe de <strong>dÃ©claration</strong> et les <strong>manipulations Ã©lÃ©mentaires</strong> (affectation, passage d'argument d'une fonction)Â ;  </li>

  <li> les <strong class="specialLB">fonctions</strong> de la <strong>bibliothÃ¨que standard</strong> sur les <strong class="defin">chaÃ®nes de styleÂ C</strong>, qui permettent de coder toutes sortes d'analyses et de manipulations complexes sur les chaÃ®neÂ ; </li>

  <li> et enfin une <strong class="pros">initiation</strong> aux <strong class="specialLB">chaÃ®nes de caractÃ¨res dynamiques</strong> en langageÂ <strong>C++</strong>Â ; on y prÃ©sente laÂ <strong>classe</strong>Â <code class="type">string</code> de la bibliothÃ¨que standard et son implÃ©mentationÂ <code class="prettyprint lang-c">String</code> dans le frameworkÂ <strong class="Arduino">Arduino</strong>. </li>
</ul>

</div><!-- exergue -->













<h2> Les constantes littÃ©rales chaÃ®neÂ deÂ caractÃ¨res </h2>


<!-- 
<div class="expert">  
<h4> Notion mathÃ©matique de chaÃ®ne de symboles </h4>

  <p> Alphabet </p>

  <p> OpÃ©ration de concatÃ©nation </p>
  
  <p> MonoÃ¯de libre Ã©lÃ©ment neutre chaÃ®ne vide </p>

  <p> Longueur d'une chaÃ®ne = nombre de symboles</p>

  <p> Ordre lexicographique </p>
</div>  
-->



<h3> Notion de chaÃ®ne de caractÃ¨res en programmation </h3>


<div class="important">
<p> En programmation, une <strong class="title">chaÃ®ne de caractÃ¨res</strong>Â <a class="external" href="https://fr.wikipedia.org/wiki/ChaÃ®ne_de_caractÃ¨res" target="_BLANK">W</a> â€“Â en anglais, <strong>character string</strong>Â â€“ est un objet d'usage trÃ¨s frÃ©quent, qui est constituÃ© d'une <strong class="defin">suite finie de caractÃ¨res</strong>. </p>

<p> Un tel objet possÃ¨de <strong class="specialLB">deux caractÃ©ristiques</strong> remarquablesÂ : </p>
<ul>
  <li> son <strong>nombre de caractÃ¨res</strong> â€”Â c'estâ€‘Ã â€‘dire sa <strong>longueur</strong> au <em class="remark">sens mathÃ©matique</em> du terme (car on verra infraÂ <a class="infra" href="Cc5-6_chainesCaracteres.html#longueurChaine"></a> qu'en termes d'encodage en mÃ©moire, cette notion est diffÃ©rente)Â ;  </li>

  <li> le <strong>format d'encodage</strong> de ses caractÃ¨res â€“Â lesquels sont nÃ©cessairement pris dans un <strong>jeu de caractÃ¨res</strong> donnÃ© (<em class="english">characterÂ set</em>).  </li>
</ul>
</div><!-- important -->


<div class="complement">
<p> Dans tous les langages de programmation, il est possible de coder des <strong class="title">constantes littÃ©rales</strong> de type <strong>chaÃ®ne de caractÃ¨res</strong> â€“Â typiquement en utilisant les <strong class="defin">guillemets</strong> simples ou doubles comme <strong>dÃ©limiteurs</strong> pour ne pas les confondre avec les constantes littÃ©rales des autres types de donnÃ©es. Par exempleÂ : </p>
<ul>
  <li> <code class="prettyprint lang-c">"123"</code> code une constante littÃ©rale de type <strong>chaÃ®ne de caractÃ¨re</strong>, </li>

  <li> alors que <code class="prettyprint lang-c">123</code> code une constante littÃ©rale de type <strong>entier</strong>. </li>
</ul>

<p> Toutefois, la <strong class="title">taille en mÃ©moire</strong> d'une <strong>chaÃ®ne de caractÃ¨res</strong> peut Ãªtre <strong class="specialLB">grande</strong>, voire trÃ¨s grande â€“Â quand il s'agit de manipuler un fichier de texte dans sa totalitÃ©. Presque toujours, la taille d'une chaÃ®ne de caractÃ¨re <strong class="cons">dÃ©passe les capacitÃ©s</strong> de stockage des <strong>registres</strong> de la machine sur laquelle s'exÃ©cute le programme. C'est pourquoi il n'est a priori <strong class="cons">pas possible</strong> de manipuler informatiquement une chaÃ®ne de caractÃ¨res <strong>comme une donnÃ©e Ã©lÃ©mentaire</strong>.  </p>
</div><!-- complement -->



<h3 id="stringLiteral"> Syntaxe de codage d'une constante littÃ©rale chaÃ®neÂ deÂ caractÃ¨res enÂ langageÂ <em>C</em> </h3>


<div class="important">
<p> En langageÂ <strong>C</strong>, une <strong class="title">constante littÃ©rale</strong> de Â«Â typeÂ Â» <strong class="title">chaÃ®ne de caractÃ¨res</strong>Â <a class="external" href="https://en.wikipedia.org/wiki/String_literal" target="_BLANK">W</a> â€“Â en anglais, <strong>string literal</strong>Â â€“ se code via la forme syntaxique ciâ€‘dessousÂ : <br>
<span class="inline">
  <code class="prettyprint lang-c"><span class="nocode"><span style="color: darkgrey; font-style: normal;">[</span><strong class="defin">prÃ©fixe d'encodage</strong><span style="color: darkgrey; font-style: normal;">]</span>
    </span> "<span class="nocode"><strong class="specialO">suite de val. de car. et de sÃ©q. d'Ã©chapp.</strong></span>"</code>
</span> </p>
<div class="expert">
<p> Le <strong class="specialG">type</strong> d'un tel objet sera dÃ©taillÃ© plus loinÂ <a class="infra" href="Cc5-6_chainesCaracteres.html#typeStringLiteral"></a>. </p>  
</div><!-- expert -->  
</div><!-- important -->

<div class="complement">
<p> Dans cette syntaxeÂ <a class="external" href="https://en.cppreference.com/w/c/language/string_literal" target="_BLANK">C</a>, on peut apporter les prÃ©cisions suivantes.  </p>
<ul>
  <li> Le <strong class="defin">prÃ©fixe d'encodage</strong> est <strong>optionnel</strong> et reprend la <strong class="pros">mÃªme syntaxe</strong> que celle des valeurs de caractÃ¨res Ã©tendus (cf.Â chap.Â C3â€‘IXÂ <a class="previous" href="../C3-Numeration/Cc3-9_typesCaracteresEtendus.html#valCarEtendus" target="_BLANK"></a>). Il peut donc prendre les <strong>codes</strong>Â : <br>
  <span class="inline">
    <code class="prettyprint lang-c">u8</code>, <code class="prettyprint lang-c">u</code> ou <code class="prettyprint lang-c">U</code>
  </span> <br>
  pour spÃ©cifier que les caractÃ¨res de la chaÃ®nes sont respectivement encodÃ©es dans le <strong>format</strong>Â : <br>
  <span class="inline">
    <strong><em class="sigle">UTFâ€‘8</em></strong>, <strong><em class="sigle">UTFâ€‘16</em></strong> ou <strong><em class="sigle">UTFâ€‘32</em></strong>.
  </span> </li>

  <div class="nobullet"> En l'<strong>absence de prÃ©fixe</strong>, l'encodage des caractÃ¨res de la chaÃ®ne dÃ©pend de l'implÃ©mentation.  <strong class="defin">Par dÃ©faut</strong>, on aÂ :  </div>
  <ul>
    <li> <strong class="defin"><em class="sigle">UTFâ€‘8</em></strong> avec la chaÃ®ne de compilationÂ <strong>GCC</strong> sous <strong>Linux</strong>Â ;  </li>
  
    <li> <strong class="defin"><em class="sigle">ASCII</em></strong> restreint avec la chaÃ®ne de compilation <strong>Mingwâ€‘w64</strong> sous <strong>Windows</strong>. </li>
  </ul>

  <div class="expert"> 
  <div class="nobullet"> Il existe aussi le <strong class="defin">prÃ©fixe d'encodage</strong>Â <code class="prettyprint lang-c">L</code> pour imposer aux caractÃ¨res de la chaÃ®ne le <strong class="cons">type obsolÃ¨te</strong>Â <code class="prettyprint lang-c">wchar_t</code>. Son usage n'est <strong class="warning">pas recommandÃ©</strong>. </div> 
  </div><!-- expert -->
  
  <li> La <strong class="specialO">suite de valeurs de caractÃ¨res et de sÃ©quences d'Ã©chappement</strong> codÃ©e entre <strong>guillemets doubles</strong>Â <code class="prettyprint lang-c">""</code> doit respecter principalement <strong class="pros">deux limitations</strong>Â : </li>
  <ul>
    <li> Ãªtre codÃ©e sur <strong class="warning">une seule ligne</strong> du <strong>fichier source</strong>Â ; </li>
    
    <div class="expert">
    <div class="nobullet"> (On a vu au chap.Â C2â€‘IIÂ <a class="previous" href="../C2-ElementsLangage/Cc2-2_syntaxeFondamentale.html#contreOblique" target="_BLANK"></a> que l'on peut s'affranchir de cette contrainte en codant des <strong>sauts de lignes fictifs</strong> avec le caractÃ¨re de contrÃ´leÂ <code>\</code> en fin de ligne. On verra infraÂ <a class="external" href="Cc5-6_chainesCaracteres.html#arrayStringDeclaration"></a> que dans l'initialisation d'une dÃ©claration, on peut aussi saisir plusieurs chaÃ®nes les unes Ã  la suite des autres, sÃ©parÃ©es selon les rÃ¨gles du format libreÂ ; elles sont concatÃ©nÃ©es par le compilateur.) </div>  
    </div><!-- expert --> 
  
    <li> <strong class="warning">ne pas contenir</strong> le <strong>caractÃ¨re</strong>Â <code class="prettyprint lang-c">"</code>, puisque ce dernier marquerait la <strong class="defin">fin du codage</strong> de la chaÃ®ne (mais il suffirait d'employer la sÃ©quence d'Ã©chappementÂ <code class="cmd" style="color: darkorange;">\"</code> pour y remÃ©dier).  </li>
  </ul>
  <div class="expert">
  <div class="nobullet"> De plusÂ :  </div>
  <ul>
    <li> les <strong class="specialO">valeurs de caractÃ¨res</strong> peuvent Ãªtre <strong class="pros">directement saisies</strong> dans le code source tant que la <strong>syntaxe automorphe</strong> est possible (cf.Â chap.Â C3â€‘IXÂ <a class="previous" href="../C3-Numeration/Cc3-9_typesCaracteresEtendus.html#syntaxeAutomorphe" target="_BLANK"></a>)Â ;   </li>

    <li> les <strong class="specialO">sÃ©quences d'Ã©chappement</strong> doivent Ãªtre codÃ©es conformÃ©ment Ã  leur <strong>syntaxe spÃ©cifique</strong> avec le symboleÂ <code class="cmd">\</code> comme prÃ©fixe (cf.Â chap.Â C2â€‘VIÂ <a class="previous" href="../C2-ElementsLangage/Cc2-6_entreesSortiesStandards.html#caracteresSpeciaux" target="_BLANK"></a>)Â ; les plus courantes sontÂ : </li>
    <ul style="list-style: circle;">
      <li> <code class="cmd" style="color: darkorange;">\n</code>, <code class="cmd" style="color: darkorange;">\t</code>, <code class="cmd" style="color: darkorange;">\b</code> ouÂ <code class="cmd" style="color: darkorange;">\a</code> pour intÃ©grer respectivement un <strong>saut de ligne</strong> (<em class="sigle">LF</em>), un <strong>saut de tabulation</strong> horizontale (<em class="sigle">HT</em>), un <strong>saut arriÃ¨re</strong> (<em class="sigle">BS</em>) du curseur ou l'Ã©mission d'<strong>avertissement sonore</strong> (<em class="sigle">BEL</em>)Â ; </li>

      <li> <code class="cmd" style="color: darkorange;">\\</code>, <code class="cmd" style="color: darkorange;">\"</code> ouÂ <code class="cmd" style="color: darkorange;">\'</code> pour intÃ©grer respectivement les <strong>symboles</strong>Â Â«Â <code>\</code>Â Â», Â«Â <code>"</code>Â Â» ou Â«Â <code>'</code>Â Â» sans qu'ils soient interprÃ©tÃ©s comme des caractÃ¨res de contrÃ´leÂ ; </li>

      <li> <code class="cmd" style="color: darkorange;">\x<span class="nocode"><strong>xx</strong></span></code>, <code class="cmd" style="color: darkorange;">\u<span class="nocode"><strong>xxxx</strong></span></code> ouÂ <code class="cmd" style="color: darkorange;">\U<span class="nocode"><strong>xxxxxxxx</strong></span></code> pour intÃ©grer un caractÃ¨re par son <strong class="specialO">point de code</strong> si ce dernier comporte respectivement <strong>2</strong>, <strong>4</strong> ouÂ <strong>8Â digits hexadÃ©cimaux</strong>, sachant que <em class="remark">tous les digits</em> du point de code doivent Ãªtre saisis, <strong class="warning">y compris</strong> les <strong>zÃ©ros initiaux</strong>. </li>
    </ul> 
  </ul>
  </div><!-- expert -->
</ul>
</div><!-- complement -->

<div class="exemples" id="eyeBlink">
<p class="exemple"> Le bon affichage de la <strong class="title">constante littÃ©rale</strong> <strong>chaÃ®ne de caractÃ¨res</strong> saisie dans le code source comme ciâ€‘dessousÂ : <br>
<span class="inline">
  <code class="prettyprint lang-c" style="font-size:80%">"Le \"visage clin d'Å“il\" \U0001F609 se code :\t\\U0001F609."</code>
</span> <br>
peut Ãªtre testÃ© directement avec la fonctionÂ <code class="prettyprint lang-c">printf</code> dans l'environnement <strong class="OnlineGDB">OnLineGDB</strong>, dont la chaÃ®ne de compilation estÂ <strong>GCC</strong> (laquelle opÃ¨re par dÃ©faut enÂ <strong><em class="sigle">UTFâ€‘8</em></strong>). On obtient normalement en sortie standardÂ : <br>
<span class="inline">
  <code class="displayDark">Le "visage clin d'Å“il" ğŸ˜‰ se code :    \U0001F609.</code>
</span> </p>

<div class="expert">
<p> Dans cet exemple, on peut remarquerÂ : </p>
<ul>
  <li> le <strong>caractÃ¨re nonÂ <em class="sigle">ASCII</em></strong>Â <code class="cmd">Å“</code> directement saisi (syntaxe automorphe)Â ;  </li>

  <li> les <strong>sÃ©quences d'Ã©chappement</strong> <code class="prettyprint lang-c">\"</code>, <code class="prettyprint lang-c">\t</code> etÂ <code class="prettyprint lang-c">\\</code>Â ;  </li>

  <li> la <strong>sÃ©quence d'Ã©chappement</strong>Â <code class="cmd">\U0001F609</code> â€“Â sachant qu'elle aurait pu Ãªtre remplacÃ©e par sa valeur de caractÃ¨reÂ ğŸ˜‰ saisie en <strong>syntaxe automorphe</strong> (cf.Â chap.Â C3â€‘VIIIÂ <a class="previous" href="../C3-Numeration/Cc3-8_typesCaracteres.html#valeurCarImprimable" target="_BLANK"></a>) par copierâ€‘coller depuis la table des caractÃ¨res du systÃ¨me d'exploitation ou d'une page web comme celleâ€‘ciÂ <a class="external" href="https://unicode-table.com/fr/1F609/" target="_BLANK"></a>.  </li>
</ul>
</div><!-- expert -->
</div><!-- exemple -->


<div class="expert">
<h4 id="rawString"> La notion de chaÃ®ne de caractÃ¨res Â«Â bruteÂ Â» </h4>


<div class="important">
<p> Pour <strong class="pros">s'affranchir de toute contrainte de saisie</strong>, le langageÂ <strong>C++</strong> (depuis la normeÂ <em class="mark">C++11</em>) et une extension du langageÂ <strong>C</strong> â€“Â portÃ©e notamment par la chaÃ®ne de compilationÂ <strong>GCC</strong>Â â€“ introduisent la notion de <strong class="title">chaÃ®ne de caractÃ¨res brute</strong> â€“Â en anglais, <strong>raw string literal</strong>Â <a class="external" href="https://en.cppreference.com/w/cpp/language/string_literal" target="_BLANK">C++Â Â§(6)</a>. Sa syntaxe de codage est la suivanteÂ :  <br>
<span class="inline">
  <code class="prettyprint lang-c"><span class="nocode"><span style="color: darkgrey; font-style: normal;">[</span><strong class="defin">prÃ©fixe d'encodage</strong><span style="color: darkgrey; font-style: normal;">]</span></span>R"<span class="nocode"><strong class="specialT">motif</strong></span>(<span class="nocode"><strong class="specialO">chaÃ®ne brute</strong></span>)<span class="nocode"><strong class="specialT">motif</strong>&#8239;</span>"</code>
</span> <br>
Le <strong class="specialT">motif</strong> joue le rÃ´le de <strong class="specialT">dÃ©limiteur</strong>, il peut Ãªtre codÃ© par n'importe quelle sÃ©quence (Ã©ventuellement vide) de <strong>caractÃ¨res imprimablesÂ <em class="sigle">ASCII</em></strong> Ã  l'exception des caractÃ¨resÂ <strong><em class="sigle">SP</em></strong> (espace), Â«Â <code>\</code>Â Â», Â«Â <code>(</code>Â Â» et Â«Â <code>)</code>Â Â». </p>
</div><!-- important -->

<div class="complement">
<p> Dans une <strong class="title">chaÃ®ne de caractÃ¨res brute</strong>, le compilateur ne traite <strong class="warning">aucune sÃ©quence d'Ã©chappement</strong>. Seules sont recherchÃ©es les sÃ©quencesÂ <code class="cmd">"<span class="nocode"><strong class="specialT">motif</strong></span>(</code> etÂ <code class="cmd">)<span class="nocode"><strong class="specialT">motif</strong></span>"</code> pour dÃ©limiter le dÃ©but et la fin de la chaÃ®ne. Le choix du <strong class="specialT">motif</strong> dÃ©limiteur dÃ©pend du contenu de la chaÃ®ne, le codeur devant s'assurer qu'il n'y ait <strong class="pros">aucun conflit</strong> possible avec une Ã©ventuelle occurrence de cette sÃ©quence dans le contenu de la chaÃ®ne. Typiquement, on prend une rÃ©pÃ©tition de symboles symÃ©triques comme par exempleÂ <code class="cmd">======</code>. </p>

<p> <strong class="specialO">Tous les caractÃ¨res</strong> saisis dans une <strong class="title">chaÃ®ne brute</strong> sont inclus donc tels quels, y compris les <strong>sauts de lignes</strong> gÃ©nÃ©rÃ©s par la touche Â«Â entrÃ©eÂ Â» du clavier. Cette propriÃ©tÃ© est particuliÃ¨rement bienvenue dans un programme pour <strong class="pros">incorporer des lignes de code source d'un autre langage</strong>, qui peuvent Ãªtre indentÃ©es conformÃ©ment aux rÃ¨gles de bonnes pratiques. </p>
</div><!-- complement -->

<div class="exemples"><p class="exemples"></p>
<ol class="numbered">
  <li> Le <strong class="title">programme acadÃ©mique</strong> ciâ€‘dessous comporte une <strong>chaÃ®ne de caractÃ¨res brute</strong> codÃ©e sur <strong>deux lignes</strong> (nÂ°Â 4Â &Â 5) comme premier argument de la fonctionÂ <code class="prettyprint lang-c">printf</code>. Arbitrairement, le <strong class="specialT">motif</strong> dÃ©limiteur choisi est <code class="cmd">!!!</code>, mais tout autre aurait pu convenir. </li>

  <div class="nobullet"> Ce programme est compilable enÂ <strong>C</strong> ou en <strong>C++</strong> sur <strong class="OnlineGDB">OnLineGDB</strong>. </div> 

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;

int main(void) {
  printf(R"!!!(foo
       bar)!!!");
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

  <div class="nobullet"> Comme attendu, il produit en sortie standard l'<strong>affichage sur deux lignes</strong> ciâ€‘dessousÂ : </div>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
foo
       bar
</pre>
<!---------- ne pas indenter ---------->

  <li id="exRawString"> Au chapitreÂ R2â€‘IVÂ <a class="previous" href="../../ModuleR/R2-Applications/Rc2-4_webServeur.html#CandCpp" target="_BLANK"></a>, on a montrÃ© comment <strong>embarquer un serveur web</strong> sur une <strong class="Arduino">carte Arduino</strong> Ã©quipÃ©e d'un <strong>shield Ethernet</strong> â€“Â donc, programmÃ©e enÂ <strong>C++</strong>. Dans l'extrait ciâ€‘dessous, le codeÂ <strong><em class="sigle">HTML/CSS</em></strong> de la page d'accueil du serveur est incorporÃ© en plusieurs parties sous la forme des <strong class="title">chaÃ®nes de caractÃ¨re brutes</strong> <code>pageHead</code> (lignesÂ nÂºÂ 10 Ã Â 17) et <code>pageTail</code> (lignesÂ nÂºÂ 19 Ã Â 26)Â : </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:10">
const char pageHead[] = R"=====(
&lt;!DOCTYPE html&gt;
  &lt;html lang='fr'&gt;
  &lt;head&gt;
    &lt;meta charset='utf-8'&gt;
    &lt;title&gt;Dynamic page Arduino&lt;/title&gt;
  &lt;/head&gt;
)=====";

const char pageTail[] = R"=====(
&lt;h1&gt; Dynamic page example embedded on Arduino board &lt;/h1&gt;
&lt;p&gt;&lt;a href='./?bgcolor=white'&gt;White&lt;/a&gt;
   Â Â &lt;!-- 2 nonâ€‘break spaces here as inter-margin --&gt;
   &lt;a href='./?bgcolor=yellow'&gt;Yellow&lt;/a&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
)=====";

// ...
</pre>
<!---------- ne pas indenter ---------->

</ol><!-- numbered -->

</div><!-- exemple -->

<div class="remarques">
<p class="remarque"> Avec certains Ã©diteurs de code, la <strong class="title">coloration syntaxique</strong> des <strong>chaÃ®nes de caractÃ¨res brutes</strong> est <strong class="cons">dÃ©fectueuse</strong>. C'est notamment le cas du script <em class="mark">Google Prettify</em>Â <a class="external" href="https://code.google.com/archive/p/google-code-prettify/" target="_BLANK"></a> utilisÃ© pour la mise en forme du prÃ©sent site. </p>
</div><!-- remarque -->

</div><!-- expert -->



<h3 id="typeStringLiteral"> Type d'une constante littÃ©rale chaÃ®neÂ deÂ caractÃ¨res </h3>



<div class="important">
<p> Comme toute constante littÃ©rale, une <strong>constante littÃ©rale chaÃ®ne de caractÃ¨re</strong> possÃ¨de un <strong class="title">type implicitement dÃ©terminÃ©</strong>. Dans tous les cas, il s'agit d'un <strong class="specialO">tableau</strong> dontÂ : </p>
<ul>
  <li> le <strong class="specialG">type d'Ã©lÃ©ment</strong> est directement liÃ© au <strong>format d'encodage</strong> des caractÃ¨resÂ ;  </li>

  <li> le <strong class="specialLB">nombre d'Ã©lÃ©ment</strong> dÃ©pend du <strong>nombre d'unitÃ©s d'encodage</strong> nÃ©cessaires pour reprÃ©senter tous les caractÃ¨res de la chaÃ®ne (variable d'un caractÃ¨re Ã  l'autre pour certains formats).  </li>
</ul>
</div><!-- important -->


<div class="complement">
<p> Plus prÃ©cisÃ©ment, si l'on noteÂ <strong class="specialLB">N</strong> le <strong>nombre d'unitÃ©s d'encodage</strong> pour reprÃ©senter tous les caractÃ¨res d'une chaÃ®ne codÃ©e dans le programme comme une constante littÃ©rale, cette derniÃ¨re est <strong class="title">implicitement de type</strong>Â :  </p>
<ul>
  <li> <code class="prettyprint lang-c">const char[<span class="nocode"><strong class="specialLB">NÂ +Â 1</strong></span>]</code> en l'<strong>absence de prÃ©fixe d'encodage</strong> ou avec le <strong>prÃ©fixe</strong>Â <code class="cmd">u8</code> enÂ langageÂ <strong>C</strong>Â ;  </li>

  <div class="nobullet"> (<code class="prettyprint lang-c">char8_t[<span class="nocode"><strong class="specialLB">NÂ +Â 1</strong></span>]</code> avec le <strong>prÃ©fixe</strong>Â <code class="cmd">u8</code> en Â langageÂ <strong>C++</strong> depuis la normeÂ <em class="mark">C++20</em>) </div>

  <li> <code class="prettyprint lang-c">const char16_t[<span class="nocode"><strong class="specialLB">NÂ +Â 1</strong></span>]</code> avec le <strong>prÃ©fixe</strong>Â <code class="cmd">u</code>Â ; </li>

  <li> <code class="prettyprint lang-c">const char32_t[<span class="nocode"><strong class="specialLB">NÂ +Â 1</strong></span>]</code> avec le <strong>prÃ©fixe</strong>Â <code class="cmd">U</code>. </li>
</ul>
<p> sachant qu'une <strong class="specialLB">unitÃ© supplÃ©mentaire</strong> (d'oÃ¹ leÂ <strong class="specialLB">+Â 1</strong> dans les expressions ciâ€‘dessus) est toujours requise pour encoder le <strong class="specialDR">caractÃ¨re de fin de chaÃ®ne</strong>Â <strong  class="specialN"><em class="sigle">NUL</em></strong>Â <a class="external" href="https://fr.wikipedia.org/wiki/CaractÃ¨re_nul" target="_BLANK">W</a> â€“Â codÃ©Â <code class="cmd">0x0</code> dans tous les formats (et Ã©galement, par la sÃ©quence d'Ã©chappement octaleÂ <code class="prettyprint lang-c">'\0'</code> â€“Â cf.Â chap.Â C3â€‘VIIIÂ <a class="previous" href="../C3-Numeration/Cc3-8_typesCaracteres.html#sequenceOctale" target="_BLANK"></a>). Ce caractÃ¨re n'a pas besoin d'Ãªtre saisi par le codeur, il est <strong>automatiquement ajoutÃ©</strong> par le compilateur (cf.Â chap.Â C2â€‘VIÂ <a class="previous" href="../C2-ElementsLangage/Cc2-6_entreesSortiesStandards.html#CstyleString" target="_BLANK"></a>). </p>
</div><!-- complement -->

<div class="expert">
<div class="exemples" id="exScanStringLiteral">
<p class="exemples"> Le <strong class="title">type implicite</strong> de chaque <strong>chaÃ®ne de caractÃ¨re</strong> donnÃ©e ciâ€‘dessous est valable pour une compilation en langageÂ <strong>C</strong> sur une machine <strong>Linux</strong>. </p>

<p> Dans tous les cas, le <strong class="defin">programme de scan mÃ©moire</strong> proposÃ© ciâ€‘aprÃ¨s pour vÃ©rifier ce type peut Ãªtre exÃ©cutÃ© sur <code class="prettyprint lang-c">OnLineGDB</code>. </p>

<ol class="numbered">
  <li> La chaÃ®neÂ <code class="prettyprint lang-c">"Good bye."</code> (9Â caractÃ¨res) est du <strong class="title">type implicite</strong>Â <code class="prettyprint lang-c">const char[10]</code> (9Â +Â 1Â Ã©lÃ©ments) car elle est composÃ©e exclusivement dans le <strong>jeuÂ <em class="sigle">ASCII</em> restreint</strong> (chaque caractÃ¨re ne nÃ©cessite qu'une seule unitÃ© d'encodage). </li>

  <div class="nobullet"> Le <strong class="defin">programme de scan mÃ©moire</strong> ciâ€‘dessous utilise (trÃ¨s classiquement) un <strong>pointeur d'octet</strong>Â <code class="prettyprint lang-c">p</code> initialisÃ© sur le premier caractÃ¨re d'une constante littÃ©rale chaÃ®ne de caractÃ¨res (cf.Â la ligneÂ nÂ°Â 7). </div>
  <ul>
    <li> Il parcourt l'espace mÃ©moire jusqu'Ã  atteindre le <strong>caractÃ¨re de fin de chaÃ®ne</strong>Â <code class="cmd">0x0</code> (cf.Â la ligneÂ nÂ°Â 14).  </li>

    <li> Ã€ chaque nouveau caractÃ¨re, il affiche son <strong>adresse</strong> puisÂ : </li>
    <ul style="list-style: circle;">
      <li> soit sa <strong>valeur de caractÃ¨re</strong> si elle est imprimableÂ ; </li>
    
      <li> soit son <strong>code hexadÃ©cimal</strong> dans le cas contraire.  </li>
    </ul>
  </ul>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;uchar.h&gt; // only for further examples

int main(void) {
  char * str = "Good bye.";
  char * p = str;  // mem-scan pointer
  do {
    if (isprint(*p)) 
      printf("%p %c\n", p, *p);
    else // non printable character
      printf("%p 0x%X\n", p, *p);
  }
  while (*p++ != 0x0);

  return 0;
}  
</pre>
<!---------- ne pas indenter ---------->

  <div class="nobullet"> Il produit en sortie standard l'affichage suivantÂ :  </div>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
0x56430e6ec004 G
0x56430e6ec005 o
0x56430e6ec006 o
0x56430e6ec007 d
0x56430e6ec008 
0x56430e6ec009 b
0x56430e6ec00a y
0x56430e6ec00b e
0x56430e6ec00c .
0x56430e6ec00d 0x0
</pre>
<!---------- ne pas indenter ----------> 

  <div class="nobullet"> oÃ¹ l'on voit que les <strong>adresses</strong> de tous les caractÃ¨res de la chaÃ®ne s'Ã©chelonnentÂ <strong>deÂ 1 enÂ 1</strong> (ils sont donc bien d'un type de tailleÂ 1 octet). </div> 
  
  <li> La chaÃ®neÂ <code class="prettyprint lang-c">"Ã€ bientÃ´t"</code> (9Â caractÃ¨res Ã©galement) est du <strong class="title">type implicite</strong>Â <code class="prettyprint lang-c">const char[12]</code> (11Â +Â 1Â Ã©lÃ©ments) car elle comporte deux caractÃ¨res (Â«Â Ã€Â Â» et Â«Â Ã´Â Â») qui sont hors <strong>jeuÂ <em class="sigle">ASCII</em> restreint</strong>, donc non reconnus comme caractÃ¨res imprimables par la fonctionÂ <code class="prettyprint lang-c">isprint</code>. L'un et l'autre nÃ©cessitent <strong>deux octets</strong> d'encodage enÂ <strong><em class="sigle">UTFâ€‘8</em></strong> (format par dÃ©faut des chaÃ®nes de caractÃ¨res avecÂ <em class="mark">GCC</em>), ce que l'on peut observer sur la sortie standard obtenue avec le mÃªme programme qu'Ã  l'exemple prÃ©cÃ©dentÂ :   </li>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
0x55c165977004 0xC3
0x55c165977005 0x80
0x55c165977006  
0x55c165977007 b
0x55c165977008 i
0x55c165977009 e
0x55c16597700a n
0x55c16597700b t
0x55c16597700c 0xC3
0x55c16597700d 0xB4
0x55c16597700e t
0x55c16597700f 0x0
</pre>
<!---------- ne pas indenter ----------> 

  <li> La chaÃ®neÂ <code class="prettyprint lang-c">u"Good bye."</code> (toujours 9Â caractÃ¨res) est du <strong class="title">type implicite</strong>Â <code class="prettyprint lang-c">const char16_t[10]</code> (9Â +Â 1Â Ã©lÃ©ments) car le <strong>prÃ©fixe</strong>Â <code class="cmd">u</code> impose le typeÂ <code class="prettyprint lang-c">char16_t</code> â€“Â de tailleÂ <strong>2Â octets</strong>Â â€“ comme unitÃ© d'encodage de ses caractÃ¨res. Et ici, chaque caractÃ¨re ne nÃ©cessite qu'une seule unitÃ© d'encodage.  </li>

  <div class="nobullet"> Dans le <strong>programme de scan mÃ©moire</strong> prÃ©cÃ©dent, il suffit de remplacer les lignesÂ nÂ°Â 6Â &Â 7 par cellesâ€‘ci dessousÂ : </div>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:6">
  char16_t * str = u"Good bye.";
  char16_t * p = str;
</pre>
<!---------- ne pas indenter ---------->

  <div class="nobullet"> pour obtenir en sortie standard l'affichage suivantÂ :  </div>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
0x56351c230004 G
0x56351c230006 o
0x56351c230008 o
0x56351c23000a d
0x56351c23000c  
0x56351c23000e b
0x56351c230010 y
0x56351c230012 e
0x56351c230014 .
0x56351c230016 0x0
</pre>
<!---------- ne pas indenter ----------> 

  <div class="nobullet"> oÃ¹ l'on voit que les adresses de tous les caractÃ¨res de la chaÃ®ne s'Ã©chelonnentÂ deÂ 2 enÂ 2 (ces caractÃ¨res sont donc bien d'un type de tailleÂ 2Â octets).  </div>  

  <li> On peut faire une <strong>expÃ©rience similaire</strong> avec la chaÃ®neÂ <code class="prettyprint lang-c">U"Good bye."</code> et vÃ©rifier qu'elle est du <strong class="specialG">type</strong>Â <code class="prettyprint lang-c">const char32_t[10]</code>.  </li>

</ol><!-- numbered -->
  
</div><!-- exemples -->
</div><!-- expert -->

<div class="remarques">
<p class="remarque"> Le <strong class="title">caractÃ¨reÂ <em class="sigle">NUL</em></strong> est parfois dÃ©signÃ© <strong class="cons"><em class="sigle">NULL</em></strong> mais il faut surtout <strong class="warning">ne pas le confondre</strong> avec le <strong class="defin">pointeurÂ nul</strong> (cf.Â chap.Â C5â€‘IIÂ <a class="previous" href="Cc5-2_pointeursApplications.html#nullPtr" target="_BLANK"></a>) dont le code en langagesÂ <strong>C/C++</strong> estÂ <code class="prettyprint lang-c">NULL</code>. </p>
</div><!-- remarque -->


<h3>  ReprÃ©sentation en mÃ©moire d'une constanteÂ littÃ©rale chaÃ®neÂ deÂ caractÃ¨res </h3>



<div class="important">
<p> <strong class="warning">Sauf</strong> lorsqu'elle constitue la valeur d'initialisation dans la <strong>dÃ©claration d'une donnÃ©e de type</strong> <strong class="defin">tableau</strong> (cf.Â infraÂ <a class="infra" href="Cc5-6_chainesCaracteres.html#arrayStringDeclaration"></a>), toute <strong class="title">constante littÃ©rale chaÃ®ne de caractÃ¨res</strong> codÃ©e dans un programme est <strong>stockÃ©e</strong> dans le <strong>segment</strong>Â <code class="inv" style="background:springgreen;">.rodata</code> (Â«Â <code>ro</code>Â Â» pour <em class="english">readâ€‘only</em>) de la zone mÃ©moire statique allouÃ©e au programme lors de son exÃ©cution  â€”Â autrement dit, le segment rÃ©servÃ© pour les <strong class="specialSG">constantes statiques</strong> (cf.Â chap.Â C4â€‘2Â <a class="previous" href="../C4-Fonctions/Cc4-2_porteeDonnees.html#machineX86" target="_BLANK"></a>). </p>

<div class="expert">
<p> En effetÂ : </p>
<ul>
  <li> du fait de sa potentielle <strong>grande taille</strong>, il ne serait <strong class="cons">pas commode</strong> de stocker un tel objet dans le segmentÂ <code>.text</code> du programmeÂ ; </li>

  <li> un tel objet Ã©tant de <strong>type</strong>Â <code class="prettyprint lang-c">const</code>, il ne peut pas Ãªtre stockÃ© dans le segmentÂ <code>.data</code>. </li>
</ul>
</div><!-- expert -->
</div><!-- important -->

<div class="complement">
<p> PrÃ©cisons de plus que lorsque le programme comporte <strong class="title">plusieurs occurrences</strong> de la <strong>mÃªme constante littÃ©rale chaÃ®ne de caractÃ¨res</strong>, le compilateur est en gÃ©nÃ©ral capable d'optimiser le code exÃ©cutable avec <strong class="pros">un seul stockage</strong> de cet objet. </p>
</div><!-- complement -->

<div class="expert">
<p> Toutefois, le codage d'un <strong class="specialO">saut de ligne final</strong> par une sÃ©quence d'Ã©chappementÂ <code class="cmd">\n</code> dans une chaÃ®ne de caractÃ¨res peut engendrer des <strong class="warning">traitements diffÃ©rents</strong> du compilateur selon qu'elle figure comme argument dans un appel de la fonctionÂ <code class="prettyprint lang-c">printf</code> ou comme valeur d'initialisation d'une dÃ©claration de donnÃ©e chaÃ®ne de caractÃ¨res. </p>

<div class="exemples" id="exScanRodata">
<p class="exemple"> Pour rÃ©vÃ©ler le <strong class="title">stockage en mÃ©moire</strong> d'une <strong>constante littÃ©rale chaÃ®nes de caractÃ¨res</strong>, on propose le programme ciâ€‘dessous dans lequelÂ :   </p>
<ul>
  <li> on dÃ©clare tout d'abord une constante globale nommÃ©eÂ <code class="prettyprint lang-c">rodataStart</code> initialisÃ©e par la valeur arbitraireÂ <code class="prettyprint lang-c">'#'</code> simplement pour repÃ©rer l'adresse du <strong>dÃ©but du segment</strong>Â <code class="inv" style="background:springgreen;">.rodata</code>Â ; </li>

  <li> on code <strong class="defin">deux occurrences</strong> de la mÃªme constante littÃ©raleÂ <code class="prettyprint lang-c">"Hello\n"</code> (avec la sÃ©quence d'Ã©chappementÂ <code class="prettyprint lang-c">\n</code> â€“Â <em>newline</em>)Â :  </li>
  <ul>
    <li> l'une constituant le premier argument effectif (donc, la chaÃ®ne de format) d'un <strong>appel de la fonction</strong>Â <code class="prettyprint lang-c">printf</code> (cf.Â la ligneÂ nÂ°Â 7)Â ;  </li>
  
    <li> l'autre constituant la valeur d'initialisation d'un pointeur de caractÃ¨res (cf.Â la ligneÂ nÂ°Â 8)Â ;  </li>
  </ul>

  <li> comme dans les exemples prÃ©cÃ©dents (cf.Â supraÂ <a class="supra" href="Cc5-6_chainesCaracteres.html#exScanStringLiteral"></a>), on scanne la mÃ©moire avec un <strong>pointeur d'octet</strong>, ici initialisÃ© au dÃ©but du segmentÂ <code class="inv" style="background:springgreen;">.rodata</code> et qui parcourtÂ 20Â caractÃ¨res en recherchant les occurrences deÂ <code class="prettyprint lang-c">'H'</code> (dÃ©but des constantes littÃ©ralesÂ <code class="prettyprint lang-c">"Hello\n"</code>). </li>
</ul>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

const char rodataStart = '#';

int main(void) {
  printf("Hello\n");
  char * str = "Hello\n";
  printf("%s", str);
  
  printf("%p %c .rodata\n", &rodataStart, rodataStart);
  
  const char * p = &rodataStart;
  do {
    if (*p != 'H') p++;
    else do {
      if (isprint(*p)) 
        printf("%p %c\n", p, *p);
      else // non printable character
        printf("%p 0x%X\n", p, *p);
    }
    while (*p++ != 0x0);
  }
  while (p <= &rodataStart + 20);

  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

  <p> ExÃ©cutÃ© sur <strong class="OnlineGDB">OnlineGDB</strong>, ce programme produit en sortie standard l'affichage suivantÂ :  </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Hello
Hello
0x561f50746004 # .rodata
0x561f50746005 H
0x561f50746006 e
0x561f50746007 l
0x561f50746008 l
0x561f50746009 o
0x561f5074600a 0x0
0x561f5074600b H
0x561f5074600c e
0x561f5074600d l
0x561f5074600e l
0x561f5074600f o
0x561f50746010 0xA
0x561f50746011 0x0
</pre>
<!---------- ne pas indenter ----------> 

  <p> oÃ¹ l'on voit que le segmentÂ <code class="inv" style="background:springgreen;">.rodata</code> contient <strong class="defin">deux occurrences</strong> de la sÃ©quence de caractÃ¨res <code>Hello</code>, l'une <strong>avec</strong> et l'autre <strong>sans</strong> le caractÃ¨reÂ <strong><em class="sigle">LF</em></strong> (<em>line feed</em>, codeÂ <code>0xA</code>) normalement gÃ©nÃ©rÃ© par la sÃ©quence d'Ã©chappementÂ <code class="prettyprint lang-c">\n</code>. </p>

  <p> Ici, le compilateur a implÃ©mentÃ© dans le segmentÂ <code>.text</code> (non scannÃ©) le saut de ligne final codÃ© dans la chaÃ®ne de format dans l'appel de la fonctionÂ <code class="prettyprint lang-c">printf</code>.  </p>
  
  <p> <em class="remark">Remarque</em>Â : en supprimant la sÃ©quence d'Ã©chappementÂ <code class="cmd">\n</code> dans les deux constantes littÃ©rales (lignesÂ nÂ°Â 7Â &Â 8), on peut constater que le compilateur <strong class="pros">optimise</strong> le segmentÂ <code class="inv" style="background:springgreen;">.rodata</code> en ne stockant qu'<strong>une seule sÃ©quence</strong>Â <code>Hello</code>. </p>
</div><!-- exemple -->

</div><!-- expert -->

<div class="remarques">
<p class="remarque"> Le cas de l'<strong>initialisation</strong> d'une donnÃ©e de type <strong class="defin">tableau</strong> par une <strong class="title">constante littÃ©rale chaÃ®ne de caractÃ¨res</strong> est traitÃ© infraÂ <a class="infra" href="Cc5-6_chainesCaracteres.html#stringArrayDeclaration"></a>. </p>
</div><!-- remarque -->


<div class="expert">
<h4> ParticularitÃ© pour le framework <em class="mark">Arduino</em> </h4>



<p>  Dans le cadre de la programmation des <strong class="title">cartes Ã  microcontrÃ´leur</strong>, le stockage des <strong>constantes littÃ©rales chaÃ®nes de caractÃ¨res</strong> dans le segmentÂ <code class="inv" style="background:springgreen;">.rodata</code> peut conduire Ã  un  <strong class="warning">encombrement significatif</strong> de l'espace mÃ©moire rÃ©servÃ© aux donnÃ©es (<strong><em class="sigle">RAM</em></strong>). En effetÂ : </p>
<ul>
  <li> cet espace est souvent <strong class="cons">trÃ¨s limitÃ©</strong> â€“Â par exemple, seulementÂ <strong class="cons">2Â ko</strong> deÂ <strong><em class="sigle">RAM</em></strong> sur dans le microcontrÃ´leur <strong>AtmelÂ ATmega328P</strong> qui Ã©quipe les <strong class="Arduino">cartes Arduino</strong>Â <strong>Uno</strong> etÂ <strong>Nano</strong> (cf.Â chap.Â C1â€‘3Â <a class="previous" href="../C1-Generalites/Cc1-3_ArduinoTinkercad.html#carteUno" target="_BLANK"></a>)Â ; </li>

  <li> tout <strong>message textuel</strong> gÃ©nÃ©rÃ© par le programme, qu'il soit envoyÃ© sur le moniteur sÃ©rie ou un autre pÃ©riphÃ©rique de sortie (Ã©cranÂ <em class="sigle">LCD</em>â€¦) nÃ©cessite a priori le codage d'une <strong>constante littÃ©rale chaÃ®ne de caractÃ¨res</strong> spÃ©cifique. </li>
</ul>
<p> MÃªme sans saturation de laÂ <strong><em class="sigle">RAM</em></strong> lors de la compilation, il est <strong class="warning">indispensable</strong> qu'il y reste <strong class="defin">suffisamment d'octets libres</strong> pour la <strong>pile</strong> et le <strong>tas</strong> lors de l'exÃ©cution du programme (cf.Â chap.Â C4â€‘2Â <a class="previous" href="../C4-Fonctions/Cc4-2_porteeDonnees.html#remarqueCollision" target="_BLANK"></a>). </p>


<div class="important">
<p> Pour <strong class="pros">remÃ©dier</strong> aux problÃ¨mes potentiels d'<strong class="cons">encombrement de laÂ <em class="sigle">RAM</em></strong>, il existe diverses <strong class="title">macroâ€‘dÃ©finitions spÃ©ciales</strong>, notamment celles mentionnÃ©es ciâ€‘dessousÂ <a class="external" href="https://www.arduino.cc/reference/en/language/variables/utilities/progmem/" target="_BLANK">A</a>. Elles permettent de <strong class="defin">localiser des donnÃ©es dans la mÃ©moire flash</strong> du microcontrÃ´leur.  </p>
<ul>
  <li> La <strong class="specialLB">macroâ€‘dÃ©finition</strong> <code class="prettyprint lang-c">PROGMEM</code> (pour <em class="english">program memory</em>) est utilisable comme un <strong class="specialLB">motâ€‘clef modificateur</strong> dans le <strong class="specialG">descripteur de type</strong> de la dÃ©claration d'une <strong class="specialO">donnÃ©e statique constante</strong>, typiquement un tableau de caractÃ¨res.   </li>

  <div class="nobullet"> Dans la suite du code, une telle donnÃ©e nÃ©cessite une <strong class="warning">conversion spÃ©ciale</strong> ou l'usage d'une <strong class="warning">pseudoâ€‘fonction spÃ©cifique</strong> pour pouvoir Ãªtre lue. </div>

  <li> La <strong class="specialLB">pseudoâ€‘fonction</strong> <code class="prettyprint lang-c">F</code> (pour <em class="english">flash</em>) peut s'appliquer Ã  toute occurrence d'une <strong>constante littÃ©rale chaÃ®ne de caractÃ¨res</strong> codÃ©e dans un argument effectif d'<strong>appel de fonction</strong>. </li>
</ul>
<p> Pour les microcontrÃ´leurs <strong>Atmel</strong> Ã Â cÅ“urÂ <strong><em class="sigle">AVR</em></strong>, ces Ã©lÃ©ments de langages sont dÃ©finis dans le fichier d'enâ€‘tÃªte <code class="filename">avr/pgmspace.h</code>Â <a class="external" href="https://github.com/avrdudes/avr-libc/blob/main/include/avr/pgmspace.h" target="_BLANK">G</a>. </p>
</div><!-- important -->


<div class="complement">
<p> Rappelons qu'en plus de saÂ <strong><em class="sigle">RAM</em></strong>, tout microcontrÃ´leur est dotÃ© d'un volume de <strong class="title">mÃ©moire flash</strong> (non volatile) notamment dÃ©diÃ© au stockage du <strong>code exÃ©cutable</strong> du programme utilisateur â€“Â le segmentÂ <code class="inv" style="background:crimson;">.text</code>. Ã‰tant <strong class="pros">beaucoup plus grand</strong> que laÂ <strong><em class="sigle">RAM</em></strong> â€“Â par exemple, <strong>32Â ko</strong> dans le microcontrÃ´leurÂ <strong>AtmelÂ ATmega328P</strong>Â â€“ ce volume peut aussi Ãªtre exploitÃ© pour y <strong class="defin">stocker des donnÃ©es</strong>. </p>

<p> Toutefois, cette possibilitÃ© est <strong class="defin">limitÃ©e aux constantes statiques</strong>, car lors de l'exÃ©cution du programme, toute la <strong class="title">mÃ©moire flash</strong> est opÃ©rÃ©e en <strong>lecture seule</strong>. </p>

<p> De plus, outre le fait qu'elle <strong class="cons">complique le codage</strong>, l'exploitation de la mÃ©moire flash pour les donnÃ©es prÃ©sente un inconvÃ©nientÂ : elle <strong class="cons">ralentit les opÃ©rations de lecture des donnÃ©es</strong>, puisque le temps d'accÃ¨s Ã  une <strong class="title">mÃ©moire flash</strong> est toujours trÃ¨s supÃ©rieur Ã  celui d'uneÂ <strong><em class="sigle">RAM</em></strong>.  Elle ne doit donc Ãªtre employÃ©e que lorsqu'elle est vraiment nÃ©cessaire, c'estâ€‘Ã â€‘dire lorsque les donnÃ©es du programme sont volumineuses au point de saturer laÂ <strong><em class="sigle">RAM</em></strong> du microcontrÃ´leur. </p>
</div><!-- complement -->

<div class="exemples">
<p class="exemple"> Reprenons le programme dÃ©jÃ  mentionnÃ© supraÂ <a class="supra" href="Cc5-6_chainesCaracteres.html#exRawString" target="_BLANK"></a> de dÃ©monstration d'un <strong class="title">serveur web embarquÃ©</strong> sur une <strong class="Arduino">carte Arduino</strong> Ã©quipÃ©e d'un <strong>shield Ethernet</strong>. Tel qu'il est donnÃ© au chap.Â R2â€‘IVÂ <a class="previous" href="../../ModuleR/R2-Applications/Rc2-4_webServeur.html#CandCpp" target="_BLANK"></a>, c'estâ€‘Ã â€‘dire sans prÃ©cautions particuliÃ¨res, le <strong>bilan de la compilation</strong> par le logiciel <strong class="Arduino">ArduinoÂ <em class="sigle">IDE</em></strong> sur un modÃ¨le de carteÂ <strong class="Arduino">Uno</strong> est le suivantÂ : </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Le croquis utilise 16274 octets (50%) de l'espace de stockage de programmes. Le maximum est de 32256 octets.
Les variables globales utilisent 961 octets (46%) de mÃ©moire dynamique, ce qui laisse 1087 octets pour les variables locales. Le maximum est de 2048 octets.
</pre>
<!---------- ne pas indenter ---------->    

<p> Certes, lors de l'exÃ©cution, on n'observe <strong class="pros">aucun dysfonctionnement</strong>, parce que l'espace restant pour la pile et le tas (les variables locales) est suffisant au peu de donnÃ©es que les fonctions appelÃ©es manipulent. Mais on peut nÃ©anmoins observer qu'avec <strong>une page web de taille extrÃªmement rÃ©duite</strong>, ce programme mobilise dÃ©jÃ Â <strong class="warning">46Â % de laÂ <em class="sigle">RAM</em></strong>. Il suffirait donc que le code de la page web soit un peu plus long pour causer une saturationâ€¦ </p>

<p class="square"> Pour l'expÃ©rience, localisons dans la <strong class="defin">mÃ©moire flash</strong> les principales chaÃ®nes de caractÃ¨res employÃ©es dans le programme. </p>

<ol class="numbered">
  <li> On invoque la <strong class="specialLB">macroâ€‘dÃ©finition</strong>Â <code class="prettyprint lang-c">PROGMEN</code> dans le descripteur de type de chacune des chaÃ®nes <code class="prettyprint lang-c">pageHead</code> et <code class="prettyprint lang-c">pageTail</code> â€“Â cf.Â les lignesÂ nÂ°Â 10Â &Â 19 dans le code ciâ€‘aprÃ¨s.  </li>

  <div class="nobullet"> Lors de la lecture de ces donnÃ©es, on doit alors prendre soin de leur appliquer une <strong class="warning">conversion spÃ©ciale</strong> (<code class="prettyprint lang-c">reinterpret_cast</code>Â <a class="external" href="https://en.cppreference.com/w/cpp/language/reinterpret_cast" target="_BLANK">C++</a>)  â€“Â cf.Â les lignesÂ nÂ°Â 50Â &Â 57 dans le code ciâ€‘aprÃ¨s. </div>

  <li> On applique la <strong class="specialLB">pseudoâ€‘fonction</strong>Â <code class="prettyprint lang-c">F</code> aux constantes littÃ©rales chaÃ®nes de caractÃ¨res constituant l'argument effectif des appels de fonctions <code class="prettyprint lang-c">client.print</code> ou <code class="prettyprint lang-c">client.println</code> â€“Â cf.Â les lignesÂ nÂ°Â 47, 48, 52Â &Â 55 dans le code ciâ€‘aprÃ¨s.  </li>
</ol>
   
<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;SPI.h&gt;
#include &lt;Ethernet.h&gt;

const int spiEthernetPin = 10; // pin number on board

byte mac[] = {0x90, 0xA2, 0xDA, 0x0D, 0x15, 0x43};

EthernetServer server(80);

const char pageHead[] PROGMEM = R"=====(
&lt;!DOCTYPE html&gt;
  &lt;html lang='fr'&gt;
  &lt;head&gt;
    &lt;meta charset='utf-8'&gt;
    &lt;title&gt;Dynamic page Arduino&lt;/title&gt;
  &lt;/head&gt;
)=====";

const char pageTail[] PROGMEM = R"=====(
&lt;h1&gt; Dynamic page example embedded on Arduino board &lt;/h1&gt;
&lt;p&gt;&lt;a href='./?bgcolor=white'&gt;White&lt;/a&gt;
   Â Â &lt;!-- 2 nonâ€‘break spaces here as inter-margin --&gt;
   &lt;a href='./?bgcolor=yellow'&gt;Yellow&lt;/a&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
)=====";

void setup() {
  Ethernet.init(spiEthernetPin);
  Ethernet.begin(mac);
  // Serial.begin(115200); // only for debug
}

void loop() {
  EthernetClient client = server.available();
  if (client) {
    String clientRequest = "";
    bool currentLineIsBlank = true;
    while (client.connected()) {
      if (client.available()) {
        char c = client.read();
        if (clientRequest.length() < 25) {
          clientRequest += c;
          // Serial.write(c); // only for debug
        }
        if (c == '\n' && currentLineIsBlank) {
          client.println(F("HTTP/1.1 200 OK"));
          client.println(F("Content-Type: text/html"));
          client.println(); // blank line, start of response body
          client.println(reinterpret_cast &lt;const __FlashStringHelper*&gt; (pageHead));
          if (clientRequest.indexOf("bgcolor=yellow") > 0) {
            client.print(F("&lt;body style='background: yellow'&gt;"));
          }
          else {
            client.print(F("&lt;body style='background: white'&gt;"));
          }
          client.println(reinterpret_cast &lt;const __FlashStringHelper*&gt; (pageTail));
          break;
        }
        if (c == '\n') {
          currentLineIsBlank = true;
        } 
        else if (c != '\r') {
          currentLineIsBlank = false;
        }
      }
    }
    delay(1); // give the web browser time to receive the data
    client.stop();
  }
}
</pre>
<!---------- ne pas indenter ----------> 

<p> Le <strong>bilan de la compilation</strong> par le logiciel <strong class="Arduino">ArduinoÂ <em class="sigle">IDE</em></strong> est alors le suivantÂ : </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Le croquis utilise 16332 octets (50%) de l'espace de stockage de programmes. Le maximum est de 32256 octets.
Les variables globales utilisent 561 octets (27%) de mÃ©moire dynamique, ce qui laisse 1487 octets pour les variables locales. Le maximum est de 2048 octets.
</pre>
<!---------- ne pas indenter ---------->    

<p> On voit donc que la <strong><em class="sigle">RAM</em></strong> n'est maintenant occupÃ©e qu'Ã Â <strong class="pros">seulementÂ 27Â %</strong>, et ce sans que la mÃ©moire flash ait Ã©tÃ© significativement impactÃ©e. </p>
</div><!-- exemple -->


<ul>
  <li> Pour <strong class="pros">approfondir les bases</strong> surÂ <code class="prettyprint lang-c">PROGMEM</code> et <code class="prettyprint lang-c">F</code>, on pourra consulter cet <strong>article</strong>Â <a class="external" href="https://www.e-tinkers.com/2020/05/do-you-know-arduino-progmem-demystified/" target="_BLANK"></a>. </li>

  <li> Et pour se documenter en dÃ©tail sur les <strong class="title">autres macroâ€‘dÃ©finitions</strong> codÃ©es dans le fichier <code class="filename">avr/pgmspace.h</code>, on s'orientera sur cette <strong>page d'index</strong>Â <a class="external" href="https://www.nongnu.org/avr-libc/user-manual/group__avr__pgmspace.html" target="_BLANK"></a>. </li>
</ul>

</div><!-- expert -->






















<h2 id="donneesC-String"> Les donnÃ©es de type <em>chaÃ®ne deÂ caractÃ¨res</em> enÂ langageÂ <em>C</em> </h2>


<div class="complement">
<p> Comme cela a Ã©tÃ© briÃ¨vement expliquÃ© au chapitreÂ C2â€‘VIÂ <a class="previous" href="../C2-ElementsLangage/Cc2-6_entreesSortiesStandards.html#C-style_string" target="_BLANK"></a> et rappelÃ© en introduction du prÃ©sent chapitre, en langageÂ <strong>C</strong>, il n'existe <strong class="cons">pas</strong> de <strong class="specialG">type</strong> de donnÃ©e <strong class="title">chaÃ®ne de caractÃ¨res</strong> Ã  proprement parler, c'estâ€‘Ã â€‘dire qui permettrait de stocker en mÃ©moire une sÃ©quence de caractÃ¨res pouvant librement <strong class="defin">varier en longueur</strong> durant l'exÃ©cution du programme. </p>
</div><!-- complement -->

<div class="important">
<p> Dans un programme codÃ©Â <strong>C</strong>, pour dÃ©clarer une <strong class="title">donnÃ©e</strong> de type Â«Â <strong class="title">chaÃ®ne de caractÃ¨res</strong>Â Â», on est donc contraint d'employerÂ : </p>
<ul>
  <li> soit un <strong class="specialLB">tableau de caractÃ¨res</strong> qui peut Ãªtre <strong>initialisÃ© de faÃ§on globale</strong> avec une syntaxe similaire Ã  celle d'une constante littÃ©rale chaÃ®ne de caractÃ¨res (mais qui n'en ait pas une)Â ; c'est le <strong class="pros">type recommandÃ©</strong> pour une <strong class="defin">variable</strong>Â ;  </li>

  <li> soit un <strong class="specialLB">pointeur sur caractÃ¨res</strong>, dont la valeur est l'<strong>adresse</strong> ciblant une <strong>constante littÃ©rale chaÃ®ne de caractÃ¨res</strong>Â ; c'est une alternative acceptable lorsque l'on veut dÃ©clarer une <strong class="defin">constante</strong>Â ; </li>
</ul>
<p> Dans tous les cas, on parle de <strong class="title">chaÃ®ne de Â«Â styleÂ CÂ Â»</strong> â€“Â <strong>Câ€‘style string</strong> en anglaisÂ <a class="external" href="https://en.wiktionary.org/wiki/C-style_string" target="_BLANK">W</a>.</p>
</div><!-- important -->

<p> En langageÂ <strong>C++</strong>, mÃªme s'il existe d'autres solutions plus Ã©voluÃ©es, il est <strong class="pros">possible</strong> d'employer des <strong class="title">chaÃ®nes de styleÂ C</strong>.</p>



<h3 id="arrayStringDeclaration"> DÃ©claration d'une donnÃ©e de type tableauÂ deÂ caractÃ¨res </h3>



<div class="important">
<p> Dans un programme en langageÂ <strong>C</strong> ouÂ <strong>C++</strong>, la dÃ©claration d'une <strong class="title">variable</strong> de type <strong class="title">chaÃ®ne de styleÂ C</strong> se code prÃ©fÃ©rentiellement via la <strong class="specialLB">mÃªme syntaxe que pour un tableau unidimensionnel</strong> (cf.Â chap.Â C5â€‘IIIÂ <a class="previous" href="Cc5-3_tableauxDeclarations.html#declarationTab" target="_BLANK"></a>), avec les particularitÃ©s suivantesÂ : <br>
<span class="inline">
  <code class="prettyprint lang-c"><span class="nocode"><strong class="specialG">type de caractÃ¨re</strong>Â <strong class="specialN">identificateur</strong></span>[<span class="nocode"><strong class="specialLB">N</strong></span>] <span class="nocode"><span style="color: darkgrey; font-style: normal;">[</span></span> = <span class="nocode"><strong class="specialO">chaÃ®neÂ 1</strong>Â Â Â <strong class="specialO">chaÃ®neÂ 2</strong> <span style="color: darkgrey; font-style: normal;">Â â€¦Â <strong class="specialO">chaÃ®neÂ i</strong>Â ]</span></span>; </code>
</span> </p>
</div><!-- important -->

<div class="complement">
<p> Dans cette syntaxe particuliÃ¨re, on peut apporter les prÃ©cisions suivantes. </p>
<ul>
  <li> Comme dans toute dÃ©claration, on peut intÃ©grer des <strong class="defin">motsâ€‘clefs modificateurs</strong> comme <code class="prettyprint lang-c">const</code> (cf.Â chap.Â C2â€‘IIIÂ <a class="previous" href="../C2-ElementsLangage/Cc2-3_declarationDonnees.html#declarationConst" target="_BLANK"></a>) et/ou <code class="prettyprint lang-c">static</code> (cf.Â chap.Â C4â€‘IIÂ <a class="previous" href="../C4-Fonctions/Cc4-2_porteeDonnees.html#classeStatique" target="_BLANK"></a> etÂ C4â€‘VIÂ <a class="previous" href="../C4-Fonctions/Cc4-6_programmationModulaire.html#fichiersImplementation" target="_BLANK"></a>). En revanche, le codage du motâ€‘clef <code class="prettyprint lang-c">register</code> n'a <strong class="cons">aucun effet</strong>, puisqu'une chaÃ®ne est potentiellement un objet trop gros pour Ãªtre stockÃ©e en registre. </li>


  <li> Le <strong class="specialG">type de caractÃ¨re</strong> codÃ© peut Ã©ventuellement nÃ©cessiter le codage prÃ©alable d'une directive d'inclusion de <strong>fichier d'enâ€‘tÃªte</strong> de bibliothÃ¨que â€“Â par exemple, <code class="filename">uchar.h</code> pour les typesÂ <code class="prettyprint lang-c">char16_t</code> etÂ <code class="prettyprint lang-c">char32_t</code>.  </li>

  <li> L'<strong class="specialN">identificateur</strong> est le <strong>nom de la donnÃ©e</strong>. Comme pour tout identificateur de tableau, une occurrence ultÃ©rieure dans le code est, sauf exceptions, dÃ©gradÃ©e en un <strong class="defin">pointeur</strong> (cf.Â chap.Â C5â€‘IIIÂ <a class="previous" href="Cc5-3_tableauxDeclarations.html#decayArray" target="_BLANK"></a>) et on peut donc lui appliquer l'<strong class="defin">opÃ©rateur d'indexation</strong>Â <code class="prettyprint lang-c">[]</code> pour cibler les Ã©lÃ©ments du tableau. </li>
  
  <li> Comme pour toute dÃ©claration de tableau, le <strong>nombre d'Ã©lÃ©ments</strong>Â <strong class="specialLB">N</strong> est une <strong class="defin">expression optionnelle</strong> si l'initialisation est codÃ©e. Il doit s'agir une <strong>expression constante entiÃ¨re</strong> (cf.Â chap.Â C2â€‘IIÂ <a class="previous" href="../C2-ElementsLangage/Cc2-2_syntaxeFondamentale.html#expressionConstanteEntiere" target="_BLANK"></a>) â€“Â enÂ <strong>C++</strong>, simplement une expression constante ou une expression Ã©valuable, selon la classe d'allocation. </li>

  <div class="nobullet">  La valeur deÂ <strong class="specialLB">N</strong> code le <strong class="defin">nombre maximal d'unitÃ© d'encodage</strong> que la chaÃ®ne de caractÃ¨res dÃ©clarÃ©e peut contenir â€“Â <strong>caractÃ¨re de fin de chaÃ®ne</strong>Â <strong  class="specialDR"><em class="sigle">NUL</em></strong> <strong class="defin">inclus</strong>. </div>
  
  <div style="display: inline-block;">
    <img class="top-right" src="../img/chaineTableau.png" width="430px" style="margin-top:0.5em">
  <li> Les expressions optionnelles d'initialisation <strong class="specialO">chaÃ®neÂ 1</strong>, <strong class="specialO">chaÃ®neÂ 2</strong>â€¦ <strong class="specialO">chaÃ®neÂ i</strong> doivent Ãªtre codÃ©es conformÃ©ment Ã  la syntaxe des <strong>constantes littÃ©rales chaÃ®nes de caractÃ¨res</strong> dÃ©crite supraÂ <a class="supra" href="Cc5-6_chainesCaracteres.html#stringLiteral"></a>, sachant queÂ : </li>
  <ul>
    <li> leur Ã©ventuel <strong>prÃ©fixe d'encodage</strong> doit Ãªtre <strong>compatible</strong> avec le <strong class="specialG">type de caractÃ¨re</strong> dÃ©clarÃ©Â ;  </li>
  
    <li> ces chaÃ®nes sont assemblÃ©es l'un aprÃ¨s l'autre par <strong>concatÃ©nation</strong> pour constituer une <strong  class="specialO">liste unique de caractÃ¨res</strong> formant les valeurs initiales des Ã©lÃ©ments ordonnÃ©s du tableau dÃ©clarÃ©. Au total, le nombreÂ <strong class="specialO">K</strong> d'unitÃ©s d'encodage nÃ©cessaires pour tous ces caractÃ¨res doit Ãªtre <strong>infÃ©rieur ou Ã©gal</strong> Ã  la valeur deÂ <strong class="specialLB">NÂ âˆ’Â 1</strong> si le nombre d'Ã©lÃ©ments du tableauÂ <strong class="specialLB">N</strong> est codÃ©. En son absence, la taille du tableau est automatiquement fixÃ©e Ã  la valeurÂ <strong class="specialO">KÂ +Â 1</strong> pour inclure automatiquement le <strong>caractÃ¨re de fin de chaÃ®ne</strong>Â <strong  class="specialDR"><em class="sigle">NUL</em></strong>.  </li>
  </ul>
  <div class="nobullet"> Ces chaÃ®nes de caractÃ¨res ne sont donc <strong class="warning">pas stockÃ©es</strong> comme des constantes littÃ©rales dans le segmentÂ <code class="inv" style="background:springgreen;">.rodata</code> de la mÃ©moire allouÃ©e au programme. </div>
  </div><!-- display -->
</ul>
</div><!-- complement -->

<div class="expert"> 
<p> Le fait de pouvoir coder la <strong class="title">valeur initiale</strong> de la variable de caractÃ¨res en <strong>plusieurs parties</strong> <strong class="specialO">chaÃ®neÂ 1</strong>, <strong class="specialO">chaÃ®neÂ 2</strong>â€¦Â est <strong class="pros">utile</strong> pour coder une <strong>longue chaÃ®ne</strong> sur <strong>plusieurs lignes</strong> dans le fichier source. En effet, cela n'est pas possible avec une seule chaÃ®ne â€“Â cf.Â supraÂ <a class="supra" href="Cc5-6_chainesCaracteres.html#stringLiteral"></a>Â â€“ sauf si on code une chaÃ®ne brute ou si l'on code Ã  la fin de chaque ligne un <strong>saut de ligne fictif</strong> via le caractÃ¨re de contrÃ´leÂ <code>\</code>). </p>

<p> Il est Ã©galement possible, comme pour tout tableau, de coder l'<strong class="title">initialisation de la chaÃ®ne</strong> sous la forme d'une <strong class="defin">liste d'Ã©lÃ©ments</strong>, chacun constituant un caractÃ¨re de la chaÃ®ne, comme ciâ€‘dessousÂ : <br>
<span class="inline">
  <code class="prettyprint lang-c">Â Â <span class="nocode"><span style="color: darkgrey; font-style: normal;">â€¦</span></span> = {<span class="nocode"><strong class="specialO">c<sub>0</sub></strong></span>, <span class="nocode"><strong class="specialO">c<sub>1</sub></strong></span>, <span class="nocode"><strong class="specialO">c<sub>2</sub></strong></span>, <span class="nocode"><span style="color: darkgrey; font-style: normal;">â€¦</span></span> };  </code>
</span> <br>
Dans ce cas, il faut <strong class="warning">ne pas oublier</strong> de coder en dernier le <strong>caractÃ¨re de fin de chaÃ®ne</strong>Â <strong class="specialDR"><em class="sigle">NUL</em></strong> (<code class="prettyprint lang-c">0x0</code>) car via cette syntaxe, il n'est <strong class="defin">pas automatiquement ajoutÃ©</strong> par le compilateur. </p>
</div><!-- expert -->

<div class="exemples">
<p class="exemple"> La dÃ©claration acadÃ©mique ciâ€‘dessousÂ : <br>
<span class="inline">
  <code class="prettyprint lang-c">static char s[] = "Foo" "Bar";</code>
</span> <br>
crÃ©e dans le segmentÂ <code class="inv" style="background:mediumseagreen;">.data</code> de la mÃ©moire allouÃ©e au programme une <strong class="title">variable</strong> de type <strong>tableau deÂ 7Â caractÃ¨res</strong>Â <strong><em class="sigle">ASCII</em></strong> ouÂ <strong><em class="sigle">UTFâ€‘8</em></strong> (selon l'implÃ©mentation) initialisÃ©s respectivement dans leur ordre d'indexation avec les valeurs de la liste ciâ€‘dessousÂ : <br>
<span class="inline">
  <code class="prettyprint lang-c">{'F', 'o', 'o', 'B', 'a', 'r', 0x0}  </code>
</span> </p>

<p> En employant une mÃ©thode de <strong>scan mÃ©moire</strong> similaire Ã  celle des exemples supraÂ <a class="supra" href="Cc5-6_chainesCaracteres.html#exScanRodata"></a>, le rÃ©sultat de cette dÃ©claration peut Ãªtre observÃ© Ã  l'aide du programme ciâ€‘dessousÂ : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

char dataStart = '$';

int main(void) {
  static char str[] = "Foo" "Bar";

  printf("%s \t %zu bytes\n", str, sizeof(str));
  printf("%p %c .data\n", &dataStart,   dataStart);
  char * p = str;
  do {
    if (isprint(*p)) 
      printf("%p %c\n", p, *p);
    else // non printable character
      printf("%p 0x%X\n", p, *p);
  }
  while (*p++ != 0x0);
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

  <p> ExÃ©cutÃ© sur <strong class="OnlineGDB">OnlineGDB</strong>, ce programme produit en sortie standard l'affichage suivantÂ :  </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
FooBar   7 bytes
0x55ce33cef010 $ .data
0x55ce33cef011 F
0x55ce33cef012 o
0x55ce33cef013 o
0x55ce33cef014 B
0x55ce33cef015 a
0x55ce33cef016 r
0x55ce33cef017 0x0
</pre>
<!---------- ne pas indenter ----------> 


<p class="square"> Si, dans le programme prÃ©cÃ©dent, on remplace la ligneÂ nÂ°Â 7 par la dÃ©claration ciâ€‘dessous oÃ¹ le <strong class="specialLB">nombre d'Ã©lÃ©ments</strong> deÂ <code class="prettyprint lang-c">str</code> est codÃ©Â : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:7">
  static char str[10] = "Foo" "Bar";
</pre>
<!---------- ne pas indenter ---------->

<p> alors on obtient presque la mÃªme sortie standardÂ : </p> 

<!---------- ne pas indenter ---------->
<pre class="displayDark">
FooBar   10 bytes
0x564142413010 $ .data
0x564142413018 F
0x564142413019 o
0x56414241301a o
0x56414241301b B
0x56414241301c a
0x56414241301d r
0x56414241301e 0x0
</pre>
<!---------- ne pas indenter ----------> 


<p> La premiÃ¨re ligne change puisque la <strong>taille</strong> deÂ <code class="prettyprint lang-c">str</code> est deÂ <strong>10Â octets</strong>. La variable dispose deÂ 3Â octets supplÃ©mentaires pour d'Ã©ventuelles modifications ultÃ©rieures. </p>

<div class="expert">
<p> De plus, l'<strong>adresse</strong> deÂ <code class="prettyprint lang-c">str</code> (celle de son premier Ã©lÃ©ment) n'est pas immÃ©diatement consÃ©cutive Ã  celle de <code class="prettyprint lang-c">dataStart</code> car le compilateur a respectÃ© une <strong>contrainte d'alignement</strong>. </p>

<p class="square"> Mais si code un <strong class="specialLB">nombre d'Ã©lÃ©ments</strong> <strong class="cons">insuffisant</strong> dans la dÃ©claration deÂ <code class="prettyprint lang-c">str</code> comme par exemple ciâ€‘dessousÂ : <br>
<span class="inline">
  <code class="prettyprint lang-c">static char str[5] = "Foo" "Bar";</code>
</span> <br>
on obtient un <strong class="specialY">avertissement du compilateur</strong> et une chaÃ®ne dont le contenu est tronquÃ© par rapport Ã  la valeur initiale codÃ©eÂ : </p> 

<!---------- ne pas indenter ---------->
<pre class="displayDark">
<span style="color: yellow;">main.c:7:24: warning: initializer-string for array of chars is too long
    7 |   static char str[5] = "Foo" "Bar";
      |                        ^~~~~</span>
FooBa    5 bytes
0x55d6f4016010 $ .data
0x55d6f4016011 F
0x55d6f4016012 o
0x55d6f4016013 o
0x55d6f4016014 B
0x55d6f4016015 a
0x55d6f4016016 0x0
</pre>
<!---------- ne pas indenter ----------> 

</div><!-- expert -->
</div><!-- exemple -->



<h3 id="pointerStringDeclaration"> DÃ©claration d'une donnÃ©e de type pointeurÂ deÂ caractÃ¨res </h3>



<div class="important">
<p> Dans un programme en langageÂ <strong>C</strong> ouÂ <strong>C++</strong>, on  peut aussi dÃ©clarer une <strong class="title">donnÃ©e</strong> de type <strong class="title">chaÃ®ne de styleÂ C</strong> comme un <strong class="specialLB">pointeur de caractÃ¨re</strong> (cf.Â chap.Â C5â€‘IÂ <a class="previous" href="Cc5-1_pointeursGeneralites.html#declarationPointeur" target="_BLANK"></a>), avec les particularitÃ©s suivantesÂ : <br>
<span class="inline">
  <code class="prettyprint lang-c"><span class="nocode"><strong class="specialG">type de caractÃ¨re</strong>Â </span> * <span class="nocode"><strong class="specialN">identificateur</strong></span> = <span class="nocode"><strong class="specialO">chaÃ®neÂ 1</strong>Â <span class="nocode"><span style="color: darkgrey; font-style: normal;">[</span></span> <strong class="specialO">chaÃ®neÂ 2</strong> <span style="color: darkgrey; font-style: normal;">Â â€¦Â <strong class="specialO">chaÃ®neÂ i</strong>Â ]</span></span>; </code>
</span> </p>
</div><!-- important -->

<div class="complement">
<p> En ce qui concerneÂ : </p>
<ul>
  <li> le <strong class="specialG">type de caractÃ¨re</strong>Â ; </li>

  <li> les expressions <strong class="specialO">chaÃ®neÂ 1</strong>, <strong class="specialO">chaÃ®neÂ 2</strong> â€¦ <strong class="specialO">chaÃ®neÂ i</strong>Â ; </li>

  <li> et mÃªme l'<strong class="specialN">identificateur</strong> â€“Â puisqu'il s'agit d'un pointeur on peut donc aussi lui appliquer l'<strong class="defin">opÃ©rateur d'indexation</strong>Â <code class="prettyprint lang-c">[]</code> (cf.Â chap.Â C5â€‘IIIÂ <a class="previous" href="Cc5-3_tableauxDeclarations.html#operIndex" target="_BLANK"></a>)Â ;  </li>
</ul>
<p> on peut apporter les <strong class="title">mÃªmes prÃ©cisions</strong> que pour la dÃ©claration d'une chaÃ®ne de caractÃ¨res de <strong>type tableau</strong> (cf.Â supraÂ <a class="supra" href="http://www.lycee-ferry-versailles.fr/snir/ModuleC/C5-StructuresPointeurs/arrayStringDeclaration"></a>). </p>


<p> En revanche, on doit prendre conscience des <strong class="warning">diffÃ©rences cruciales</strong> suivantes. </p>
<div style="display: inline-block;">
    <img class="top-right" src="../img/chainePointeur.png" width="330px" style="margin-top:0.5em">
<ul>
  <li> La variable ainsi dÃ©clarÃ©e n'est <strong class="cons">pas vÃ©ritablement</strong> une <strong>chaÃ®ne de caractÃ¨res</strong> mais un <strong class="specialPB">pointeur sur une constante littÃ©rale</strong> chaÃ®ne de caractÃ¨res. DoncÂ :  </li>
  <ul>
    <li> sa <strong>taille</strong> est invariablement celle d'un pointeur â€“Â typiquement, 8Â octets sur une machine Ã  architectureÂ <em class="mark">x86â€‘64Â bits</em>Â ;  </li>

    <div class="expert">
    <div class="nobullet"> (et il n'y a aucun moyen de dÃ©terminer la taille de la chaÃ®ne pointÃ©e Ã  l'aide de l'opÃ©rateurÂ <code class="prettyprint lang-c">sizeof</code>) </div>  
    </div><!-- expert -->
  
    <li> rien n'interdit d'affecter Ã  cette variable pointeur une <strong>autre adresse</strong> de donnÃ©e d'un type compatible (Ã©ventuellement via une conversion explicite), en particulier une autre constante littÃ©rale chaÃ®ne de caractÃ¨res.  </li>
  </ul>
  
  <li> La <strong>position</strong> d'un Ã©ventuel <strong>motâ€‘clef</strong> <code class="prettyprint lang-c">const</code> ajoutÃ© dans le descripteur de type n'est <strong class="warning">pas indiffÃ©rente</strong> â€“Â cf.Â la distinction exposÃ©e au chap.Â C5â€‘IÂ <a class="previous" href="Cc5-1_pointeursGeneralites.html#constantVSlectureSeule" target="_BLANK"></a> entreÂ : </li>
  <ul>
    <li> un <strong>pointeur constant</strong>, dont la dÃ©claration commence par  <code class="prettyprint lang-c">char * const</code>, et qui ne peut pas faire l'objet d'une affectation aprÃ¨s son initialisationÂ ;   </li>
  
    <li> et un <strong>pointeur en Â«Â lecture seuleÂ Â»</strong>, dont la dÃ©claration commence par <code class="prettyprint lang-c">const char *</code>, et qui interdit la modification de la donnÃ©e pointÃ©e (qui est dÃ©jÃ  impossible puisqu'il s'agit d'une constante littÃ©rale de type chaÃ®ne de caractÃ¨res).  </li>
  </ul>
</ul>
</div><!-- display -->
</div><!-- complement -->


<div class="exemples">
<p class="exemple"> La dÃ©claration acadÃ©mique ciâ€‘dessousÂ : <br>
<span class="inline">
  <code class="prettyprint lang-c">static char * str = "Foo" "Bar";</code>
</span> <br>
crÃ©e dans le segmentÂ <code class="inv" style="background:mediumseagreen;">.data</code> de la mÃ©moire allouÃ©e au programme une <strong class="title">variable</strong> nommÃ©eÂ <code class="prettyprint lang-c">str</code> de type <strong>pointeur de caractÃ¨re</strong>Â <strong><em class="sigle">ASCII</em></strong> ouÂ <strong><em class="sigle">UTFâ€‘8</em></strong> (selon l'implÃ©mentation). La valeur de ce pointeur est l'adresse de la <strong>constante littÃ©rale</strong>Â <code class="prettyprint lang-c">"FooBar"</code> stockÃ©e dans le segmentÂ <code class="inv" style="background:springgreen;">.rodata</code>. </p>

<p> En employant une mÃ©thode de <strong>scan mÃ©moire</strong> similaire Ã  celle des exemples supraÂ <a class="supra" href="Cc5-6_chainesCaracteres.html#exScanRodata"></a>, le rÃ©sultat de cette dÃ©claration peut Ãªtre observÃ© Ã  l'aide du programme ciâ€‘dessousÂ : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

const char rodataStart = '#';
char       dataStart   = '$';


int main(void) {
  static char * str = "Foo" "Bar";
  printf("%s \t %zu bytes\n", str, sizeof(str));

  printf("%p %c .data\n", &dataStart, dataStart);
  printf("%p %p\n", &str, str);

  printf("%p %c .rodata\n", &rodataStart, rodataStart);
  char * p = str;
  do {
    if (isprint(*p)) 
      printf("%p %c\n", p, *p);
    else // non printable character
      printf("%p 0x%X\n", p, *p);
  }
  while (*p++ != 0x0);
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

  <p> ExÃ©cutÃ© sur <strong class="OnlineGDB">OnlineGDB</strong>, ce programme produit en sortie standard l'affichage suivantÂ :  </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
FooBar   8 bytes
0x565536182010 $ .data
0x565536182018 0x56553618002b
0x565536180004 # .rodata
0x56553618002b F
0x56553618002c o
0x56553618002d o
0x56553618002e B
0x56553618002f a
0x565536180030 r
0x565536180031 0x0
</pre>
<!---------- ne pas indenter ----------> 

  <p> On peut vÃ©rifier notamment que la <strong class="title">variable</strong>Â <code class="prettyprint lang-c">str</code>Â : </p>
  <ul>
    <li> a une <strong>taille</strong> deÂ <strong>8Â octets</strong>, ce qui est bien celle d'un pointeur (ce n'est pas du tout la taille de la chaÃ®ne qu'elle pointe)Â ;  </li>
  
    <li> est stockÃ©e dans le <strong>segment</strong>Â <code class="inv" style="background:mediumseagreen;">.data</code>Â ;  </li>

    <li> prend pour valeur l'<strong>adresse</strong>Â <code>0x56553618002b</code> qui est celle du premier octet de la constante littÃ©raleÂ <code class="prettyprint lang-c">"FooBar"</code> â€“Â laquelle est dans le <strong>segment</strong>Â <code class="inv" style="background:springgreen;">.rodata</code>.   </li>
  </ul>
  
</div><!-- exemple -->



<h3> Lecture et Ã©criture des chaÃ®nesÂ deÂ caractÃ¨res deÂ styleÂ C </h3>


<h4> Cas d'une chaÃ®ne de caractÃ¨res dÃ©clarÃ©e commeÂ unÂ tableau </h4>


<div class="important">
<p> Dans son espace de visibilitÃ©, une variable <strong class="title">chaÃ®ne de caractÃ¨res</strong> dÃ©clarÃ©e comme un <strong class="title">tableau</strong> (cf.Â supraÂ <a class="supra" href="Cc5-6_chainesCaracteres.html#arrayStringDeclaration"></a> et leÂ chap.Â C5â€‘IVÂ <a class="previous" href="Cc5-4_tableauxManipulations.html#manipulation" target="_BLANK"></a>)Â : </p>
<ul>
  <li> est accessible en <strong class="defin">lecture</strong> et en <strong class="defin">Ã©criture</strong>, <strong>Ã©lÃ©ment par Ã©lÃ©ment</strong>, par exemple via une expression de la formeÂ : <br>
 <span class="inline">
  <code class="prettyprint lang-c"><span class="nocode"><strong class="specialN">identificateur</strong></span>[<span class="nocode"><strong class="specialLB">i</strong></span>] = <span class="nocode"><strong>expression</strong></span> </code> 
 </span> </li>

  <li> mais ne peut <strong class="warning">pas</strong> faire l'objet d'une <strong class="warning">affectation globale</strong> par exemple via une expression de la formeÂ : <br>
 <span class="inline">
  <code class="prettyprint lang-c" style="background: lightgrey;"><span class="nocode"><strong class="specialN">identificateur</strong></span> = <span class="nocode"><strong class="specialO">autre chaÃ®ne</strong></span> // build error </code> 
 </span> </li>
</ul>
</div><!-- important -->

<div class="exemples">
<p class="exemple"> Dans le programme acadÃ©mique ciâ€‘dessous, aprÃ¨s avoir dÃ©clarÃ© une <strong class="title">chaÃ®ne de caractÃ¨re de type tableau</strong>, on peut coder une <strong class="defin">modification de sa valeur Ã©lÃ©ment par Ã©lÃ©ment</strong> (cf.Â la ligneÂ nÂ°Â 7)Â :  </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;

int main(void) {
  char str[] = "Foo";
  printf("%s \t (%p)\n", str, str);
  
  str[0] = 'B', str[1] = 'a', str[2] = 'r';
  printf("%s \t (%p)\n", str, str);
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

<p> ExÃ©cutÃ© sur <strong class="OnlineGDB">OnlineGDB</strong>, on obtient un affichage <strong class="pros">conforme</strong> Ã  celui attenduÂ :  </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Foo    (0x7ffd20f17b94)
Bar    (0x7ffd20f17b94)
</pre>
<!---------- ne pas indenter ----------> 

<p> et l'on peut constater que l'adresse deÂ <code class="prettyprint lang-c">str</code> ne change pas. </p>

<p class="square"> En revanche, si l'on tente de coder une <strong class="defin">affectation globale</strong>, par exempleÂ : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:7">
  str = "Bar"; // won't work hereâ€¦
</pre>
<!---------- ne pas indenter ---------->

<p> alors, comme prÃ©vu, le compilateur signale une <strong class="warning">erreur</strong>Â : </p>
<!---------- ne pas indenter ---------->
<pre class="displayDark">
<span style="color: orangered">main.c:7:7: error: assignment to expression with array type</span>
    7 |   str = "Bar"; // won't work hereâ€¦
      |       ^
</pre>
<!---------- ne pas indenter ----------> 

</div><!-- exemple -->


<h4> Cas d'une chaÃ®ne de caractÃ¨res dÃ©clarÃ©e commeÂ unÂ pointeur </h4>


<div class="important">
<p> Dans son espace de visibilitÃ©, une variable <strong class="title">chaÃ®ne de caractÃ¨res</strong> dÃ©clarÃ©e comme un <strong class="title">pointeur</strong> (cf.Â supraÂ <a class="supra" href="Cc5-6_chainesCaracteres.html#pointerStringDeclaration"></a> et leÂ chap.Â C5â€‘IÂ <a class="previous" href="Cc5-1_pointeursGeneralites.html#lesPointeurs" target="_BLANK"></a>)Â : </p>
<ul>
  <li> permet d'accÃ©der <strong>Ã©lÃ©ment par Ã©lÃ©ment</strong> Ã  la constante littÃ©rale qu'elle pointe en <strong class="defin">lecture</strong>, mais <strong class="warning">pas en Ã©criture</strong> via une expression de la formeÂ : <br>
  <span class="inline">
    <code class="prettyprint lang-c" style="background: lightgrey;"><span class="nocode"><strong class="specialN">identificateur</strong></span>[<span class="nocode"><strong class="specialLB">i</strong></span>] = <span class="nocode"><strong>expression</strong></span> // segment fault</code> 
  </span> <br>
  puisqu'il s'agit d'une constanteÂ ;  </li>

  <li> mais peut faire l'objet d'une Â«Â <strong class="defin">affectation globale</strong>Â Â» pour pointer sur une <strong class="specialO">autre constante littÃ©rale</strong>, par exemple via une expression de la formeÂ : <br>
  <span class="inline">
    <code class="prettyprint lang-c"><span class="nocode"><strong class="specialN">identificateur</strong></span> = <span class="nocode"><strong class="specialO">autre chaÃ®ne</strong></span> </code> 
  </span> <br>
  <strong class="warning">sauf</strong> bien entendu si la donnÃ©e a Ã©tÃ© dÃ©clarÃ©e comme un <strong>pointeur constant</strong>Â (cf.Â chap.Â C5â€‘IÂ <a class="previous" href="Cc5-1_pointeursGeneralites.html#pointeurConstant" target="_BLANK"></a>).  </li>
</ul>
</div><!-- important -->

<div class="complement">
<p> Ici, il est essentiel comprendre que toute Â«Â <strong class="title">affectation Â«Â globaleÂ Â»</strong> sur une <strong>chaÃ®ne de caractÃ¨res dÃ©clarÃ©e comme un pointeur</strong> ne <strong class="warning">modifie pas</strong> la constante littÃ©rale pointÃ©e. En effetÂ : </p>
<ul>
  <li> cette derniÃ¨re reste stockÃ©e telle quelle dans le segmentÂ <code class="inv" style="background:springgreen;">.rodata</code>Â ;  </li>

  <li> simplement la valeur du pointeur <strong class="defin">change d'adresse</strong> pour pointer sur la constante littÃ©rale <strong class="specialO">autre chaÃ®ne</strong> qui constitue laÂ <strong class="specialMg">râ€‘value</strong> de l'affectation, et qui est stockÃ©e ailleurs dans le segmentÂ <code class="inv" style="background:springgreen;">.rodata</code>. </li>
</ul>
</div><!-- complement -->

<div class="expert">
<p> PrÃ©cisons Ã©galement que la syntaxe d'<strong class="title">affectation globale</strong> sur pointeur de caractÃ¨re n'autorise pour le codage de laÂ <strong class="specialMg">râ€‘value</strong> qu'<strong>une seule expression</strong> <strong class="specialLB">chaÃ®ne</strong>, et non pas plusieurs, comme pour l'initialisation dans une dÃ©claration. Autrement dit, une expression commeÂ : <br>
<span class="inline">
  <code class="prettyprint lang-c" style="background: lightgrey;"><span class="nocode"><strong class="specialN">identificateur</strong></span> = <span class="nocode"><strong class="specialO">chaÃ®neÂ 1</strong>Â Â <strong class="specialO">chaÃ®neÂ 2</strong> </span> // build error </code> 
</span> <br>
provoque une <strong class="warning">erreur de compilation</strong>. </p>
</div><!-- expert -->

<div class="exemples">
<p class="exemple"> Dans le programme acadÃ©mique ciâ€‘dessous, aprÃ¨s avoir dÃ©clarÃ© une <strong class="title">chaÃ®ne de caractÃ¨re de type pointeur</strong>, on peut coder une <strong class="defin">affectation Â«Â globaleÂ Â»</strong> (cf.Â la ligneÂ nÂ°Â 7)Â :  </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;

int main(void) {
  char * str = "Foo";
  printf("%s \t (%p)\n", str, str);
  
  str = "Bar";
  printf("%s \t (%p)\n", str, str);
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

<p> ExÃ©cutÃ© sur <strong class="OnlineGDB">OnlineGDB</strong>, on obtient un affichage <strong class="pros">conforme</strong> Ã  celui attenduÂ :  </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Foo    (0x5631624e2004)
Bar    (0x5631624e2013)
</pre>
<!---------- ne pas indenter ----------> 

<p> sachant que ce n'est pas la constante littÃ©raleÂ <code class="prettyprint lang-c">Foo</code> qui a Ã©tÃ© modifiÃ©e, mais simplement la valeur deÂ <code class="prettyprint lang-c">str</code> qui pointe sur une autre constante littÃ©rale â€“Â <code class="prettyprint lang-c">Bar</code>. </p>

<p class="square"> En revanche, si l'on tente de coder une <strong class="defin">affectation sur un des Ã©lÃ©ments</strong> de la constante littÃ©rale sur laquelleÂ <code class="prettyprint lang-c">str</code> pointe, par exemple Â : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:7">
  str[0] = 'f'; // won't work hereâ€¦
</pre>
<!---------- ne pas indenter ---------->

<p> alors le programme semble s'exÃ©cuter, mais avec un <strong class="cons">affichage non conforme</strong> Ã  ce qui est attendu (pas deÂ 2<sup>e</sup>Â ligne)Â :  </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Foo    (0x562c9bde9004)
</pre>
<!---------- ne pas indenter ----------> 

<p> En fait, si on effectue la mÃªme expÃ©rience avecÂ <strong>GCC</strong> sur un <em class="mark">PCÂ Linux</em>, on constate une <strong class="warning">erreur d'exÃ©cution</strong> avec le messageÂ : </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
<span style="color: orangered">Erreur de segmentation (core dumped)</span>
</pre>
<!---------- ne pas indenter ---------->

</div><!-- exemple -->



<h3> Transmission d'une chaÃ®neÂ deÂ caractÃ¨res deÂ styleÂ <em>C</em> comme argumentÂ deÂ fonction </h3>



<p class="square" style="margin-top:0em"> Rappelons qu'en langageÂ <strong>C</strong> (cf.Â chap.Â C5â€‘IVÂ <a class="previous" href="Cc5-4_tableauxManipulations.html#transmissionTableau" target="_BLANK"></a>), la <strong class="title">transmission d'un tableau</strong> comme argument de fonction peut Ãªtre codÃ©e <strong class="defin">seulement par adresse</strong> â€“Â ou Ã©ventuellement aussi par <strong class="defin">rÃ©fÃ©rence</strong> enÂ <strong>C++</strong>. </p>

<p> Lorsqu'on procÃ¨de par adresse, dans l'<strong class="title">enâ€‘tÃªte de la fonction</strong>, un tel <strong class="specialT">argument formel</strong> est donc un <strong class="defin">pointeur</strong>. L'usage fait qu'il est le plus souvent codÃ© comme tel, c'estâ€‘Ã â€‘dire via la syntaxeÂ : <br>
<span class="inline">
  <code class="prettyprint lang-c"><span class="nocode"><strong class="specialG">descripteur de type</strong></span> * <span class="nocode"><strong class="specialN">identificateur</strong></span> </code> 
</span> <br>
surtout si l'argument est manipulÃ© comme un pointeur dans le corps de dÃ©finition de la fonction. </p>

<div class="expert">
<p> Bien entendu, il est toujours possible d'employer la <strong class="specialLB">syntaxe alternative Ã©quivalente</strong>Â : <br>
<span class="inline">
  <code class="prettyprint lang-c"><span class="nocode"><strong class="specialG">descripteur de type</strong></span> <span class="nocode"><strong class="specialN">identificateur</strong></span>[]</code> 
</span> <br> 
ce qui est plus <strong class="pros">plus lisible</strong>, surtout si l'argument est manipulÃ© via l'opÃ©rateur d'indexation. </p>

<p> Cette <strong class="title">Ã©quivalence des deux syntaxes</strong> possible pour coder un <strong class="specialT">argument formel</strong> dans l'enâ€‘tÃªte d'une fonction est sans doute une <strong class="warning">grande source de confusion</strong> pour un codeur dÃ©butant Ã  qui l'on vient d'expliquer qu'il ne faut surtout pas les confondre pour la <strong class="defin">dÃ©claration d'une donnÃ©e</strong> de type chaÃ®ne de caractÃ¨res (cf.Â supraÂ <a class="previous" href="Cc5-6_chainesCaracteres.html#donneesC-String"></a>). </p>
</div><!-- expert -->


<p class="square"> Rappelons (cf.Â chap.Â C5â€‘IVÂ <a class="previous" href="Cc5-4_tableauxManipulations.html#codageTransmissionTableau" target="_BLANK"></a>) Ã©galement que la <strong class="title">transmission d'un tableau</strong> sous la forme d'un <strong class="specialT">argument formel</strong> de type pointeur prÃ©sente <strong class="warning">deux difficultÃ©s</strong>. </p>
<ul>
  <li> On subit la <strong class="cons">perte d'information</strong> du <strong class="specialLB">nombre d'Ã©lÃ©ments</strong> du tableau. </li>

  <div class="nobullet"> Donc, si cette information est nÃ©cessaire Ã  l'algorithme de la fonction, elle doit Ãªtre passÃ©e comme un argument supplÃ©mentaire. </div> 

  <li> On a la <strong class="cons">possibilitÃ© inhÃ©rente de modification</strong> de l'<strong class="specialO">argument effectif</strong>. </li>

  <div class="nobullet"> La rÃ¨gle est donc de coder le <strong>motâ€‘clef</strong>Â <code class="prettyprint lang-c">const</code> avant le descripteur de type de l'<strong class="specialT">argument formel</strong> lorsqu'on souhaite s'assurer que la fonction ne puisse opÃ©rer <strong>aucune modification</strong> sur l'<strong class="specialO">argument effectif</strong>. </div>
</ul>


<div class="important">
<p> Au regard de ces considÃ©rations, dans le cas particulier des <strong class="title">arguments de fonction</strong> de type <strong>chaÃ®ne de caractÃ¨res de styleÂ C</strong>, on peut retenir donc le principe suivantÂ : </p>
<ul>
    <li> si une fonction <strong>modifie</strong> un <strong class="specialT">argument formel</strong>, alors dans toute expression d'appel, l'<strong class="specialO">argument effectif</strong> correspondant doit <strong class="warning">obligatoirement</strong> Ãªtre une <strong>variable</strong> <strong class="defin">dÃ©clarÃ©e comme un tableau</strong>Â ;  </li>
  
    <li> si une fonction <strong>ne modifie pas</strong> un <strong class="specialT">argument formel</strong>, alors dans toute expression d'appel, l'<strong class="specialO">argument effectif</strong> correspondant peut Ãªtre <strong class="pros">indiffÃ©remment</strong> dÃ©clarÃ© comme un <strong class="defin">tableau</strong>, un <strong class="defin">pointeur</strong>, ou mÃªme simplement Ãªtre une <strong class="defin">constante littÃ©rale</strong>. </li>
  </ul>
</div><!-- important -->



<div class="exemples"><p class="exemples"></p>

<ol class="numbered">
  <li> Dans le programme ciâ€‘dessous, on code une <strong class="defin">fonction</strong> <code class="prettyprint lang-c">toupperString</code> qui <strong class="title">met en lettres majuscules</strong> une <strong>chaÃ®ne de caractÃ¨resÂ <em class="sigle">ASCII</em></strong> prise comme <strong class="specialT">argument formel</strong> unique faisant l'objet de <strong>modifications</strong>. </li>
  
  <div class="expert">
  <div class="nobullet"> On utilise pour cela (cf.Â la ligneÂ nÂ°Â 6) des fonctions de la bibliothÃ¨que standard du langageÂ <strong>C</strong> (fichier d'enâ€‘tÃªte <code class="filename">ctype.h</code>, cf.Â chap.Â C3â€‘VIIIÂ <a class="previous" href="../C3-Numeration/Cc3-8_typesCaracteres.html#fonctionsTest" target="_BLANK"></a>)Â : </div>
  <ul>
    <li> la fonction <code class="prettyprint lang-c">islower</code> pour dÃ©terminer si un caractÃ¨re est une <strong>lettre minuscule</strong> (<em class="english">lowercase</em>)Â ;  </li>
  
    <li> la fonctionÂ <code class="prettyprint lang-c">toupper</code> qui retourne la <strong>majuscule</strong> (<em class="english">uppercase</em>) correspondant Ã  une minuscule. </li>
  </ul>
  <div class="nobullet"> Ces deux fonctions sont dÃ©clarÃ©es dans le  </div>
  </div><!-- expert -->

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

void toupperString(char * str) {
  do {
    if (islower(*str)) *str = toupper(*str);
  }
  while (*++str);
}

int main(void) {
  char fbs[] = "Foo bar.";
  printf("%s\n", fbs);
  toupperString(fbs);
  printf("%s\n", fbs);
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->  

  <div class="nobullet"> La fonction <code class="prettyprint lang-c">toupperString</code> ne peut Ãªtre appelÃ©e qu'avec pour <strong class="specialO">argument effectif</strong> une chaÃ®ne de caractÃ¨re <strong class="defin">dÃ©clarÃ©e comme un tableau</strong>, comme par exemple Ã  la ligneÂ nÂ°Â 12 dans la fonctionÂ <code class="prettyprint lang-c">main</code> du programme ciâ€‘dessus. </div>

  <div class="nobullet"> Ã€ l'exÃ©cution sur <strong class="OnlineGDB">OnlineGDB</strong>, on obtient bien la sortie standard attendueÂ :  </div>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Foo Bar.
FOO BAR.
</pre>
<!---------- ne pas indenter ---------->

  <div class="nobullet"> En revanche, si Ã  la ligneÂ nÂ°Â 12, la chaÃ®ne de caractÃ¨reÂ <code class="prettyprint lang-c">fbs</code> Ã©tait <strong class="warning">dÃ©clarÃ©e comme un pointeur</strong> â€“Â c'estâ€‘Ã â€‘dire, pourtant exactement comme dans l'enâ€‘tÃªte de la fonctionÂ :  </div>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:12">
  char * fbs = "Foo bar."; // will cause a segment fault!
</pre>
<!---------- ne pas indenter ---------->
  
  <div class="nobullet"> alors, sur <strong class="OnlineGDB">OnlineGDB</strong>, on obtient une <strong class="warning">sortie standard tronquÃ©e</strong> (seule la premiÃ¨re ligne est affichÃ©e). Et en effectuant la mÃªme expÃ©rience avecÂ <strong>GCC</strong> sur un <em class="mark">PCÂ Linux</em>, on constate comme prÃ©vu une <strong class="warning">erreur d'exÃ©cution</strong> avec le messageÂ : </div>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Foo Bar.
<span style="color: orangered">Erreur de segmentation (core dumped)</span>
</pre>
<!---------- ne pas indenter ---------->


  <li style="margin-top: 1em;"> Dans le programme ciâ€‘dessous, on code une <strong>fonction</strong> <code class="prettyprint lang-c">wordCount</code> qui <strong class="title">compte le nombre de mots</strong> dans une <strong>chaÃ®ne de caractÃ¨resÂ <em class="sigle">ASCII</em></strong> prise comme <strong class="specialLB">argument formel</strong> en lecture seule. </li>

  <div class="expert">
  <div class="nobullet"> On utilise pour cela (cf.Â la ligneÂ nÂ°Â 8) la fonctionÂ <code class="prettyprint lang-c">isalnum</code> dÃ©clarÃ©e dans le fichier d'enâ€‘tÃªte <code class="filename">ctype.h</code> de la bibliothÃ¨que standard du langageÂ <strong>C</strong> (cf.Â chap.Â C3â€‘VIIIÂ <a class="previous" href="../C3-Numeration/Cc3-8_typesCaracteres.html#fonctionsManip" target="_BLANK"></a>). Elle dÃ©tecte les caractÃ¨res <strong>alphanumÃ©riques</strong>, ce qui permet de les distinguer des autres catÃ©gories de caractÃ¨res (espace, signes de ponctuation) qui ne constituent pas les mots. </div>
  </div><!-- expert -->


<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

size_t wordCount(const char * str) {
  size_t count  = 0;
  int    isWord = 0; // bool value
  do {
    if (isalnum(*str)) {
      if (!isWord) isWord = 1, count++;
    }
    else isWord = 0;
  }
  while (*++str);
  return count;
}

int main(void) {
  char * fbs = "Foo bar.";
  printf("\"%s\" contains %zu words\n", fbs, wordCount(fbs));
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->  

  <div class="nobullet"> La fonction <code class="prettyprint lang-c">wordCount</code> peut Ãªtre appelÃ©e avec <strong class="specialO">n'importe quel argument effectif</strong> de type <strong class="defin">chaÃ®ne de styleÂ C</strong>, qu'il soit dÃ©clarÃ© comme un <strong>tableau</strong>, un <strong>pointeur</strong> (cf.Â la ligneÂ nÂ°Â 18), ou mÃªme qu'il soit une <strong>constante littÃ©rale</strong>. </div>

  <div class="nobullet"> Ã€ l'exÃ©cution sur <strong class="OnlineGDB">OnlineGDB</strong>, on obtient bien la sortie standard attendueÂ :  </div>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
"Foo bar." contains 2 words
</pre>
<!---------- ne pas indenter ---------->

</ol><!-- numbered -->

<div class="expert">
<p class="remarque"> Dans les deux programmes ciâ€‘dessus, la clause qui dÃ©termine la <strong class="title">fin de boucle</strong>Â : <br>
<span class="inline">
  <code class="prettyprint lang-c">  while (*++str);</code> 
</span> <br> 
testeÂ : </p>
<ul>
  <li> la <strong>nonâ€‘Ã©galitÃ© Ã  zÃ©ro</strong> â€“Â c'estâ€‘Ã â€‘direÂ <code class="prettyprint lang-c"> != 0x0</code> qui code le caractÃ¨re de fin de chaÃ®neÂ ;   </li>

  <li> du <strong>code du caractÃ¨re</strong> pointÃ© parÂ <code class="prettyprint lang-c">str</code> â€“Â obtenu par dÃ©rÃ©fÃ©rencementÂ (opÃ©rateurÂ <code class="prettyprint lang-c">*</code>)Â ;  </li>

  <li> mais seulement <strong class="warning">aprÃ¨s</strong> avoir incrÃ©mentÃ©Â <code class="prettyprint lang-c">str</code> (cf.Â chap.Â C2â€‘IVÂ <a class="previous" href="../C2-ElementsLangage/Cc2-4_manipulationDonnees.html#compoundOperators#incremUnitaire" target="_BLANK"></a>). </li>
</ul>
</div><!-- expert -->

</div><!-- exemple -->



<h3> Retour d'une chaÃ®neÂ deÂ caractÃ¨res deÂ styleÂ <em>C</em> comme valeurÂ deÂ fonction </h3>



<p> Rappelons qu'en langagesÂ <strong>C</strong> etÂ <strong>C++</strong> (cf.Â chap.Â C5â€‘IVÂ <a class="previous" href="Cc5-4_tableauxManipulations.html#retourFonctionTableau" target="_BLANK"></a>), Ã  quelques exceptions prÃ¨s, il n'est <strong class="warning">pas possible</strong> de former une <strong class="title">expression</strong> dont la <strong class="defin">valeur</strong> est un <strong>tableau</strong>. </p>

<p> Par consÃ©quent, une fonction ne peut pas retourner une telle valeur, seulement un <strong class="title">pointeur</strong> sur une <strong>variable</strong> prÃ©alablement dÃ©clarÃ©e de type <strong class="defin">tableau</strong>, qui doit Ã©galement Ãªtre <strong class="defin">transmise comme argument</strong> de la fonction. </p>


<div class="complement">
<p> Ces considÃ©rations sont valables pour les <strong class="title">chaÃ®nes de caractÃ¨res de styleÂ C</strong> qui ne sont pas commode Ã  retourner comme valeur de fonction. </p>
</div><!-- complement -->



<h3 id="longueurChaine"> Longueur et taille d'une chaÃ®neÂ deÂ caractÃ¨res deÂ styleÂ <em>C</em> </h3>



<div class="important">
<p> En langagesÂ <strong>C</strong> etÂ <strong>C++</strong>, on considÃ¨re usuellement que la <strong class="title">longueur</strong> d'une <strong>chaÃ®ne de caractÃ¨res</strong> est le <strong class="defin">nombre d'unitÃ©s d'encodage</strong> nÃ©cessaires pour reprÃ©senter cet objet en mÃ©moire, le <strong>caractÃ¨re de fin de chaÃ®ne</strong>Â <strong  class="specialDR"><em class="sigle">NUL</em></strong> Ã©tant <strong class="warning">exclus</strong>. </p>
</div><!-- important -->

<div class="complement">
<p> En comparaison avec le <strong class="defin">nombre de caractÃ¨res</strong> qu'elle contient, la <strong class="title">longueur</strong> d'une <strong>chaÃ®ne de styleÂ C</strong> est doncÂ : </p>
<ul>
  <li> <strong class="pros">Ã©gale</strong> si son format d'encodage est Ã  <strong>taille fixe</strong> â€“Â <strong><em class="sigle">ASCII</em></strong> etÂ <strong><em class="sigle">UTFâ€‘32</em></strong>Â ;   </li>

  <li> <strong class="warning">plus grande</strong> si son format d'encodage est Ã  <strong>taille variable</strong> â€“Â <strong><em class="sigle">UTFâ€‘8</em></strong> etÂ <strong><em class="sigle">UTFâ€‘16</em></strong>. </li>
</ul>

<p> On peut facilement coder une <strong class="defin">fonction</strong> qui retourne la <strong class="title">longueur d'une chaÃ®ne</strong>, comme par exemple la solution trÃ¨s classique ciâ€‘dessous pour les chaÃ®nesÂ <strong><em class="sigle">ASCII</em></strong> etÂ <strong><em class="sigle">UTFâ€‘8</em></strong>Â : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
size_t stringLength(const char * str) {
  size_t length = 0;
  while (*str++) length++;
  return lenght;
}
</pre>
<!---------- ne pas indenter ---------->  

<p> sachant qu'il existe des solutions <strong class="pros">plus optimisÃ©es</strong> et <strong class="pros">robustes</strong> dÃ©jÃ  codÃ©es dans la <strong>bibliothÃ¨que standard</strong> du langageÂ <strong>C</strong>. </p>

<div class="expert">
<p class="square"> Pour compter le <strong class="title">nombre de caractÃ¨res</strong> d'une chaÃ®ne encodÃ©e enÂ <strong><em class="sigle">UTFâ€‘8</em></strong>, on peut coder la  variante ciâ€‘dessous Ã  peine plus complexeÂ : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
size_t u8stringLength(const char * str) {
  size_t length = 0;
  do {
    length += (*str & 0b11000000) != 0b10000000;
  }
  while (*++str);
  return length;
}
</pre>
<!---------- ne pas indenter ---------->  

<p> dans laquelle on ne compte <strong class="warning">pas</strong> les <strong class="specialLB">octets de suite</strong>, c'estâ€‘Ã â€‘dire prÃ©sentant le <strong>motif initial binaireÂ </strong>Â <code style="color: dodgerblue;">10</code> (cf.Â chap.Â C3â€‘IXÂ <a class="previous" href="../C3-Numeration/Cc3-9_typesCaracteresEtendus.html#encodageUTF-8" target="_BLANK"></a>).  </p>
</div><!-- expert --> 
</div><!-- complement -->


<p> Quant Ã  la <strong class="title">taille en mÃ©moire</strong> d'une <strong>chaÃ®ne de caractÃ¨res</strong> â€“Â qu'on obtient avec l'opÃ©rateurÂ <code class="prettyprint lang-c">sizeof</code>Â â€“Â  elle est Ã©gale au <strong class="defin">produit</strong>Â (Ã—) de la taille du <strong class="specialG">type</strong> d'encodage des caractÃ¨res parÂ : </p>
<ul>
  <li> le <strong>nombre total d'Ã©lÃ©ments</strong> du tableau dans le cas d'une donnÃ©e dÃ©clarÃ©e comme telÂ ;  </li>

  <li> le <strong>nombre total d'unitÃ©s d'encodage</strong> â€“Â caractÃ¨re de fin de chaÃ®neÂ <strong  class="specialDR"><em class="sigle">NUL</em></strong> <strong class="defin">inclus</strong>Â â€“Â dans le cas d'une constante littÃ©rale.  </li>
</ul>

<p> Rappelons par ailleurs (cf.Â chap.Â C5â€‘IIIÂ <a class="previous" href="Cc5-4_tableauxManipulations.html#routineNbElements" target="_BLANK"></a>) qu'il est facile de dÃ©terminer le <strong class="title">nombre d'Ã©lÃ©ments d'un tableau</strong> grÃ¢ce Ã  une pseudoâ€‘fonction commeÂ : <br>
<span class="inline">
  <code class="prettyprint lang-c">#define nbOfElements(tab) (sizeof(tab)/sizeof(tab[0]))</code>
</span> </p>



















<h2 id="fonctionsChaines"> Fonctions de la bibliothÃ¨que standard surÂ lesÂ chaÃ®nesÂ deÂ styleÂ C </h2>



<h3> GÃ©nÃ©ralitÃ©s </h3>



<div class="complement">
<p> Les chaÃ®nes de caractÃ¨res Ã©tant des objets complexes et nÃ©anmoins trÃ¨s utilisÃ©s en langagesÂ <strong>C</strong>, il existe une <strong class="title">plusieurs dizaines de fonctions</strong> dans la <strong class="defin">bibliothÃ¨que standard</strong> afin de les analyser et les manipuler facilement. </p>

<p> En particulier, pour les chaÃ®nes dont les <strong>unitÃ©s d'encodage</strong> sont de typeÂ <code class="prettyprint lang-c">char</code>, c'estâ€‘Ã â€‘dire au formatÂ <strong><em class="sigle">ASCII</em></strong> ouÂ <strong><em class="sigle">UTFâ€‘8</em></strong>Â <a class="external" href="https://en.cppreference.com/w/c/string/byte" target="_BLANK">C</a>Â : </p>
<ul>
  <li> le fichier d'enâ€‘tÃªteÂ <code class="filename">string.h</code> regroupe la <strong>grande majoritÃ©</strong> des prototypes des <strong class="specialLB">fonctions d'analyse et de manipulation</strong> (dÃ©termination de la longueur, recherche de caractÃ¨res et de motifs, recopie, concatÃ©nation, etc.)Â ;    </li>

  <li> le fichier d'enâ€‘tÃªteÂ <code class="filename">stdlib.h</code> contient les prototypes des <strong class="specialLB">fonctions d'interprÃ©tation numÃ©rique</strong>  de valeurs codÃ©es dans une chaÃ®ne de caractÃ¨res selon les diffÃ©rents types standards du langage (<code class="prettyprint lang-c">int</code>, <code class="prettyprint lang-c">long</code>, <code class="prettyprint lang-c">double</code>, etc.). </li>
</ul>

<div class="expert">
<p> Par ailleurs, il existe d'<strong class="specialV">autres fonctions</strong> plus <strong class="specialV">spÃ©cialisÃ©es</strong> pour le traitementÂ : </p>
<ul>
  <li> des <strong>chaÃ®nes de caractÃ¨res</strong> ditesÂ Â«Â <strong class="specialLB">multibyte</strong>Â Â»Â <a class="external" href="https://en.cppreference.com/w/c/string/multibyte" target="_BLANK">C</a>, c'estâ€‘Ã â€‘dire dont les unitÃ©s d'encodage sont de typeÂ <code class="prettyprint lang-c">char</code> mais potentiellement multiples pour un caractÃ¨re donnÃ© â€“Â typiquement, au format <strong><em class="sigle">UTFâ€‘8</em></strong>Â ; ces fonctions sont dÃ©clarÃ©es dans le fichier d'enâ€‘tÃªteÂ <code class="filename">stdlib.h</code>Â ; elles comportent le motifÂ <code>mb</code> (pour <em>multibyte</em>) dans leur identificateurÂ ; </li>

  <li> des <strong>chaÃ®nes de caractÃ¨res</strong> ditesÂ Â«Â <strong class="specialLB">wide</strong>Â Â»Â <a class="external" href="https://en.cppreference.com/w/c/string/wide" target="_BLANK">C</a>, c'estâ€‘Ã â€‘dire dont les unitÃ©s d'encodage sont de typeÂ <code class="prettyprint lang-c">wchar_t</code>Â ; ces fonctions sont dÃ©clarÃ©es dans le fichier d'enâ€‘tÃªteÂ <code class="filename">wchar.h</code>.</li>
</ul>
</div><!-- expert -->
</div><!-- complement -->

<div class="expert">
<p> Dans le cadre de ce chapitre, une <strong>prÃ©sentation exhaustive</strong> de ces fonctions n'est <strong class="cons">pas envisageable</strong>. L'objectif est d'apporter un <strong class="title">mode d'emploi basique</strong> des <strong class="defin">fonctions les plus usuelles</strong>, chacune dans sa <strong class="pros">variante la plus simple</strong>. </p>

<p> Quant aux <strong class="specialV">fonctions spÃ©cialisÃ©es</strong> mentionnÃ©es ciâ€‘dessus, elles ne seront <strong class="cons">pas abordÃ©es</strong>. </p>

<p> SystÃ©matiquement, des <strong>liens</strong> vers des <strong class="title">pages de rÃ©fÃ©rence</strong> sont donnÃ©es pour accÃ©der Ã  <strong class="warning">plus de dÃ©tails</strong> si nÃ©cessaire. </p>  
</div><!-- expert -->

<div class="remarques">
<p class="remarque"> Chaque <strong>fonction</strong> possÃ¨de <strong class="title">plusieurs variantes</strong>, dont certaines sont dites <strong class="specialMg">sÃ©curisÃ©es</strong> â€“Â elles sont reconnaissables au <strong>suffixe</strong>Â <code class="cmd">_s</code> Ã  la fin de leur identificateur. </p>

<p> En rÃ¨gle gÃ©nÃ©rale, ces variantes sÃ©curisÃ©es imposent des <strong>restrictions de typage</strong> des arguments et produisent des <strong>codes d'erreurs</strong> pour faciliter le diagnostric des scÃ©narios de fonctionnement. Dans un premier temps, il n'est pas forcÃ©ment utile d'y recourir. </p>
</div><!-- remarque -->



<h3> Fonctions d'analyse </h3>



<h4> DÃ©termination de la longueur d'une chaÃ®neÂ deÂ caractÃ¨res </h4>


<p> Il n'existe qu'<strong>une seule fonction</strong> pour dÃ©terminer la <strong class="title">longueur d'une chaÃ®ne</strong> de caractÃ¨resÂ <a class="external" href="https://en.cppreference.com/w/c/string/byte/strlen" target="_BLANK">C</a>Â : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
// string length
size_t strlen(const char * str);
</pre>
<!---------- ne pas indenter ---------->  

<div class="important"> 
<p> La <strong class="specialLB">valeur retournÃ©e</strong> par la fonctionÂ <code class="prettyprint lang-c">strlen</code> est le <strong class="defin">nombre d'unitÃ©s d'encodage</strong> â€“Â c'estâ€‘Ã â€‘dire d'<strong>octets</strong>Â â€“ deÂ <code class="prettyprint lang-c">str</code>, sachant que le <strong>caractÃ¨re de fin de chaÃ®ne</strong>Â <strong  class="specialDR"><em class="sigle">NUL</em></strong> estÂ <strong class="warning">exclu</strong> du compte (cf.Â supraÂ <a class="supra" href="Cc5-6_chainesCaracteres.html#longueurChaine"></a>). </p>
</div><!-- important -->

<div class="exemples"><p class="exemples"> Dans l'environnement <strong class="OnlineGDB">OnlineGDB</strong>, on effectue les tests suivants. </p>

<ul>
  <li> AprÃ¨s la dÃ©claration <code class="prettyprint lang-c">char s[8] = "abc";</code> l'appelÂ <code class="prettyprint lang-c">strlen(s)</code> retourne la valeurÂ <code class="cmd">3</code>. </li>

  <div class="expert">
  <div class="nobullet"> En effet, ni le nombre d'Ã©lÃ©ments deÂ <code class="prettyprint lang-c">str</code>, ni le caractÃ¨re de fin de chaÃ®neÂ <strong class="specialDR"><em class="sigle">NUL</em></strong> ne sont pris en compte dans la valeur retournÃ©e. </div>
  </div><!-- expert -->

  <li> AprÃ¨s la dÃ©claration <code class="prettyprint lang-c">char s[8] = "a\0bc";</code> l'appelÂ <code class="prettyprint lang-c">strlen(s)</code> retourne la valeurÂ <code class="cmd">1</code>. </li>
  
  <div class="expert">
  <div class="nobullet"> En effet, seuls les caractÃ¨res codÃ©s <strong>avant</strong> le premier caractÃ¨re de fin de chaÃ®neÂ <strong><em class="sigle">NUL</em></strong> sont comptÃ©s or ici, on a codÃ© la <strong>sÃ©quence d'Ã©chappement octale</strong>Â <code class="prettyprint lang-c">'\0'</code> juste aprÃ¨s le premier caractÃ¨re. </div>
  </div><!-- expert -->

  <div class="expert">
  <li> AprÃ¨s la dÃ©claration <code class="prettyprint lang-c">char s[8] = "ğŸ˜‰";</code> l'appelÂ <code class="prettyprint lang-c">strlen(s)</code> retourne la valeurÂ <code class="cmd">4</code>. </li>

  
  <div class="nobullet"> En effet, l'Ã©moticÃ´neÂ ğŸ˜‰ â€“Â <em class="english">winking face</em>Â <a class="external" href="https://unicode-table.com/fr/1F609/" target="_BLANK"></a>Â â€“ se code surÂ <strong>4Â octets enÂ <em class="sigle">UTFâ€‘8</em></strong> (<code>OxF0 Ox9F Ox98 Ox89</code>). </div>
  </div><!-- expert -->
  </ul>

</div><!-- exemple -->



<h4> Recherche d'un caractÃ¨re ou d'unÂ motif dansÂ uneÂ chaÃ®ne </h4>


<ol class="numbered" style="margin-top:0em">
  <li id="strchr"> <strong class="title">PremiÃ¨re occurrence d'un caractÃ¨re</strong> dansÂ uneÂ chaÃ®neÂ deÂ caractÃ¨resÂ <a class="external" href="https://en.cppreference.com/w/c/string/byte/strchr" target="_BLANK">C</a> </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
// string character
char * strchr(const char * str, int ch);
</pre>
<!---------- ne pas indenter ---------->  
  
  <div class="complementExpert">
  <p> <em class="remark">Attention</em>. L'<strong class="specialT">argument formel</strong>Â <code class="prettyprint lang-c">ch</code>, bien que dÃ©clarÃ© de <strong>type</strong>Â <code class="prettyprint lang-c">int</code> dans l'enâ€‘tÃªte de la fonction, est <strong class="warning">converti</strong> dans le <strong>type</strong>Â <code class="prettyprint lang-c">char</code> dans le corps de dÃ©finition de la fonction. </p>

  <p> C'est pourquoi, dans l'appel de la fonctionÂ <code class="prettyprint lang-c">strchr</code>, son <strong class="specialO">argument effectif</strong> correspondant ne doit donc prendre qu'une <strong>valeur d'encodage</strong> comprise entreÂ <code>0x00</code> etÂ <code>0xFF</code>. Ce faisant, il peut Ã©ventuellement Ãªtre codÃ© comme une <strong>valeur de caractÃ¨re</strong> entre guillemets simplesÂ <code class="prettyprint lang-c">''</code> ou une <strong>sÃ©quence d'Ã©chappement</strong>. </p> 

  </div><!-- complementExpert -->

  <div class="important">
  <p> La <strong class="specialLB">valeur retournÃ©e</strong> par la fonctionÂ <code class="prettyprint lang-c">strchr</code> estÂ : </p>
  <ul>
    <li> l'<strong class="defin">adresse de la premiÃ¨re occurrence</strong> deÂ <code class="prettyprint lang-c">ch</code> dansÂ <code class="prettyprint lang-c">str</code>Â ;  </li>
  
    <li> sinon, en cas d'absence deÂ <code class="prettyprint lang-c">ch</code> dansÂ <code class="prettyprint lang-c">str</code>, le <strong class="defin">pointeur nul</strong> (Ã  <strong class="warning">ne pas confondre</strong> avec le <em>caractÃ¨re</em>Â <em class="sigle">NUL</em> â€“Â cf.Â supraÂ <a class="supra" href="Cc5-6_chainesCaracteres.html#remCarNul"></a>). </li>
  </ul>
  </div><!-- important -->
  
  <div class="expert">
  <div class="exemples">
  <p class="exemple"> Dans le programme ciâ€‘dessous, la <strong>fonction</strong>Â <code class="prettyprint lang-c">htmlWordCount</code> effectue un <strong class="title">comptage des mots</strong> de texte d'une <strong>page web</strong> (partielle) codÃ©e enÂ <strong><em class="sigle">HTML/CSS</em></strong>, ici intÃ©grÃ©e sous la forme d'une <strong class="title">chaÃ®ne de caractÃ¨res brute</strong> (cf.Â chap.Â R2-IVÂ <a class="previous" href="../../ModuleR/R2-Applications/Rc2-4_webServeur.html#ArduinoChangeBackground" target="_BLANK">R</a>). </p>

  <p> Or dans ce langage, les mots de texte sont codÃ©s <strong class="defin">hors des balises</strong>. C'est pourquoi il faut repÃ©rerÂ : </p>
  <ul>
    <li> les <strong>fins de balise</strong>Â <code class="prettyprint lang-c">'&gt;'</code> pour effectuer le comptageÂ ; </li>

    <li> les <strong>dÃ©buts de balise</strong>Â <code class="prettyprint lang-c">'&lth;'</code> suspendre le comptage. </li>
  </ul>
  <p> Dans les deux cas, on appelle la <strong class="title">fonction</strong>Â <code class="prettyprint lang-c">strchr</code> (cf.Â les ligneÂ nÂ°Â 10Â &Â 19). </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;

size_t htmlWordCount(const char * str) {
  size_t count  = 0;
  int    isWord = 0;  // bool value
  do {  
    // end of HTML tag means (re)start of text
    str = strchr(str, '>');   
    if (str == NULL) break;
    do {
      // symbols in the text are not considered as words
      if (isalnum(*str)) {  
        if (!isWord) isWord = 1, count++;
      }
      else isWord = 0;
      str++;
    }
    while (*str != '<' && *str != 0); 
    // begining of HTML tag means end of text
  }
  while (*str != 0);  
  return count;
}

const char pageTail[] = R"=====(
&lt;h1&gt; Dynamic page example embedded on Arduino board &lt;/h1&gt;
&lt;p&gt;&lt;a href='./?bgcolor=white'&gt;White&lt;/a&gt;
   Â Â &lt;!-- 2 nonâ€‘break spaces here as inter-margin --&gt;
   &lt;a href='./?bgcolor=yellow'&gt;Yellow&lt;/a&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
)=====";

int main(void) {
  printf("%zu words\n", htmlWordCount(pageTail));
  return 0;
}
</pre>
<!---------- ne pas indenter ----------> 

<p> Ce programme produit en sortie standard l'affichageÂ : </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
9 words
</pre>
<!---------- ne pas indenter ----------> 

<p> puisque le codeÂ <strong><em class="sigle">HTML</em></strong> de la chaÃ®ne de caractÃ¨res traitÃ©e ne compte que lesÂ <strong>9Â mots</strong> ciâ€‘dessousÂ : </p>

<!---------- ne pas indenter ---------->
<pre class="displayWhite">
Dynamic page example embedded on Arduino board
White  Yellow 
</pre>
<!---------- ne pas indenter ----------> 

  </div><!-- exemple -->
  </div><!-- expert -->
  

  <li style="margin-top:1.5em"> <strong class="title">DerniÃ¨re occurrence d'un caractÃ¨re</strong> dansÂ uneÂ chaÃ®neÂ deÂ caractÃ¨resÂ <a class="external" href="https://en.cppreference.com/w/c/string/byte/strrchr" target="_BLANK">C</a> </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
// string reverse character
char * strrchr(const char * str, int ch);
</pre>
<!---------- ne pas indenter ---------->  

  <div class="important">
  <p> Cette fonction <strong class="specialLB">opÃ¨re comme</strong> <code class="prettyprint lang-c">strchr</code> (cf.Â supraÂ <a class="supra" href="Cc5-6_chainesCaracteres.html#strchr"></a>) mais dans l'<strong class="defin">ordre inverse</strong> des caractÃ¨res de la chaÃ®neÂ <code class="prettyprint lang-c">str</code> â€“Â donc en partant de la <strong>fin</strong>. </p>
  </div><!-- important -->

  <div class="complement">
  <p> Une telle fonction est particuliÃ¨rement utile pour des chaÃ®nes de caractÃ¨res oÃ¹ les <strong>donnÃ©es les plus rÃ©centes</strong> sont concatÃ©nÃ©es Ã  la fin relevÃ©s de mesure, etc.). </p>
</div><!-- complement -->
  <li style="margin-top:1.5em"> <strong class="title">PremiÃ¨re occurrence d'un motif</strong> dans une chaÃ®neÂ deÂ caractÃ¨resÂ <a class="external" href="https://en.cppreference.com/w/c/string/byte/strstr" target="_BLANK">C</a> </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
// string (sub)string
char * strstr(const char * str, const char * substr);
</pre>
<!---------- ne pas indenter ---------->

  <div class="important">
  <p> Cette fonction <strong class="specialLB">opÃ¨re comme</strong> <code class="prettyprint lang-c">strchr</code> (cf.Â supraÂ <a class="supra" href="Cc5-6_chainesCaracteres.html#strchr"></a>) mais en recherchant dansÂ <code class="prettyprint lang-c">str</code> la premiÃ¨re occurrence de la sousâ€‘chaÃ®neÂ <code class="prettyprint lang-c">substr</code>. Si cette derniÃ¨re est la <strong class="specialO">chaÃ®ne vide</strong>Â <code class="prettyprint lang-c">""</code>, la <strong>valeur retournÃ©e</strong> est celle du pointeurÂ <code class="prettyprint lang-c">str</code>. </p>
  </div><!-- important -->
  
  <div class="expert">
  <div class="complement">
  <p> La fonction <code class="prettyprint lang-c">strstr</code> permet notamment de <strong class="title">rechercher</strong> dans une chaÃ®ne de caractÃ¨res encodÃ©e enÂ <strong><em class="sigle">UTFâ€‘8</em></strong> n'importe quelÂ <strong class="title">caractÃ¨re</strong> <strong class="defin">hors du jeuÂ <em class="sigle">ASCII</em> restreint</strong> (donc encodÃ© sur plusieurs octets). </p>
  </div><!-- complement -->
  
  <div class="exemples">
  <p class="exemple">  Dans le programme acadÃ©mique ciâ€‘dessous, on recherche dans la chaÃ®neÂ <code class="prettyprint lang-c">mess</code> la premiÃ¨re occurrence du caractÃ¨reÂ Â«Â <em class="bold">Ã´</em>Â Â» (cf.Â la ligneÂ nÂ°Â 6). </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(void) {
  char * mess = "Ã€ bientÃ´t !";
  printf("%s", strstr(mess, "Ã´"));
  return 0;
}
</pre>
<!---------- ne pas indenter ----------> 
  
  <p> Comme prÃ©vu, on obtient en sortie standard l'affichageÂ : </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Ã´t !
</pre>
<!---------- ne pas indenter ----------> 

  </div><!-- exemple -->
  </div><!-- expert -->
</ol><!-- numbered -->

<!-- 
<div class="expert">  
<h4> Parsing littÃ©ral d'une chaÃ®ne </h4>

<p>  strspn (string span) strcspn (string complementary span) strpbrk (string point break) strtok (string token)</p>
</div>&lt;!-- expert -->



<h3 id="interpretationNumerique"> Fonctions d'interprÃ©tation numÃ©rique </h3>



<div class="important">
<p> Ces fonctions permettent d'<strong class="title">interprÃ©ter</strong> â€“Â en quelque sorte, Â«Â convertirÂ Â»Â â€“  dans un <strong class="specialG">type numÃ©rique standard</strong> (<code class="prettyprint lang-c">int</code>, <code class="prettyprint lang-c">long</code>, <code class="prettyprint lang-c">double</code>, etc.) une <strong class="defin">valeur</strong> codÃ©e dans une <strong>chaÃ®ne de caractÃ¨res</strong> avec la <strong class="specialO">syntaxe des constantes littÃ©rales</strong> (cf.Â chap.Â C3â€‘IIÂ <a class="previous" href="../C3-Numeration/Cc3-2_typesEntiers.html#constantesLitterales" target="_BLANK"></a> etÂ C3â€‘VÂ <a class="previous" href="../C3-Numeration/Cc3-5_typesFlottants.html#codageConstanteDecimale" target="_BLANK"></a>). </p>  

<p> Ces fonctions sont dÃ©clarÃ©es dans le <strong class="specialLB">fichier d'enâ€‘tÃªte</strong> <code class="filename">stdlib.h</code> de la bibliothÃ¨que standard du langageÂ <strong>C</strong> (<code class="filenamen">cstdlib</code> pour leÂ <strong>C++</strong>). </p>
</div><!-- important -->


<h4> InterprÃ©tation par une valeurÂ entiÃ¨re </h4>


<ol class="numbered" style="margin-top:0em">
  <li id="strchr"> <strong class="title">InterprÃ©tation en baseÂ 10</strong> dans le <strong>type</strong>Â <code class="prettyprint lang-c">int</code>Â <a class="external" href="https://en.cppreference.com/w/c/string/byte/atoi" target="_BLANK">C</a> </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
// ascii to int 
int atoi(const char * str);
</pre>
<!---------- ne pas indenter ---------->  
  
  <div class="complement">
  <p> La chaÃ®neÂ <code class="prettyprint lang-c">str</code> est supposÃ©e contenir une <strong class="defin">suite de chiffres</strong>, Ã©ventuellement prÃ©cÃ©dÃ©e de <strong>caractÃ¨res d'espacement</strong>, de <strong>zÃ©ros non significatifs</strong> et d'un <strong class="defin">signe</strong> Â«Â <code>-</code>Â Â» ou Â«Â <code>+</code>Â Â». </p>
  </div><!-- complement -->

  <div class="important">
  <p> La <strong class="specialLB">valeur retournÃ©e</strong> par la fonctionÂ <code class="prettyprint lang-c">atoi</code> est la <strong class="defin">valeur numÃ©rique entiÃ¨re</strong> <strong>positive</strong> ou <strong>nÃ©gative</strong> interprÃ©tant la chaÃ®ne de chiffres en <strong>baseÂ 10</strong>. ToutefoisÂ : </p>
  <ul>
    <li> en cas de <strong class="warning">dÃ©bordement</strong> de l'intervalle d'encodage du <strong>type</strong>Â <code class="prettyprint lang-c">int</code>, la valeur retournÃ©e <strong>dÃ©pend de l'implÃ©mentation</strong>Â ; </li>

    <li> en cas d'<strong class="cons">Ã©chec d'interprÃ©tation</strong> â€“Â en particulier si, aprÃ¨s les Ã©ventuelles caractÃ¨res d'espacement et le signe, le <strong>premier caractÃ¨re</strong> rencontrÃ© n'est <strong class="cons">pas un chiffre</strong>Â â€“ la <strong>valeur retournÃ©e</strong> estÂ <code class="cmd">0</code>. </li>
  </ul>
  </div><!-- important -->
  
  <div class="exemples"><p class="exemples"> Dans l'environnement <strong class="OnlineGDB">OnlineGDB</strong>, on teste les appels suivants. </p>
  <ul>
    <li> <code class="prettyprint lang-c">atoi("  \t \n -0123.45foo")</code> retourne la valeur <code class="cmd">-123</code>. </li>

    <div class="expert">
    <div class="nobullet"> C'est le <strong class="pros">comportement normal</strong> avec, aprÃ¨s le signeÂ <code class="prettyprint lang-c">'-'</code> unÂ <code class="prettyprint lang-c">'0'</code> non significatif ignorÃ©. AprÃ¨s le premier chiffre trouvÃ©, tout caractÃ¨re qui n'est pas un chiffre (ici, <code class="prettyprint lang-c">'.'</code>) marque la fin de la chaÃ®ne numÃ©rique. </div>
    </div><!-- expert -->  

    <li> <code class="prettyprint lang-c">atoi("foo123")</code> retourne la valeurÂ <code class="cmd">0</code>. </li>

    <div class="expert">
    <div class="nobullet"> On a un <strong class="cons">Ã©chec d'interprÃ©tation</strong> puisque le premier caractÃ¨re de la chaÃ®ne n'est ni un chiffre, ni un signeÂ <code>+</code> ouÂ <code>-</code>, ni un caractÃ¨re d'espacement. </div>
    </div><!-- expert --> 
  
    <li> <code class="prettyprint lang-c">atoi("12345678900")</code> retourne la valeurÂ <code class="cmd">-539222988</code>. </li>

    <div class="expert">
    <div class="nobullet"> On a un <strong class="warning">dÃ©bordement</strong> traitÃ© par <strong>rebouclage cyclique</strong> puisque la chaÃ®ne numÃ©rique <code class="prettyprint lang-c">"12345678900"</code> reprÃ©sente une valeur supÃ©rieure Ã Â <code class="cmd">INT_MAX</code> mais nÃ©anmoins infÃ©rieure Ã  <code class="cmd">LLONG_MAX</code> (cf.Â chap.Â C3â€‘IIÂ <a class="previous" href="../C3-Numeration/Cc3-2_typesEntiers.html#limits" target="_BLANK"></a>). </div>
    </div><!-- expert --> 

    <li> <code class="prettyprint lang-c">atoi("123456789012345678900")</code> retourne la valeur <code class="cmd">-1</code>. </li>

    <div class="expert">
    <div class="nobullet"> On a un <strong class="warning">dÃ©bordement</strong> signalÃ© par un <strong>code d'erreur</strong> conventionnel car la chaÃ®ne numÃ©rique <code class="prettyprint lang-c">"123456789012345678900"</code> reprÃ©sente une valeur supÃ©rieure Ã Â <code class="cmd">LLONG_MAX</code>.  </div>
    </div><!-- expert --> 
  </ul>
  </div><!-- exemples -->
 

  <li style="margin-top:1.5em" id="strchr"> <strong class="title">InterprÃ©tation en baseÂ 10</strong> dans les <strong>types</strong>Â <code class="prettyprint lang-c">long</code> etÂ <code class="prettyprint lang-c">long long</code>Â <a class="external" href="https://en.cppreference.com/w/c/string/byte/atoi" target="_BLANK">C</a> </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
// ascii to long / long long 
long       atol(const char * str);
long long atoll(const char * str); 
</pre>
<!---------- ne pas indenter ---------->  
  
  <div class="important">
  <p> Ces fonctions <strong class="specialLB">opÃ¨rent comme</strong> <code class="prettyprint lang-c">atoi</code> mais avec un <strong class="specialG">type</strong> d'interprÃ©tation de la valeur numÃ©rique <strong class="pros">plus large</strong>. </p>
  </div><!-- important -->

  <li style="margin-top:1.5em" id="strchr"> <strong class="title">InterprÃ©tation enchaÃ®nable en baseÂ n</strong> dans le <strong>type</strong>Â <code class="prettyprint lang-c">long</code> </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
// string to long 
long strtol(const char * str, char ** str_end, int base);
</pre>
<!---------- ne pas indenter ---------->  

  <div class="complement">
  <p> Cette fonction <strong class="specialLB">opÃ¨re comme</strong> <code class="prettyprint lang-c">atol</code> mais possÃ¨de <strong class="specialT">deux arguments supplÃ©mentaires</strong>. </p>
  <ul>
    <li> L'<strong class="specialT">argument</strong> <code class="prettyprint lang-c">str_end</code> est un <strong class="defin">pointeur de caractÃ¨re</strong> transmis par adresse pour pouvoir Ãªtre <strong>modifiÃ© par la fonction</strong> (c'est donc un pointeur de pointeur). </li>

    <div class="nobullet"> Il donne le <strong class="defin">caractÃ¨re immÃ©diatement consÃ©cutif</strong> Ã  la chaÃ®ne numÃ©rique interprÃ©tÃ©e pour permettre un enchaÃ®nement d'interprÃ©tation (si la chaÃ®neÂ <code class="prettyprint lang-c">str</code> comporte plusieurs valeurs successives). </div>

    <li> L'<strong class="specialT">argument</strong> <code class="prettyprint lang-c">base</code> permet de coder n'importe quelle <strong class="defin">base</strong> <strong>n</strong>Â =Â <em class="bold">2</em> Ã Â <strong>n</strong>Â =Â <em class="bold">36</em> dans laquelle interprÃ©ter la chaÃ®ne numÃ©rique identifiÃ©e.  </li>

    <div class="nobullet"> Dans un appel deÂ <code class="prettyprint lang-c">strtol</code>, on peut Ã©galement coder pour l'argument <code class="prettyprint lang-c">base</code> la valeurÂ <code class="prettyprint lang-c">0</code>. La fonction opÃ¨re alors par <strong class="defin">autoâ€‘dÃ©tection</strong> en recherchant un <strong class="defin">prÃ©fixe</strong> Ã  la chaÃ®ne numÃ©rique â€“Â <code class="prettyprint lang-c">0</code> pour la <strong>baseÂ 8</strong> et <code class="prettyprint lang-c">0x</code> ouÂ <code class="prettyprint lang-c">0X</code> pour la <strong>baseÂ 16</strong> (il n'y a pas de prÃ©fixe pour la <em>baseÂ 2</em>). </div>
  </ul>
  </div><!-- complement -->

  <div class="exemples" id="ex-strtol">
  <p class="exemple"> Le <strong class="title">programme acadÃ©mique</strong> ciâ€‘dessous montre comment enregistrer dans un <strong class="defin">tableau d'entiers</strong> une <strong>sÃ©rie de valeurs numÃ©riques</strong> codÃ©es en <strong>baseÂ 16</strong> avec le prÃ©fixeÂ <code class="prettyprint lang-c">"0x"</code> dans une chaÃ®ne de caractÃ¨res. </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void) {
  char * val = "0xAA 0xAB 0xAC 0xAD 0xAE";
  long tab[5] = {0};
  for (char * p = val, * e = NULL, i = 0; i < 5 ; p = e, i++) {
    tab[i] = strtol(p, &e, 0);
    printf("0x%lX ", tab[i]);
  }
  printf("\n");
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->  
  </div><!-- exemple -->
  
  <div class="remarques">
  <p class="remarque"> Il existe aussi la <strong class="title">fonction</strong> <code class="prettyprint lang-c">strtoll</code> qui est une <strong class="defin">variante similaire</strong> Ã  Â <code class="prettyprint lang-c">strtol</code> mais retournant une valeur dans le type <code class="prettyprint lang-c">long long</code>. </p>
  </div><!-- exemple -->

</ol><!-- numbered -->

  
<h4> InterprÃ©tation par une valeur dÃ©cimaleÂ flottante </h4>


<ol class="numbered" style="margin-top: 0em">
  <li id="strchr"> <strong class="title">InterprÃ©tation</strong> dans le <strong>type</strong>Â <code class="prettyprint lang-c">double</code>Â <a class="external" href="https://en.cppreference.com/w/c/string/byte/atof" target="_BLANK">C</a> </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
// ascii to floating-point decimal 
double atof(const char * str);
</pre>
<!---------- ne pas indenter ---------->  
  
  <div class="complement">
  <p> La chaÃ®neÂ <code class="prettyprint lang-c">str</code> est supposÃ©e contenir une <strong class="defin">suite de chiffres</strong> et de <strong class="defin">symboles numÃ©riques</strong> conforme Ã  la syntaxe de codage des constantes littÃ©rales dÃ©cimales (cf.Â C3â€‘VÂ <a class="previous" href="../C3-Numeration/Cc3-5_typesFlottants.html#codageConstanteDecimale" target="_BLANK"></a>), Ã©ventuellement prÃ©cÃ©dÃ©e de <strong>caractÃ¨res d'espacement</strong> et de <strong>zÃ©ros non significatifs</strong>. </p>
  </div><!-- complement -->

  <div class="important">
  <p> La <strong class="specialLB">valeur retournÃ©e</strong> par la fonctionÂ <code class="prettyprint lang-c">atof</code> est la <strong class="defin">valeur numÃ©rique dÃ©cimale</strong> interprÃ©tant la sÃ©quence de chiffres et de symboles. ToutefoisÂ : </p>
  <ul>
    <li> en cas de <strong class="warning">dÃ©bordement</strong> par le <strong>haut</strong> (<strong>overflow</strong>) ou par le <strong>bas</strong> (<strong>underflow</strong>) des intervalles encodables dans le <strong>type</strong>Â <code class="prettyprint lang-c">double</code>, la valeur retournÃ©e est un <strong class="defin">Ã©lÃ©ment absorbant</strong>, respectivementÂ <code class="cmd">inf</code> ouÂ <code class="cmd">0.0</code> (cf.Â C3â€‘VÂ <a class="previous" href="../C3-Numeration/Cc3-5_typesFlottants.html#debordements" target="_BLANK"></a>)Â ; </li>

    <li> en cas d'<strong class="cons">Ã©chec d'interprÃ©tation</strong> â€“Â en particulier si, aprÃ¨s les Ã©ventuelles caractÃ¨res d'espacement, le <strong>premier caractÃ¨re</strong> rencontrÃ© n'est <strong class="cons">pas un chiffre</strong>Â â€“ la <strong>valeur retournÃ©e</strong> estÂ <code class="cmd">0.0</code>. </li>
  </ul>
  </div><!-- important -->
  
  <div class="expert">
  <div class="exemples"><p class="exemples"> Dans l'environnement <strong class="OnlineGDB">OnlineGDB</strong>, on teste les appels suivants. </p>
  <ul>
    <li> <code class="prettyprint lang-c">atof("  \t \n -0123.45e+02foo")</code> retourne la valeurÂ <code class="cmd">-12345.0</code>. </li>

    <div class="expert">
    <div class="nobullet"> C'est le <strong class="pros">comportement normal</strong> avec, aprÃ¨s le signeÂ <code class="prettyprint lang-c">'-'</code> unÂ <code class="prettyprint lang-c">'0'</code> non significatif ignorÃ©. Ici, c'est la lettreÂ <code class="prettyprint lang-c">'f'</code> qui marque la fin de la chaÃ®ne dÃ©cimale Ã  interprÃ©ter. </div>
    </div><!-- expert -->  

    <div class="expert">
    <li> <code class="prettyprint lang-c">atof("0xA.1p3")</code> retourne la valeur <code class="cmd">80.5</code>. </li>

    <div class="nobullet"> C'est le <strong class="pros">comportement normal</strong> avec une constante littÃ©rale codÃ©e en <strong>notation hexadÃ©cimale</strong> (cf.Â C3â€‘VÂ <a class="previous" href="../C3-Numeration/Cc3-5_typesFlottants.html#constanteDecimaleHexa" target="_BLANK"></a>). </div>
    </div><!-- expert -->  

    <li> <code class="prettyprint lang-c">atof("foo12.3")</code> retourne la valeurÂ <code class="cmd">0.0</code>. </li>
    
    <div class="expert">
    <div class="nobullet"> On a un <strong class="cons">Ã©chec d'interprÃ©tation</strong> puisque le premier caractÃ¨re de la chaÃ®ne n'est ni un chiffre, ni un point dÃ©cimal, ni un signeÂ <code>+</code> ouÂ <code>-</code>, ni un caractÃ¨re d'espacement. </div>
    </div><!-- expert --> 
  
    <li> <code class="prettyprint lang-c">atof("1e400")</code> retourne la valeurÂ <code class="cmd">inf</code>. </li>
    
    <div class="expert"> 
    <div class="nobullet"> On a un <strong class="warning">overflow</strong> traitÃ© par l'<strong>Ã©lÃ©ment absorbant</strong>Â <code class="prettyprint lang-c">inf</code> (<em class="english">infinity</em>) car la chaÃ®neÂ <code class="prettyprint lang-c">"1e400"</code> reprÃ©sente une valeur <strong>supÃ©rieure</strong> Ã Â <code class="prettyprint lang-c">DBL_MAX</code> (cf.Â C3â€‘VÂ <a class="previous" href="../C3-Numeration/Cc3-5_typesFlottants.html#caracteristiques" target="_BLANK"></a>). </div>
    </div><!-- expert -->


    <li> <code class="prettyprint lang-c">atof("1e-400")</code> retourne la valeurÂ <code class="cmd">0.0</code>. </li>
    
    <div class="expert"> 
    <div class="nobullet"> On a un <strong class="cons">underflow</strong> traitÃ© par l'<strong>Ã©lÃ©ment absorbant</strong>Â <code class="prettyprint lang-c">0.0</code> car la chaÃ®neÂ <code class="prettyprint lang-c">"1e-400"</code> reprÃ©sente une valeur <strong>infÃ©rieure</strong> Ã Â <code class="prettyprint lang-c">DBL_TRUE_MIN</code> (cf.Â C3â€‘VÂ <a class="previous" href="../C3-Numeration/Cc3-5_typesFlottants.html#constanteDecimaleHexa" target="_BLANK"></a>). </div>
    </div><!-- expert -->
  </ul>
  
  </div><!-- exemples -->
  </div><!-- expert -->

  <li style="margin-top:1.5em" id="strchr"> <strong class="title">InterprÃ©tation enchaÃ®nable</strong> dans le <strong>type</strong>Â <code class="prettyprint lang-c">double</code>Â <a class="external" href="https://en.cppreference.com/w/c/string/byte/strtod" target="_BLANK">C</a> </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
// string to double
double strtod(const char * str, char ** str_end);
</pre>
<!---------- ne pas indenter ---------->  

  <div class="complement"> 
  <p> Cette fonction <strong class="specialLB">opÃ¨re comme</strong> <code class="prettyprint lang-c">atof</code> mais, Ã  l'instar deÂ <code class="prettyprint lang-c">strtol</code>, elle possÃ¨de aussi un <strong class="specialT">argument</strong> <code class="prettyprint lang-c">str_end</code> qui est un <strong class="defin">pointeur de caractÃ¨re</strong> transmis par adresse pour pouvoir Ãªtre <strong>modifiÃ© par la fonction</strong> (c'est donc un pointeur de pointeur). Ce dernier donne le <strong class="defin">caractÃ¨re immÃ©diatement consÃ©cutif</strong> Ã  la chaÃ®ne numÃ©rique interprÃ©tÃ©e pour permettre un enchaÃ®nement d'interprÃ©tation (si la chaÃ®neÂ <code class="prettyprint lang-c">str</code> comporte plusieurs valeurs successives). </p>
  </div><!-- complement -->

  <div class="exemples">
  <p class="exemple"> Le <strong class="title">programme acadÃ©mique</strong> ciâ€‘dessous montre comment enregistrer dans un <strong class="defin">tableau de dÃ©cimaux</strong> une <strong>sÃ©rie de valeurs numÃ©riques</strong> codÃ©es dans une chaÃ®ne de caractÃ¨res au formatÂ <strong><em class="sigle">csv</em></strong> (<em class="english">commaâ€‘separated values</em>Â <a class="external" href="https://fr.wikipedia.org/wiki/Comma-separated_values" target="_BLANK">W</a>). </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(void) {
  char * val = " 0.1 ,  0.2 , 0.3 , 0.4 , 0.5 ";
  double tab[5] = {0};
  for (char * p = val, * e = NULL, i = 0; i < 5; p = e, i++) {
    tab[i] = strtod(p, &e);
    printf("%g ", tab[i]);
    e = strchr(e, ',') + 1;
  }
  printf("\n");
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->  
  </div><!-- exemple -->
  
  <p> Parce que la spÃ©cification est semblable que celle de l'exemple supraÂ <a class="supra" href="http://www.lycee-ferry-versailles.fr/snir/ModuleC/C5-StructuresPointeurs/ex-strtol" target="_BLANK"></a> proposÃ© pour illustrer la fonctionÂ <code class="prettyprint lang-c">strtol</code>, ce programme en reprend le <strong class="pros">mÃªme algorithme</strong>. Le seul aspect supplÃ©mentaire est la ligneÂ nÂ°Â 9 qui code le <strong>traitement des virgules sÃ©paratrices</strong> des valeurs dans la chaÃ®neÂ : elle cherche le caractÃ¨reÂ <code class="prettyprint lang-c">','</code> et passe au caractÃ¨re suivant. </p>

  <div class="remarques">
  <p class="remarque"> Il existe aussi les <strong class="title">fonctions</strong> <code class="prettyprint lang-c">strtof</code> et <code class="prettyprint lang-c">strtold</code> qui sont des <strong class="defin">variantes similaires</strong> Ã Â <code class="prettyprint lang-c">strtod</code> mais retournant une valeur respectivement dans les <strong>types</strong>Â <code class="prettyprint lang-c">float</code> etÂ <code class="prettyprint lang-c">long double</code>. </p>
  </div><!-- remarque -->

</ol><!-- numbered -->



<h3 id="fonctionComparaison"> Fonctions de comparaison </h3>



<div class="important">
<p> Toute fonction de <strong class="title">comparaison entre deux chaÃ®nes de caractÃ¨res</strong> est basÃ©e sur un <strong class="defin">ordre lexicographique</strong>Â <a class="external" href="https://fr.wikipedia.org/wiki/Ordre_lexicographique" target="_BLANK">W</a> dÃ©fini â€“Â Ã  l'instar de celui pour classer les mots dans un dictionnaire. <strong class="specialLB">Par dÃ©faut</strong>, cet ordre est basÃ© sur la <strong>valeur ordinale des codes des caractÃ¨res</strong>, aussi bien en formatÂ <strong><em class="sigle">ASCII</em></strong> qu'enÂ <strong><em class="sigle">UTFâ€‘8</em></strong>. </p>

<div class="expert">
<p> Sous un systÃ¨meÂ <em class="mark">Linux</em>, l'<strong class="defin">ordre lexicographique</strong> dÃ©pend de la valeur de <strong>variable d'environnement</strong>Â <code class="cmd">LC_COLLATE</code> <em class="remark">durant l'exÃ©cution du programme</em>. Par dÃ©faut, c'est celui de la <strong>locale</strong>Â <code class="cmd">C</code> qui est sÃ©lectionnÃ©. </p>
</div><!-- expert -->

<p> La comparaison est opÃ©rÃ©e respectivement entre les deux chaÃ®nes <strong class="defin">octet par octet</strong> <strong>dans l'ordre de leur position dans les chaÃ®nes</strong> â€“Â de faÃ§on semblable au sens de lecture des mots.  </p>
</div><!-- important -->

<ol class="numbered">
  <li style="margin-top:1.5em" id="strchr"> <strong class="title">Comparaison complÃ¨te</strong> de deux chaÃ®nes dans l'<strong class="defin">ordre lexicographique</strong>Â <a class="external" href="https://en.cppreference.com/w/c/string/byte/strcmp" target="_BLANK">C</a> </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
// string compare 
int strcmp(const char * lhs, const char * rhs);
</pre>
<!---------- ne pas indenter ---------->  
  
  <div class="complement">
  <p> Dans l'enâ€‘tÃªte de cette fonction, les <strong class="specialT">arguments formels</strong> sont dÃ©signÃ©sÂ : </p>
  <ul>
    <li> <code class="prettyprint lang-c">lhs</code> pour <strong>leftâ€‘hand string</strong>Â ; </li>
  
    <li> <code class="prettyprint lang-c">rhs</code> pour <strong>rightâ€‘hand string</strong>. </li>
  </ul>
  </div><!-- complement -->

  <div class="important">
  <p> La <strong class="specialLB">valeur retournÃ©e</strong> par la fonctionÂ <code class="prettyprint lang-c">strcmp</code> est un <strong class="defin">entier</strong>Â : </p>
  <ul>
    <li> <strong>positif</strong> â€“Â typiquementÂ <code class="cmd">1</code>Â â€“ si <code class="prettyprint lang-c">lhs <span class="nocode"><strong class="defin">></strong></span> rhs</code>, autrement dit siÂ <code class="prettyprint lang-c">lhs</code> <strong class="defin">succÃ¨de</strong> Ã Â <code class="prettyprint lang-c">rhs</code> dans l'ordre lexicographique.  </li>

    <li> <strong>nul</strong> â€“Â <code class="cmd">0</code>Â â€“ si <code class="prettyprint lang-c">lhs <span class="nocode"><strong class="defin">=</strong></span> rhs</code>Â ;  </li>

    <li> <strong>nÃ©gatif</strong> â€“Â typiquementÂ <code class="cmd">-1</code>Â â€“ si <code class="prettyprint lang-c">lhs <span class="nocode"><strong class="defin"><</strong></span> rhs</code>.  </li>
  </ul>
  </div><!-- important -->
  
  <div class="exemples"><p class="exemples"> Dans l'environnement <strong class="OnlineGDB">OnlineGDB</strong>, on teste les appels deÂ <code class="prettyprint lang-c">strcmp</code> suivants. </p>
  <ul>
    <li> <code class="prettyprint lang-c">strcmp("abd", "abce")</code> retourne la valeurÂ <code class="cmd">1</code>. </li>

    <div class="expert">
    <div class="nobullet"> En effet, mÃªme si elle est plus courte,Â <code class="prettyprint lang-c">"abd"</code> <strong class="defin">succÃ¨de</strong> Ã Â <code class="prettyprint lang-c">"abce"</code> dans l'ordre lexicographique. </div>
    </div><!-- expert -->

    <li> <code class="prettyprint lang-c">strcmp("&abc", "#abc")</code> retourne la valeurÂ <code class="cmd">1</code>. </li>

    <div class="expert">
    <div class="nobullet"> 
    En effet, le caractÃ¨reÂ <code class="prettyprint lang-c">'&'</code> (<code>0x26</code>) <strong class="defin">succÃ¨de</strong> Ã Â <code class="prettyprint lang-c">'#'</code> (<code>0x23</code>) en termes de <strong>codesÂ <em class="sigle">ASCII</em></strong> ouÂ <strong><em class="sigle">UTFâ€‘8</em></strong>. </div>
    </div><!-- expert -->

    <div class="expert">
    <li> <code class="prettyprint lang-c">strcmp("Ã¨", "Ã©")</code> retourne la valeurÂ <code class="cmd">-1</code>. </li>

    <div class="nobullet"> En effet, le caractÃ¨reÂ <code class="prettyprint lang-c">'Ã¨'</code> (codeÂ <code>0xC3A8</code>) <strong class="defin">prÃ©cÃ¨de</strong> Ã Â <code class="prettyprint lang-c">'Ã©'</code> (codeÂ <code>0xC3A9</code>) en termes de <strong>codesÂ <em class="sigle">UTFâ€‘8</em></strong>.  </div>

    <li> <code class="prettyprint lang-c">strcmp("e", "Ã©")</code> retourne la valeurÂ <code class="cmd">-1</code>Â . </li>

    <div class="nobullet"> En effet, le caractÃ¨reÂ <code class="prettyprint lang-c">'e'</code> (<code>0x65</code>) <strong class="defin">prÃ©cÃ¨de</strong> Ã Â <code class="prettyprint lang-c">'Ã©'</code> (<code>0xC3A9</code>) car pour le premier octet, on a bien <code>0x65</code>Â <strong class="defin"><</strong>Â <code>0xC3</code>.  </div>
    </div><!-- expert -->
  </ul>
  
  </div><!-- exemples -->
  

  <li style="margin-top:1.5em" id="strchr"> <strong class="title">Comparaison desÂ nÂ premiers octets</strong> de deux chaÃ®nes de caractÃ¨res dans l'<strong class="defin">ordre lexicographique</strong>Â <a class="external" href="https://en.cppreference.com/w/c/string/byte/strcmp" target="_BLANK">C</a> </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
// string nâ€‘bytes compare 
int strncmp(const char * lhs, const char * rhs, size_t count);
</pre>
<!---------- ne pas indenter ---------->  

  <div class="complement">
  <p> Cette fonction <strong class="specialLB">opÃ¨re comme</strong>Â <code class="prettyprint lang-c">strncmp</code> mais seulement sur lesÂ <strong class="defin">n</strong>Â <strong>premiers octets</strong> respectifs des deux chaÃ®nes â€“Â ce nombre Ã©tant codÃ© par la valeur de l'argumentÂ <code class="prettyprint lang-c">count</code>. </p>
  
  <div class="expert" id="memcmp">
  <p> Toutefois, le <strong class="defin">nombre d'octets rÃ©ellement comparÃ©s</strong> <strong class="warning">ne dÃ©passe pas</strong> la <strong>longueur de la plus grande des deux chaÃ®nes</strong>, mÃªme si la valeur de l'argument effectif codÃ© pourÂ <strong class="defin">n</strong> est supÃ©rieur cette longueur. </p>

  <p> Si l'on souhaite une comparaison surÂ <strong class="defin">n</strong>Â octets quelles que soient la longueur des chaÃ®nes, il faut employer la <strong class="title">fonction</strong>Â <code class="prettyprint lang-c">memcmp</code>Â <a class="external" href="https://en.cppreference.com/w/c/string/byte/memcmp" target="_BLANK">C</a>. </p>
  </div><!-- expert -->

  </div><!-- complement -->

  <div class="exemples"><p class="exemples"> Dans l'environnement <strong class="OnlineGDB">OnlineGDB</strong>, on teste les appels deÂ <code class="prettyprint lang-c">strncmp</code> suivants. </p>
  <ul>
    <li> <code class="prettyprint lang-c">strncmp("abd", "abce", 2)</code> retourne la valeurÂ <code class="cmd">0</code>. </li>

    <div class="expert">
    <div class="nobullet"> En effet, les chaÃ®nesÂ <code class="prettyprint lang-c">"abd"</code> etÂ <code class="prettyprint lang-c">"abce"</code> ont leurs <strong>deux premiers caractÃ¨res</strong>Â <code class="prettyprint lang-c">"ab"</code> respectivement <strong class="defin">Ã©gaux</strong>. </div>
    </div><!-- expert -->
    
    <div class="expert">
    <li> <code class="prettyprint lang-c">strncmp("ab\0a", "ab\0z", 4)</code> retourne la valeurÂ <code class="cmd">0</code>. </li>

    <div class="nobullet"> En effet, seuls les deux premiers caractÃ¨res respectifs des deux chaÃ®nes sont comparÃ©s Ã  cause des caractÃ¨res de <strong>fin de chaÃ®ne</strong>Â <code class="prettyprint lang-c">'\0'</code> codÃ©s dans l'une et l'autre enÂ 3<sup>e</sup>Â position (elles sont interprÃ©tÃ©es comme des chaÃ®nes de longueurÂ 2). </div>

    <div class="nobullet"> A contrario, <code class="prettyprint lang-c">memcmp("ab\0a", "ab\0z", 4)</code> retourne la valeurÂ <code class="cmd">-1</code>. </div>

    <li> <code class="prettyprint lang-c">strncmp("Ã™", "Ã©", 1)</code> retourne la valeurÂ <code class="cmd">0</code>. </li>

    <div class="nobullet"> En effet, les caractÃ¨resÂ <code class="prettyprint lang-c">'Ã™'</code> (<code>0xC399</code>) etÂ <code class="prettyprint lang-c">'Ã©'</code> (<code>0xC3A9</code>) ont un <strong>premier octet</strong>Â <code>0xC3</code> <strong class="defin">identique </strong>dans leurÂ codeÂ <strong><em class="sigle">UTFâ€‘8</em></strong>. </div>

    <li> <code class="prettyprint lang-c">strncmp("Ã™", "Ã©", 2)</code> retourne la valeurÂ <code class="cmd">-16</code>. </li>

    <div class="nobullet"> En effet, les caractÃ¨res <code class="prettyprint lang-c">'Ã™'</code> etÂ <code class="prettyprint lang-c">'Ã©'</code> sont encodÃ©s l'un comme l'autre sur <strong>deux octets</strong> enÂ <strong><em class="sigle">UTFâ€‘8</em></strong> et au regard de leurs codes respectifs, <code class="prettyprint lang-c">'Ã™'</code> <strong class="defin">prÃ©cÃ¨de</strong> <code class="prettyprint lang-c">'Ã©'</code>. </div>

    <div class="nobullet"> <em class="remark">Remarque</em>. Ce dernier exemple montre qu'une fonction de comparaison peut retourner une <strong class="defin">valeur nÃ©gative</strong> qui n'est <strong class="warning">pas forcÃ©ment</strong>Â <code class="cmd">-1</code>. Il en va de mÃªme pour les valeurs positivesÂ : elles ne sontÂ pas forcÃ©ment Ã©gales Ã Â <code>1</code>. </div>
    </div><!-- expert -->
  </ul>
  </div><!-- exemples -->
</ol><!-- numbered -->



<h3> Fonctions de manipulation </h3>


<div class="important">
<p> Parmi les <strong class="title">manipulations usuelles</strong> des chaÃ®nes de caractÃ¨res, on a typiquement la <strong class="specialLB">recopie</strong>, la <strong class="specialLB">concatÃ©nation</strong>, l'<strong>affectation uniforme</strong>â€¦ </p> 

<p> Dans l'enâ€‘tÃªte de ces fonctions, les <strong class="specialT">arguments formels</strong> sont usuellement dÃ©signÃ©sÂ : </p>
<ul>
    <li> <code class="prettyprint lang-c">dest</code> pour <strong class="specialT">destination</strong> â€“Â la chaÃ®ne dont l'<strong class="specialO">argument effectif</strong> correspondant est <strong class="defin">modifiÃ©</strong>Â ; ce dernier doit obligatoirement Ãªtre dÃ©clarÃ© comme un <strong>tableau de caractÃ¨res</strong>Â ; </li>

    <li> <code class="prettyprint lang-c">src</code> pour <strong class="specialT">source</strong> â€“Â la chaÃ®ne dont l'<strong class="specialO">argument effectif</strong> n'est <strong class="defin">pas modifiÃ©</strong> mais <strong class="defin">seulement lu</strong>Â ; il peut s'agir d'une chaÃ®ne dÃ©clarÃ©e comme un <strong>tableau</strong> ou un <strong>pointeur de caractÃ¨res</strong>, voire d'une <strong>constante littÃ©rale</strong>. </li>
  </ul>
</div><!-- important -->


<h4> Recopie d'une chaÃ®ne dansÂ uneÂ autre </h4>


<ol class="numbered" style="margin-top:0em">
  <li id="strcpy"> <strong class="title">Recopie complÃ¨te</strong> deÂ <code class="prettyprint lang-c">src</code> dansÂ <code class="prettyprint lang-c">dest</code>Â <a class="external" href="https://en.cppreference.com/w/c/string/byte/strcpy" target="_BLANK">C</a> </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
// string copy 
char * strcpy(char * dest, const char * src);
</pre>
<!---------- ne pas indenter ---------->  
  
  <div class="complement">
  <p> La chaÃ®neÂ <code class="prettyprint lang-c">dest</code> est censÃ©e Ãªtre dÃ©clarÃ©e avec un <strong>nombre d'Ã©lÃ©ments</strong> <strong class="pros">suffisant</strong> pour enregistrer tous les caractÃ¨res deÂ <code class="cmd">src</code> â€“Â caractÃ¨re de fin de chaÃ®neÂ <strong class="specialDR"><em class="sigle">NUL</em></strong> <strong class="defin">inclus</strong>. Sinon, le rÃ©sultat est <strong class="cons">indÃ©fini</strong>. </p>
  
  <div class="expert">
  <p> De plus, les chaÃ®nesÂ <code class="prettyprint lang-c">dest</code> etÂ <code class="prettyprint lang-c">src</code> ne doivent <strong class="warning">pas se chevaucher</strong> (<em class="english">no overlapping</em>) sur le mÃªme espace mÃ©moire â€“Â sinon, le rÃ©sultat est Ã©galement <strong class="cons">indÃ©fini</strong>. </p>
  </div><!-- expert -->
  </div><!-- complement -->

  <div class="important">
  <p> La <strong class="title">fonction</strong>Â <code class="prettyprint lang-c">strcpy</code> permet de coder une <strong class="defin">affectation groupÃ©e</strong> des octets du tableau sur lequelÂ <code class="cmd">dest</code> pointe, pour qu'il prennent respectivement par ordre de position les octets pointÃ©s parÂ <code class="prettyprint lang-c">src</code> jusqu'Ã  son caractÃ¨re de fin de chaÃ®neÂ <strong class="specialDR"><em class="sigle">NUL</em></strong> <strong class="defin">inclus</strong>. </p>

  <p> Les <strong>octets suivants</strong> dans le tableau pointÃ© par <code class="cmd">dest</code> ne sont <strong class="warning">pas affectÃ©s</strong>. </p>

  <p> La <strong class="specialLB">valeur retournÃ©e</strong> est simplement un <strong class="defin">pointeur</strong> sur la chaÃ®neÂ <code class="prettyprint lang-c">dest</code>. </p>
  </div><!-- important -->
  
  <div class="exemples" id="ex-strcpy">
  <p class="exemple"> Dans l'environnement <strong class="OnlineGDB">OnlineGDB</strong>, on peut tester ce <strong class="title">programme acadÃ©mique</strong> qui code un appel de la fonctionÂ <code class="prettyprint lang-c">strcpy</code> (cf.Â la ligneÂ nÂ°Â 13) sur deux chaÃ®nes deÂ caractÃ¨resÂ <code class="prettyprint lang-c">dest</code> etÂ <code class="prettyprint lang-c">src</code> dÃ©clarÃ©es comme des <strong class="defin">tableaux de mÃªme taille</strong> mais initialisÃ©es avec des <strong>contenus diffÃ©rents</strong>. </p>

  <div class="expert">
  <p> Pour <strong class="defin">inspecter le contenu</strong> deÂ <code class="prettyprint lang-c">dest</code> <strong>avant</strong> et <strong>aprÃ¨s</strong> cet appel, on code une fonctionÂ <code class="prettyprint lang-c">scanString</code> (cf.Â les lignesÂ nÂ°Â 18 Ã Â 24) qui prend comme argument une chaÃ®neÂ <code class="prettyprint lang-c">str</code> et une tailleÂ <code class="prettyprint lang-c">count</code>. </p>
  <ul>
    <li> Avec <code class="prettyprint lang-c">printf</code>, elle affiche d'abordÂ <code class="prettyprint lang-c">str</code> via la spÃ©cification de conversion usuelleÂ <code class="cmd" style="color: darkorange;">%s</code>.  </li>
  
    <li> Puis elle affiche successivement <strong>chaque caractÃ¨re</strong> deÂ <code class="prettyprint lang-c">str</code> ou son code s'il n'est pas imprimable, en comptant jusqu'Ã Â <code class="prettyprint lang-c">count</code>. </li>
  </ul>
  </div><!-- expert -->

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;

void scanString(const char * str, size_t count);

char dest[8] = "Hello";
char  src[8] = "hi";


int main(void) {
  scanString(dest, 8);
  strcpy(dest, src);
  scanString(dest, 8);
  return 0;
}

void scanString(const char * str, size_t count) {
  printf("%s\n", str);
  for (const char * c = str; c < str + count; c++) {
    printf(isprint(*c) ? "%3c " : "0x%X ", *c);
  }
  printf("\n");
}
</pre>
<!---------- ne pas indenter ---------->  
  
  <p> On obtient en sortie standard l'affichageÂ :  </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Hello
  H   e   l   l   o 0x0 0x0 0x0 
hi
  h   i 0x0   l   o 0x0 0x0 0x0 
</pre>
<!---------- ne pas indenter ---------->
  
  <div class="expert">
  <p> oÃ¹ l'on voit qu'aprÃ¨s l'appel deÂ <code class="prettyprint lang-c">strcpy</code>, lesÂ <strong>5Â derniers octets</strong> deÂ <code class="prettyprint lang-c">dest</code> n'ont <strong class="warning">pas changÃ©</strong>. </p>

  <p> En effet, bien que la chaÃ®neÂ <code class="prettyprint lang-c">src</code> soit dÃ©clarÃ©e comme un tableau de mÃªme taille queÂ <code class="prettyprint lang-c">dest</code>, son contenu n'est pas intÃ©gralement recopiÃ© dansÂ <code class="prettyprint lang-c">dest</code>. C'est son caractÃ¨re de fin de chaÃ®neÂ <strong class="specialDR"><em class="sigle">NUL</em></strong> (3<sup>e</sup>Â octet) qui achÃ¨ve la copie. </p>

  <p class="square"> Examinons maintenant ce que se produit en cas de <strong class="warning">chevauchement</strong> entre les deux chaÃ®nes passÃ©es dans l'appel deÂ <code class="prettyprint lang-c">strcpy</code>. Dans le programme supra, si l'on remplace la ligneÂ nÂ°Â 13 parÂ : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:13">
  strcpy(dest, dest + 1);
</pre>
<!---------- ne pas indenter ---------->  
  
  <p> ce qui revient Ã  vouloir <strong class="defin">supprimer le premier caractÃ¨re</strong> deÂ <code class="prettyprint lang-c">dest</code>. Comme prÃ©vu, le rÃ©sultat obtenu n'est <strong class="cons">pas satisfaisant</strong>Â : </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Hello
  H   e   l   l   o 0x0 0x0 0x0 
eloo
  e   l   o   o 0x0 0x0 0x0 0x0 
</pre>
<!---------- ne pas indenter ---------->
  
  <p> puisque la recopie est erronÃ©e Ã  partir duÂ 3<sup>e</sup>Â caractÃ¨re (on devrait normalement obtenir <code class="displayDark">ello</code>). On verra infraÂ <a class="infra" href="Cc5-6_chainesCaracteres.html#memcpy"></a> comment rÃ©soudre ce problÃ¨me. </p>
  </div><!-- expert -->
  </div><!-- exemple -->

  <li style="margin-top:1.5em" id="strncpy"> <strong class="title">Recopie deÂ nÂ octets</strong> deÂ <code class="prettyprint lang-c">src</code> dansÂ <code class="prettyprint lang-c">dest</code>Â <a class="external" href="https://en.cppreference.com/w/c/string/byte/strcpy" target="_BLANK">C</a> </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
// string nâ€‘bytes copy 
char * strncpy(char * dest, const char * src, size_t count);
</pre>
<!---------- ne pas indenter ---------->  
  
  <div class="complement">
  <p> Cette fonction <strong class="specialLB">opÃ¨re comme</strong>Â <code class="prettyprint lang-c">strcpy</code> sur lesÂ <strong class="defin">n</strong>Â <strong>premiers octets</strong> respectifs des deux chaÃ®nes â€“Â ce nombre Ã©tant codÃ© par la valeur de l'argumentÂ <code class="prettyprint lang-c">count</code>. </p>

  <div class="expert" id="memcpy">
  <p> Et le <strong class="defin">nombre d'octets rÃ©ellement copiÃ©s</strong> n'est <strong class="pros">pas limitÃ©</strong> par la <strong>longueur de laÂ chaÃ®ne</strong>Â <code class="prettyprint lang-c">src</code>. </p>
  
  <p> En revanche, on est toujours limitÃ© par le fait que les chaÃ®nes <code class="prettyprint lang-c">dest</code> etÂ <code class="prettyprint lang-c">src</code> ne doivent <strong class="warning">pas se chevaucher</strong> sur le mÃªme espace mÃ©moire. </p>

  <p> Si l'on souhaite recopier une partie d'une chaÃ®ne dans elleâ€‘mÃªme, il faut employer la <strong class="title">fonction</strong>Â <code class="prettyprint lang-c">memcpy</code>Â <a class="external" href="https://en.cppreference.com/w/c/string/byte/memcpy" target="_BLANK">C</a>. </p>
  </div><!-- expert -->
  </div><!-- complement -->
  
  <div class="expert">
  <div class="exemples">
  <p class="exemple"> Reprenons l'<strong class="title">exemple acadÃ©mique</strong> supraÂ <a class="supra" href="Cc5-6_chainesCaracteres.html#ex-strcpy"></a> donnÃ© pour illustrer l'usage de la fonctionÂ <code class="prettyprint lang-c">strcpy</code>. </p>
  
  <p class="square"> Dans le programme, si l'on remplace la ligneÂ nÂ°Â 13 parÂ : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:13">
  strncpy(dest, src, 8);
</pre>
<!---------- ne pas indenter ---------->  </p>

<p> on obtient dansÂ <code class="prettyprint lang-c">dest</code> une <strong class="pros">copie intÃ©grale</strong> desÂ <strong class="defin">8Â octets</strong> deÂ <code class="prettyprint lang-c">scr</code>, comme le montre l'affichage obtenu en sortie standardÂ :  </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Hello
  H   e   l   l   o 0x0 0x0 0x0 
hi
  h   i 0x0 0x0 0x0 0x0 0x0 0x0 
</pre>
<!---------- ne pas indenter ---------->

  <p class="square"> Dans le programme, si l'on remplace la ligneÂ nÂ°Â 13 parÂ : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:13">
  memcpy(dest, dest + 1, 7);
</pre>
<!---------- ne pas indenter ---------->  </p>

<p> on obtient dansÂ <code class="prettyprint lang-c">dest</code> une <strong class="pros">copie correcte</strong> de ses octets <strong class="defin">dÃ©calÃ©s deÂ 1Â rang vers la gauche</strong> (d'oÃ¹ la suppression du premier caractÃ¨re de la chaÃ®ne), comme le montre l'affichage obtenu en sortie standardÂ : </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Hello
  H   e   l   l   o 0x0 0x0 0x0 
ello
  e   l   l   o 0x0 0x0 0x0 0x0 
</pre>
<!---------- ne pas indenter ---------->

  </div><!-- exemple -->
  </div><!-- expert -->

</ol><!-- numbered -->


<h4> ConcatÃ©nation d'une chaÃ®ne auÂ boutÂ d'uneÂ autre </h4>


<ol class="numbered" style="margin-top:0em">
  <li id="strcat"> <strong class="title">ConcatÃ©nation complÃ¨te</strong> deÂ <code class="prettyprint lang-c">src</code> au bout deÂ <code class="prettyprint lang-c">dest</code>Â <a class="external" href="https://en.cppreference.com/w/c/string/byte/strcat" target="_BLANK">C</a> </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
// string concatenation 
char * strcat(char * dest, const char * src);
</pre>
<!---------- ne pas indenter ---------->  
  
  <div class="complement">
  <p> La chaÃ®neÂ <code class="prettyprint lang-c">dest</code> est censÃ©e Ãªtre dÃ©clarÃ©e avec un <strong>nombre d'Ã©lÃ©ments</strong> <strong class="pros">suffisant</strong> pour recevoir tous les caractÃ¨res deÂ <code class="cmd">src</code> en plus de ceux qu'elle contient dÃ©jÃ  â€“Â caractÃ¨re de fin de chaÃ®neÂ <strong class="specialDR"><em class="sigle">NUL</em></strong> <strong class="defin">inclus</strong>. Sinon, le rÃ©sultat est <strong class="cons">indÃ©fini</strong>. </p>
  
  <div class="expert">
  <p> En principe, les chaÃ®nesÂ <code class="prettyprint lang-c">dest</code> etÂ <code class="prettyprint lang-c">src</code> ne doivent <strong class="warning">pas se chevaucher</strong> (<em class="english">no overlapping</em>) sur le mÃªme espace mÃ©moire â€“Â sinon, le rÃ©sultat est Ã©galement <strong class="cons">indÃ©fini</strong>. </p>
  </div><!-- expert -->
  </div><!-- complement -->

  <div class="important">
  <p> La <strong class="title">fonction</strong>Â <code class="prettyprint lang-c">strcat</code> code une <strong class="defin">affectation groupÃ©e</strong> des octets du tableau sur lequelÂ <code class="cmd">dest</code> pointe Ã  partir du caractÃ¨re de fin de chaÃ®neÂ <strong class="specialDR"><em class="sigle">NUL</em></strong> <strong class="defin">inclus</strong>, pour qu'il prennent respectivement par ordre de position les octets pointÃ©s parÂ <code class="prettyprint lang-c">src</code> jusqu'Ã  son caractÃ¨re de fin de chaÃ®neÂ <strong class="specialDR"><em class="sigle">NUL</em></strong> <strong class="defin">inclus</strong>. </p>
  
  <div class="expert">
  <p> Les <strong>octets suivants</strong> dans le tableau pointÃ© par <code class="cmd">dest</code> ne sont <strong class="warning">pas affectÃ©s</strong>. </p>
  </div><!-- expert -->

  <p> La <strong class="specialLB">valeur retournÃ©e</strong> est simplement un <strong class="defin">pointeur</strong> sur la chaÃ®neÂ <code class="prettyprint lang-c">dest</code>. </p>
  </div><!-- important -->

  <div class="exemples" id="ex-strcpy">
  <p class="exemples"> Dans l'environnement <strong class="OnlineGDB">OnlineGDB</strong>, on peut tester ce <strong class="title">programme acadÃ©mique</strong> similaire Ã  celui pour illustrer l'usage de la fonctionÂ <code>strcpy</code>Â <a class="supra" href="Cc5-6_chainesCaracteres.html#ex-strcpy" target="_BLANK"></a>. L'appel de la fonctionÂ <code class="prettyprint lang-c">strcat</code> figure Ã  la ligneÂ nÂ°Â 14. </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;

void scanString(const char * str, size_t count);

char dest[8] = "Foo";
char  src[8] = "Bar";


int main(void) {

  scanString(dest, 8);
  strcat(dest, src);
  scanString(dest, 8);
  return 0;
}

void scanString(const char * str, size_t count) {
  printf("%s\n", str);
  for (const char * c = str; c < str + count; c++) {
    printf(isprint(*c) ? "%3c " : "0x%X ", *c);
  }
  printf("\n");
}
</pre>
<!---------- ne pas indenter ---------->  
  
  <p> Comme prÃ©vu, on obtient en sortie standard l'affichageÂ :  </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Foo
  F   o   o 0x0 0x0 0x0 0x0 0x0 
FooBar
  F   o   o   B   a   r 0x0 0x0 
</pre>
<!---------- ne pas indenter ---------->

  <div class="expert">
  <p class="square"> Dans le programme prÃ©cÃ©dent, si on ajoute au dÃ©but de la fonctionÂ <code class="prettyprint lang-c">main</code> l'instructionÂ : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:12">
  dest[7] = '*';
</pre>
<!---------- ne pas indenter ---------->  
  
  <p> alors on obtient en sortie standard l'affichageÂ :  </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Foo
  F   o   o 0x0 0x0 0x0 0x0   * 
FooBar
  F   o   o   B   a   r 0x0   * 
</pre>
<!---------- ne pas indenter ---------->  

  <p> On voit donc que, comme prÃ©vu, la concatÃ©nation n'a pas modifiÃ© le dernier Ã©lÃ©ment deÂ <code class="prettyprint lang-c">dest</code>. </p>
  </div><!-- expert -->
  </div><!-- exemples -->  
  
  <li style="margin-top:1.5em" id="strncat"> <strong class="title">ConcatÃ©nation deÂ nÂ octets</strong> deÂ <code class="prettyprint lang-c">src</code> au bout deÂ <code class="prettyprint lang-c">dest</code>Â <a class="external" href="https://en.cppreference.com/w/c/string/byte/strncat" target="_BLANK">C</a> </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
// string nâ€‘bytes concatenation 
char * strncat(char * dest, const char * src, size_t count);
</pre>
<!---------- ne pas indenter ---------->  
  
  <div class="complement">
  <p> Cette fonction <strong class="specialLB">opÃ¨re comme</strong>Â <code class="prettyprint lang-c">strcat</code> mais en copiant au bout deÂ <code class="prettyprint lang-c">dest</code> lesÂ <strong class="defin">n</strong>Â <strong>premiers octets</strong> deÂ <code class="prettyprint lang-c">src</code> â€“Â ce nombre Ã©tant codÃ© par la valeur de l'argumentÂ <code class="prettyprint lang-c">count</code>. De plus, un caractÃ¨re de fin de chaÃ®neÂ <strong class="specialDR"><em class="sigle">NUL</em></strong> est <strong class="defin">ajoutÃ©</strong> juste aprÃ¨s les caractÃ¨res concatÃ©nÃ©s. </p>

  <div class="expert" id="memcpy">
  <p> De plus, le <strong class="defin">nombre d'octets rÃ©ellement concatÃ©nÃ©s</strong> est <strong class="pros">limitÃ©</strong> par la <strong>longueur de laÂ chaÃ®ne</strong>Â <code class="prettyprint lang-c">src</code>. </p>
  
  <p> Si l'on souhaite s'affranchir de cette limite, il faut employer la <strong class="title">fonction</strong>Â <code class="prettyprint lang-c">memmove</code>Â <a class="external" href="https://en.cppreference.com/w/c/string/byte/memmove" target="_BLANK">C</a>. </p>
  </div><!-- expert -->
  </div><!-- complement -->
  
  <div class="expert">
  <div class="exemples">
  <p class="exemples"> Reprenons l'<strong class="title">exemple acadÃ©mique</strong> supraÂ <a class="supra" href="Cc5-6_chainesCaracteres.html#ex-strcpy"></a> donnÃ© pour illustrer l'usage de la fonctionÂ <code class="prettyprint lang-c">strcpy</code>. </p>
  
  <p class="square"> Dans le programme, si l'on remplace la ligneÂ nÂ°Â 7 parÂ : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:7">
char dest[8] = "Foo\0****";
</pre>
<!---------- ne pas indenter ----------> 
  
  <p> et la ligneÂ nÂ°Â 14 parÂ :</p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:14">
  strncat(dest, src, 2);
</pre>
<!---------- ne pas indenter ---------->  

  <p> on opÃ¨re au bout deÂ <code class="prettyprint lang-c">dest</code> la <strong>concatÃ©nation</strong> deÂ <strong class="defin">2Â premiers octets</strong> deÂ <code class="prettyprint lang-c">scr</code>, comme le montre l'affichage obtenu en sortie standardÂ :  </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Foo
  F   o   o 0x0   *   *   *   *
FooBa
  F   o   o   B   a 0x0   *   * 
</pre>
<!---------- ne pas indenter ---------->

  <p> Et si l'on codeÂ <code class="prettyprint lang-c">5</code> dans l'appel deÂ <code class="prettyprint lang-c">strncat</code> pour l'argumentÂ <code class="prettyprint lang-c">count</code>, on obtientÂ : </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Foo
  F   o   o 0x0   *   *   *   * 
FooBar
  F   o   o   B   a   r 0x0   * 
</pre>
<!---------- ne pas indenter ---------->

  <p> oÃ¹ l'on voir que leÂ <strong>dernier octet</strong> deÂ <code class="prettyprint lang-c">dest</code> n'a <strong class="warning">pas Ã©tÃ© Ã©crasÃ©</strong> par la concatÃ©nation, qui s'est arrÃªtÃ©e au caractÃ¨re de fin de chaÃ®ne deÂ <code class="prettyprint lang-c">src</code> (placÃ© juste aprÃ¨s deÂ <code class="prettyprint lang-c">"Bar"</code>). </p>
  
  <p> Mais si l'on remplace la ligneÂ nÂ°Â 14 parÂ : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:14">
  memmove(dest + 3, src, 5);
</pre>
<!---------- ne pas indenter ---------->  

  <p> alors on obtient un <strong class="pros">Ã©crasement complet</strong> des <strong class="defin">5Â derniers octets</strong> deÂ <code class="prettyprint lang-c">dest</code>, comme le montre l'affichage obtenu en sortie standardÂ :  </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Foo
  F   o   o 0x0   *   *   *   * 
FooBar
  F   o   o   B   a   r 0x0 0x0 
</pre>
<!---------- ne pas indenter ---------->

  </div><!-- exemples -->
  </div><!-- expert -->

</ol><!-- numbered -->


<h4> Affectation uniforme d'un caractÃ¨re rÃ©pÃ©titif </h4>


<p> Il existe <strong>une fonction</strong> pour coder <strong class="title"> l'affectation groupÃ©e</strong> deÂ <strong class="defin">n</strong>Â occurrences du <strong class="defin">mÃªme caractÃ¨reÂ <em class="sigle">ASCII</em></strong> dans une chaÃ®neÂ <a class="external" href="https://en.cppreference.com/w/c/string/byte/memset" target="_BLANK">C</a>Â : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
// memory set 
void * memset(void * dest, int ch, size_t count);
</pre>
<!---------- ne pas indenter ---------->  
  
<div class="complement">
<p> La chaÃ®neÂ <code class="prettyprint lang-c">dest</code> doit Ãªtre dÃ©clarÃ©e de <strong>type</strong>Â <code class="prettyprint lang-c">char[]</code> ou <code class="prettyprint lang-c">unsigned char[]</code> avec un <strong>nombre d'Ã©lÃ©ments</strong> supÃ©rieur ou Ã©gal Ã  la valeurÂ <strong class="defin">n</strong> prise par l'argumentÂ <code class="prettyprint lang-c">count</code>. </p>

<p> <em class="remark">Attention</em>. Comme pour la fonctionÂ <code class="prettyprint lang-c">strchr</code> (cf.Â supraÂ <a class="supra" href="Cc5-6_chainesCaracteres.html#strchr"></a>), l'<strong class="specialT">argument formel</strong>Â <code class="prettyprint lang-c">ch</code>, bien que dÃ©clarÃ© de <strong>type</strong>Â <code class="prettyprint lang-c">int</code> dans l'enâ€‘tÃªte de la fonction, est <strong class="warning">converti</strong> dans le <strong>type</strong>Â <code class="prettyprint lang-c">char</code> dans le corps de dÃ©finition de la fonction. </p>

<p> C'est pourquoi, dans l'appel de la fonctionÂ <code class="prettyprint lang-c">memset</code>, son <strong class="specialO">argument effectif</strong> correspondant ne doit donc prendre qu'une <strong>valeur d'encodage</strong> comprise entreÂ <code>0x00</code> etÂ <code>0xFF</code>. Ce faisant, il peut Ã©ventuellement Ãªtre codÃ© comme une <strong>valeur de caractÃ¨re</strong> entre guillemets simplesÂ <code class="prettyprint lang-c">''</code> ou une <strong>sÃ©quence d'Ã©chappement</strong>. </p> 
</div><!-- complement -->

<div class="important">
<p> La <strong class="title">fonction</strong>Â <code class="prettyprint lang-c">memset</code> opÃ¨re l'<strong class="defin">affectation groupÃ©e</strong> Ã  la valeur deÂ <code class="prettyprint lang-c">ch</code> desÂ <strong>n</strong>Â premiers octets du tableau sur lequelÂ <code class="cmd">dest</code> pointe. </p>

<p> Les <strong>octets suivants</strong> du tableau ne sont <strong class="warning">pas affectÃ©s</strong>. En particulier, il n'y <strong class="warning">pas d'ajout automatique</strong> d'un caractÃ¨re de fin de chaÃ®neÂ <strong class="specialDR"><em class="sigle">NUL</em></strong> Ã  l'octet de positionÂ <em class="bold"><var>n</var>Â +Â 1</em>. </p>

<p> La <strong class="specialLB">valeur retournÃ©e</strong> est simplement un <strong class="defin">pointeur</strong> sur la chaÃ®neÂ <code class="prettyprint lang-c">dest</code>. </p>
</div><!-- important -->

<div class="exemples" id="ex-memset"><p class="exemples"> Dans l'environnement <strong class="OnlineGDB">OnlineGDB</strong>, on effectue les tests suivants. </p>
<ul>
  <li> AprÃ¨s la dÃ©claration <code class="prettyprint lang-c">char str[8] = {0x0};</code> l'instructionÂ : <br>
  <span class="inline">
    <code class="prettyprint lang-c">printf("%s\n", (char*) memset(str, '=', 4));</code> 
  </span> <br>
  afficheÂ <code class="displayDark">====</code> en sortie standard. </li>
   
  <div class="expert"> 
  <div class="nobullet"> En effet, le tableauÂ <code class="prettyprint lang-c">str</code> a Ã©tÃ© <strong class="defin">initialisÃ©</strong> avec tous ses Ã©lÃ©ments valantÂ <strong class="specialDR"><em class="sigle">NUL</em></strong>. Le premier de ces Ã©lÃ©ments constitue donc le caractÃ¨re de fin de chaÃ®ne. </div>
  </div><!-- expert -->

  <li> AprÃ¨s la dÃ©claration <code class="prettyprint lang-c">char str[8] = "0123456";</code> l'instructionÂ : <br>
  <span class="inline">
    <code class="prettyprint lang-c">printf("%s\n", (char*) memset(str, '=', 4));</code> 
  </span> <br>
  afficheÂ <code class="displayDark">====456</code> en sortie standard. </li>

  <div class="expert">
  <div class="nobullet"> Et l'instructionÂ : <br>
  <span class="inline">
    <code class="prettyprint lang-c">printf("%s\n", (char*) memset(str, '=', 8));</code> 
  </span> <br>
  <em>peut</em> afficherÂ <code class="displayDark">========</code> en sortie standard. </div> 
  
  <div class="nobullet"> Ici, <strong class="warning">il faut Ãªtre trÃ¨s vigilantÂ !</strong> </div>
  <ul>
    <li> Le tableauÂ <code class="prettyprint lang-c">str</code> contient donc <strong>8Â caractÃ¨res</strong>Â <code class="prettyprint lang-c">'='</code> et sans y prendre garde, on vient d'<strong class="cons">Ã©craser le caractÃ¨re de fin de chaÃ®ne</strong> que contenaitÂ <code class="prettyprint lang-c">str[7]</code>. </li>
  
    <li> En sortie standard, la fonction <code class="prettyprint lang-c">printf</code> <em>peut</em> afficher seulement cesÂ 8Â caractÃ¨res si, dans la mÃ©moire, l'octet consÃ©cutif Ã Â <code class="prettyprint lang-c">str[7]</code> vaut <strong>par Â«Â chanceÂ Â»</strong>Â <code class="cmd">0</code>, de sorte qu'il est interprÃ©tÃ© comme caractÃ¨re de fin de chaÃ®ne. </li>

    <li> Mais si on compile et exÃ©cute le programme ciâ€‘dessous, oÃ¹ l'on dÃ©clare juste aprÃ¨sÂ <code class="prettyprint lang-c">str</code> une <strong class="defin">autre chaÃ®ne</strong> de <strong>8Â caractÃ¨res</strong>Â <code class="prettyprint lang-c">nxt</code>Â (cf.Â la ligneÂ nÂ°Â 7): </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void scanString(const char * str, size_t count);

char str[8] = "0123456";
char nxt[8] = "789...";

int main(void) {
  memset(str, '=', 8);
  printf("%s\n", str);
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->  
  
    <div class="nobullet"> alors on obtient en sortie standard l'<strong class="cons">affichage consÃ©cutif</strong> deÂ <code class="prettyprint lang-c">str</code> etÂ <code class="prettyprint lang-c">nxt</code>, ce qui n'est <strong class="warning">pas codÃ©</strong> Ã  la ligneÂ nÂ°Â 11Â : </div>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
========789...
</pre>
<!---------- ne pas indenter ---------->
  
    <div class="nobullet">  En effet, les tableauxÂ <code class="prettyprint lang-c">str</code> etÂ <code class="prettyprint lang-c">nxt</code> ayant l'un et l'autre une taille deÂ 8Â octets, ils sont <strong class="defin">stockÃ©s l'un aprÃ¨s l'autre</strong> dans la mÃ©moire <strong>sans octets de padding</strong> (leur contrainte d'alignement est prÃ©cisÃ©ment deÂ 8Â octets). Le tableauÂ <code class="prettyprint lang-c">str</code> n'ayant pas de caractÃ¨re de fin de chaÃ®ne, c'est donc celui deÂ <code class="prettyprint lang-c">nxt</code> qui joue ce rÃ´le et termine l'affichage. </div>
  </ul>
  </div><!-- expert -->
</ul>
</div><!-- exemples -->



<h3 id="sprintf"> Fonctions de composition et d'analyse polyvalentes </h3>



<p> Dans le fichier d'enâ€‘tÃªteÂ <code class="filename">stdio.h</code> de la bibliothÃ¨que standard du langageÂ <strong>C</strong> sont dÃ©clarÃ©es les <strong class="title">fonctions</strong>Â <code class="prettyprint lang-c">sprintf</code>Â <a class="external" href="https://en.cppreference.com/w/c/io/fprintf" target="_BLANK">C</a> etÂ <code class="prettyprint lang-c">sscanf</code>Â <a class="external" href="https://en.cppreference.com/w/c/io/fscanf" target="_BLANK">C</a>. </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
int sprintf(char * buffer, const char * format, ... );
int sscanf(const char * buffer, const char * format, ... );
</pre>
<!---------- ne pas indenter ---------->  

<div class="important">
<p> Les <strong class="title">fonctions</strong>Â <code class="prettyprint lang-c">sprintf</code> etÂ <code class="prettyprint lang-c">sscanf</code> constituent respectivement une <strong>variante</strong> des fonctionsÂ <code>printf</code> etÂ <code>scanf</code>. Elles opÃ¨rent sur une <strong class="defin">chaÃ®ne de caractÃ¨re</strong> â€“Â d'oÃ¹ le prÃ©fixeÂ <code>s</code> de leur nomÂ â€“ au lieu des <strong>pÃ©riphÃ©riques d'entrÃ©esâ€‘sorties standards</strong> (Ã©cran et clavier). </p>

<p> Dans leur enâ€‘tÃªte (cf.Â ciâ€‘dessus), cette chaÃ®ne de caractÃ¨re est nommÃ©e <code class="prettyprint lang-c">buffer</code> et constitue le <strong class="specialT">premier argument formel</strong> <strong>avant</strong> la chaÃ®ne de format (nommÃ©e <code>format</code>).   </p>
</div><!-- important -->

<div class="complement">
<p> L'<strong class="title">argument</strong>Â <code class="prettyprint lang-c">buffer</code>Â : </p>
<ul>
  <li> est composÃ©e parÂ <code class="prettyprint lang-c">sprintf</code> â€“Â donc son <strong class="specialO">argument effectif</strong> correspondant doit Ãªtre dÃ©clarÃ© comme un <strong>tableau de caractÃ¨res</strong> avec un <strong class="defin">nombre d'Ã©lÃ©ment suffisant</strong> pour stocker ceux codÃ©s dans la chaÃ®ne de format â€“Â <strong class="defin">sans oublier</strong> de compter le caractÃ¨re de fin de chaÃ®neÂ <strong class="specialDR"><em class="sigle">NUL</em></strong> automatiquement ajoutÃ©Â ;  </li>

  <li> est analysÃ©e parÂ <code class="prettyprint lang-c">sscanf</code> â€“Â donc son <strong class="specialO">argument effectif</strong> correspondant peut Ãªtre dÃ©clarÃ© indiffÃ©remment comme un <strong>pointeur</strong> ou un <strong>tableau</strong> de caractÃ¨resÂ ; il peut Ã©galement s'agir d'une <strong>constante littÃ©rale</strong>.  </li>
</ul>
<p> Par ailleurs, la trÃ¨s complexe <strong class="title">syntaxe de codage</strong> des autres arguments des fonctionsÂ <code class="prettyprint lang-c">sprintf</code> etÂ <code class="prettyprint lang-c">sscanf</code> est <strong class="pros">la mÃªmes</strong> que pourÂ <code class="prettyprint lang-c">printf</code> etÂ <code class="prettyprint lang-c">scanf</code>. Succinctement abordÃ©e auÂ chap.Â C2â€‘VIÂ <a class="previous" href="../C2-ElementsLangage/Cc2-6_entreesSortiesStandards.html#printf" target="_BLANK"></a>), son Ã©tude est approfondie au chap.Â C5â€‘VIIÂ <a class="next" href="http://www.lycee-ferry-versailles.fr/snir/ModuleC/C5-StructuresPointeurs/Cc5-7_flotsEntreesSorties.html" target="_BLANK"></a>. </p>
</div><!-- complement -->

<div class="exemples"><p class="exemples"> Reprenons des <strong class="title">exemples acadÃ©miques</strong> proposÃ©s auÂ chap.Â C2â€‘VIÂ <a class="previous" href="../C2-ElementsLangage/Cc2-6_entreesSortiesStandards.html#exemplesPrintf" target="_BLANK"></a>Â <a class="previous" href="../C2-ElementsLangage/Cc2-6_entreesSortiesStandards.html#exemplesScanf" target="_BLANK"></a>. </p>
<ul>
  <li> AprÃ¨s la dÃ©claration <code class="prettyprint lang-c">char date[11];</code> l'instructionÂ : <br>
  <span class="inline">
    <code class="prettyprint lang-c">sprintf(date, "%02u/%02u/%u", 1, 9, 2019);</code> 
  </span> <br>
  compose la chaÃ®ne <code class="prettyprint lang-c">"01/09/2019"</code> dans la variableÂ <code class="prettyprint lang-c">date</code>. </li>

  <li> RÃ©ciproquement, aprÃ¨s les dÃ©clarations <code class="prettyprint lang-c">unsigned day, month, year;</code> l'instructionÂ : <br>
  <span class="inline">
    <code class="prettyprint lang-c">sscanf("01/09/2019", "%02u/%02u/%u", &day, &month, &year);</code> 
  </span> <br>
  affecte aux variablesÂ <code class="prettyprint lang-c">day</code>, <code class="prettyprint lang-c">month</code> etÂ <code class="prettyprint lang-c">year</code> respectivement les valeursÂ <code>1</code>, <code>9</code> etÂ <code>2019</code>. </li>
</ul>
</div><!-- exemple -->


















<h2> Les chaÃ®ne deÂ caractÃ¨res dynamiques enÂ langageÂ <em>C++</em> </h2>



<h3> GÃ©nÃ©ralitÃ©s </h3>



<p> En langageÂ <strong>C++</strong>, il est bien Ã©videmment <strong class="pros">possible</strong> d'employer les <strong class="title">chaÃ®nes de styleÂ C</strong>, et c'est d'ailleurs <strong class="warning">incontournable</strong> pour certaines fonctionnalitÃ©s, notamment lorsque l'on code des <strong>arguments Ã  la fonction</strong>Â <code class="prettyprint lang-c">main</code>. </p>

<p> NÃ©anmoins, les concepts de la programmation orientÃ©e objet permettent d'implÃ©menter efficacement des <strong class="title">chaÃ®nes de caractÃ¨res dynamiques</strong>. Dans cette perspective, la bibliothÃ¨que standard duÂ <strong>C++</strong> comporte un module dont le fichier d'enâ€‘tÃªteÂ <code class="filename">string</code> qui dÃ©finit la classeÂ <code class="type">string</code>. Par rapport aux types  offre au codeur une grande souplesse.</p>



<h3> DÃ©claration d'un objet de classeÂ <code class="type">string</code> </h3>



<div class="complement">
<p> Le fichier d'enâ€‘tÃªteÂ <code class="filename">string</code> de la bibliothÃ¨que standard duÂ <strong>C++</strong> ne dÃ©finit pas seulement une classe mais une <strong class="title">famille de classes</strong> qui sont toutes basÃ©es sur le <strong class="defin">mÃªme patron</strong> â€“Â en anglais, <strong>template</strong>Â <a class="external" href="https://fr.wikipedia.org/wiki/Template_(programmation)" target="_BLANK">W</a>Â â€“ nommÃ©Â <code class="type">basic_string</code>. </p>

<p> Le <strong class="defin">polymorphisme</strong> duÂ <strong>C++</strong> permet ainsi de dÃ©cliner efficacement la dÃ©finition de chacune des classes de cette famille en fonction du <strong class="specialG">type</strong> des <strong class="specialLB">unitÃ©s d'encodage</strong> qu'elle utilise pour les caractÃ¨res. En particulierÂ :  </p>
<ul>
  <li> la classeÂ <code class="type">string</code> emploie le type <code class="prettyprint lang-c">char</code>Â ;   </li>

  <li> la classeÂ <code class="type">u8string</code> emploie le type <code class="prettyprint lang-c">char8_t</code>Â ;   </li>

  <li> la classeÂ <code class="type">u16string</code> emploie le type <code class="prettyprint lang-c">char16_t</code>Â ;   </li>

  <li> la classeÂ <code class="type">u32string</code> emploie le type <code class="prettyprint lang-c">char32_t</code>Â ;   </li>
</ul>
<p> sachant qu'avec certaines implÃ©mentations â€“Â notamment <strong>GCC</strong> sous <em class="mark">Linux</em>Â â€“Â la classeÂ <code class="type">string</code> est compatible avec le format d'encodageÂ <strong><em class="sigle">UTFâ€‘8</em></strong>. </p>
</div><!-- complement -->



<div class="important">
<p> Dans un programme enÂ <strong>C++</strong>, la dÃ©claration d'une <strong class="title">objet variable</strong> de classeÂ <code class="type">string</code> se code via la syntaxe suivanteÂ : <br>
<span class="inline">
  <code class="prettyprint lang-c"> <span class="nocode" style="font-size: 105%"><code class="type">std::string</code></span> <span class="nocode"><strong class="specialN">identificateur</strong>Â Â </span><span class="nocode"><span style="color: darkgrey; font-style: normal;">[</span></span> = <span class="nocode"><strong class="specialO">chaÃ®neÂ 1</strong>Â Â Â <strong class="specialO">chaÃ®neÂ 2</strong> <span style="color: darkgrey; font-style: normal;">Â â€¦Â <strong class="specialO">chaÃ®neÂ i</strong>Â ]</span></span>; </code>
</span> <br>
oÃ¹ les <strong>constantes littÃ©rales</strong> <strong class="specialO">chaÃ®neÂ 1</strong>, <strong class="specialO">chaÃ®neÂ 2</strong>â€¦ adoptent la <strong class="pros">mÃªme syntaxe</strong> qu'en langageÂ <strong>C</strong> (prÃ©fixe d'encodage facultatif et saisie entre guillemets doubles â€“Â cf.Â supraÂ <a class="supra" href="Cc5-6_chainesCaracteres.html#stringLiteral"></a>).
</p>

<p> Dans cette syntaxe, on peut simplifier le <strong class="specialG">descripteur de classe</strong> avec justeÂ <code class="type">string</code> en codant prÃ©alablement l'instructionÂ : <br>
<span class="inline">
  <code class="prettyprint lang-c">using namespace std;</code>
</span> <br>
c'estâ€‘Ã â€‘dire en prÃ©cisant que le programme utilise l'<strong>espace de nom standard</strong>Â <a class="external" href="https://en.wikipedia.org/wiki/Namespace#C++" target="_BLANK">W</a>, nommÃ©Â <code class="prettyprint lang-c">std</code>. </p>
</div><!-- important -->

<div class="expert">
<p> Comme la <strong>dÃ©claration d'une chaÃ®ne de styleÂ C</strong>, celle d'un objet de classeÂ <code class="type">string</code> peut Ãªtre assortie de <strong class="title">modificateurs</strong> commeÂ <code class="prettyprint lang-c">const</code> et/ouÂ <code class="prettyprint lang-c">static</code> (cf.Â chap.Â C4â€‘IIÂ <a class="previous" href="../C4-Fonctions/Cc4-1_fonctionsGeneralites.html#classeStatique" target="_BLANK"></a>).  </p>

<p> De plus, il Ã©galement possible d'adopter les <strong class="title">syntaxes alternatives</strong> du <strong>C++</strong> pour l'<strong class="defin">initialisation</strong> d'une donnÃ©eÂ (cf.Â chap.Â C2â€‘IIIÂ <a class="previous" href="../C2-ElementsLangage/Cc2-3_declarationDonnees.html#initC++" target="_BLANK"></a>).  </p>
</div><!-- expert -->


<div class="exemples">
<p class="exemple"> Le <strong class="title">programme acadÃ©mique</strong> ciâ€‘dessous donne un simple exemple de <strong class="defin">dÃ©claration</strong> enÂ <strong>C++</strong> d'une <strong>variable</strong> de classeÂ <code class="type">string</code> nommÃ©eÂ <code class="prettyprint lang-c">mess</code> et initialisÃ©e avec des caractÃ¨res accentuÃ©s (cf.Â la ligneÂ nÂ°Â 7). Il peut Ãªtre testÃ© dans l'environnement <strong class="OnlineGDB">OnLineGDB</strong>. </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;cstdio&gt;
#include &lt;string&gt;

using namespace std;

int main() {
  string mess = "Ã€ bientÃ´t.";
  printf("%s\n", mess.c_str());
} 
</pre>
<!---------- ne pas indenter ---------->  

<div class="expert">
<p> <em class="remark">Remarque</em>. L'<strong class="title">affichage</strong> en sortie standard avec la fonctionÂ <code class="prettyprint lang-c">printf</code> d'une chaÃ®ne de classeÂ <code class="type">string</code>  nÃ©cessite un recours Ã  la <strong>mÃ©thode</strong>Â <code class="prettyprint lang-c">c_str</code> (dÃ©taillÃ©e infraÂ <a class="external" href="Cc5-6_chainesCaracteres.html#c_str"></a>), car la spÃ©cification de conversionÂ <code class="cmd" style="color: darkorange;">%s</code> attend une valeur de typeÂ <code class="prettyprint lang-c">char*</code>. </p>
</div><!-- expert -->
</div><!-- exemple -->


<h3> OpÃ©rateurs de la classeÂ <code class="type">string</code> </h3>



<h3> Principales mÃ©thodes de la classeÂ <code class="type">string</code> </h3>



<h3> La classeÂ <code class="prettyprint lang-c">String</code> du frameworkÂ <em class="mark">Arduino</em> </h3>

</section>

</div><!-- #scrollingFrame -->

</div><!-- #mainFrame -->

</body>

</html>
