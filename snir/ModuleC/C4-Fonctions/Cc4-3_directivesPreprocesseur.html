<!DOCTYPE html>

<html 
  data-module="C"
  data-pagetype="Chapitre"
  data-modulepartnumber="4"
  data-pagenumber="III"
  data-pageState="OK"
  data-pageheadtitle="Préprocesseur"
  data-pagefulltitle="Les prétraitements du préprocesseur"
  data-authorname="François GIRAULT"
  data-authormail="francois.girault@ac-versailles.fr"
  lang="fr">

<script src="../../js/operateData.js"></script>

<!-- The following script MUST be coded here and not anywhere else! -->
<script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>

<head> 
  <meta charset="utf-8">
  <script src="../../js/makeHead.js"></script>
</head>

<body>

<nav id="navPannel" style="display: block">
  <script src="../../js/makeNavPannel.js"></script>
</nav>

<div id="mainFrame">
  
<header class="band">
  <script src="../../js/makeHeader.js"></script>
</header> 

<div id="scrollingFrame">

<footer class="band">
  <script src="../../js/makeFooter.js"></script>
</footer>

<section>

<div id="mainTitle">
  <script src="../../js/makeTitle.js"></script>
</div>




<!-- relecture jusqu'à la partie 5.6 en janv./fév. 2023 -->



<div class="exergue">
<p class="square">  À partir d'un code source, la <strong>traduction en code exécutable</strong> nécessite de <strong class="defin">nombreux traitements</strong>. Les normes des langages <strong>C</strong> et <strong>C++</strong> distinguent respectivement <strong>huit</strong> et <strong>neuf</strong> <strong class="specialLB">phases</strong> <a class="external" href="https://en.cppreference.com/w/c/language/translation_phases" target="_BLANK">C</a> <a class="external" href="https://en.cppreference.com/w/cpp/preprocessor" target="_BLANK">C++</a>. Dans la pratique – et c'est une <strong class="pros">particularité remarquable</strong> de ces deux langages – les six premières phases de la traduction sont confiée à un <strong>composant logiciel spécifique</strong>, mais néanmoins intégré à la chaîne de compilation, appelé <strong class="title">préprocesseur</strong> <a class="external" href="https://fr.wikipedia.org/wiki/Préprocesseur" target="_BLANK">W</a>. On peut alors parler de <strong class="defin">prétraitements</strong> – ou <strong class="defin">précompilation</strong> – du code source, en anglais, <strong>preprocessing</strong>. </p>

<p> Ce chapitre est consacré à l'étude d'un <strong class="title">préprocesseur C</strong>, noté en abrégé <strong class="title"><em class="mark">CPP</em></strong> <a class="external" href="https://fr.wikipedia.org/wiki/Préprocesseur_C" target="_BLANK">W</a> (à ne pas confondre avec l'extension <code class="filename">.cpp</code> des fichiers sources en langage <em class="mark">C++</em>). Il ne présente <strong class="defin">pas de différences significatives</strong> avec un préprocesseur du <strong>C++</strong> qui justifieraient, dans le cadre de ce cours, un exposé spécifique pour ce dernier. </p>

<div class="expert">
<p> En comparaison, les <strong class="title">langages plus modernes</strong> comme <em class="mark">Ada</em>, <em class="mark">Java</em>, <em class="mark">Python</em>… n'emploient <strong class="cons">pas de préprocesseur</strong> (ils sont conçus pour s'en passer). Néanmoins, il existe des <strong class="defin">préprocesseurs généralistes</strong>, comme par exemple <strong class="specialLB"><em class="mark">GNU M4</em></strong> <a class="external" href="https://en.wikipedia.org/wiki/M4_(computer_language)" target="_BLANK">W</a> qui peuvent s'adapter si besoin à toutes sortes de codes sources pour opérer des prétraitements aussi puissants que ceux de <strong>CPP</strong>. Dans une formation aux bases de la programmation, l'étude de <strong>CPP</strong> présente donc un <strong class="pros">intérêt général</strong>. </p>
</div><!-- expert -->

<p class="square"> A contrario d'un compilateur, un préprocesseur ne produit <strong class="defin">aucun élément exécutable</strong>, aussi est‑il en principe <strong class="pros">indépendant de la machine cible</strong> pour laquelle le programme est codé. Cependant, dans le cas de <strong class="title"><em class="mark">CPP</em></strong>, il existe bien évidemment <strong>différentes implémentations</strong> : celle du <em>projet <em class="mark">GNU</em></em> (cf. chap. C1‑II <a class="previous" href="../C1-Generalites/Cc1-2_langagesCetCpp.html#GCC" target="_BLANK"></a>), de <em class="mark">Clang</em>, de <em class="mark">Microsoft</em>, etc. </p>

<p> Dans ce chapitre, on étudiera uniquement le préprocesseur <strong class="title">CPP</strong> intégré à la chaîne de compilation <strong class="defin">GCC</strong> – donc du <em>projet</em> <em class="mark">GNU</em> – testé avec un PC sous <strong>Linux</strong> (sous <em class="mark">Windows</em>, avec la chaîne de compilation <em class="mark">MinGW</em>, les résultats obtenus sont très similaires). </p>

<p class="square"> Dans une chaîne de compilation <strong>C</strong> ou <strong>C++</strong>, le <strong class="title">rôle de CPP</strong> est double : </p>
<ol class="numbered" style="margin-top:0em">
  <li> Il opère des <strong class="specialLB">prétraitements implicites</strong> sur le fichier source, préparatoires à la compilation, en convertissant le <strong>jeu de caractères</strong> employé, en supprimant les <strong>fins de lignes fictives</strong>, en uniformisant <strong>caractères d'espacement</strong> et supprimant les <strong>commentaires</strong>. </li>

  <li> Il permet au programmeur de coder <strong class="specialLB">prétraitements explicites</strong> sur le fichier source par le biais d'une <strong>syntaxe spécifique</strong> différente de celle des instructions – remarquable notamment par le <strong>symbole initial</strong> <code class="prettyprint lang-c">#</code>. </li>

  <div class="nobullet"> On parle de <strong class="specialLB">directives au préprocesseur</strong>, ces dernières permettant :  </div>
  <ul> 
    <li> d'<strong>inclure</strong> dans le fichier source le contenu d'<strong class="defin">autres fichiers</strong> ; c'est notamment ainsi que sont incorporés les fichiers d'en‑tête de bibliothèques ;  </li>

    <li> de <strong>définir</strong> des <strong class="defin">pseudo‑constantes</strong> qui ont la particularité, contrairement aux constantes usuelles, d'être <strong class="specialG">non typées</strong> ; </li>

    <li> de <strong>définir</strong> des <strong class="defin">pseudo‑fonctions</strong> qui ont la particularité, contrairement aux fonctions, de prendre des <strong>arguments</strong> <strong class="specialG">non typés</strong> ; </li>

    <li> de mettre en œuvre une <strong class="defin">compilation conditionnelle</strong> pour adapter le code source en fonction de valeurs prises par des <strong>variables d'environnement</strong>, et ainsi pouvoir porter le programme sur différentes machines ou systèmes. </li>
  </ul>
</ol>

<p class="square"> Constituant un véritable <strong class="defin">métalangage</strong>, les <strong class="title">directives</strong> au préprocesseur confèrent aux langages <strong>C</strong> et <strong>C++</strong> une <strong class="pros">puissance d'expression exceptionnelle</strong>. Néanmoins, il faut beaucoup d'expérience pour en maîtriser les subtilités. </p>

<p> En adoptant un plan similaire à celui de la liste ci‑dessus, ce <strong class="warning">très long chapitre</strong> a pour <strong class="title">objectif</strong> d'en exposer <strong>toutes les bases</strong>. Il doit permettre au codeur débutant de se familiariser suffisamment avec cette composante importante de la chaîne de compilation pour pouvoir comprendre son emploi très fréquent, en particulier dans les fichiers sources des modules de bibliothèque <strong class="Arduino">Arduino</strong>. De <strong class="pros">nombreux exemples</strong> dans ce cours sont tirés de ces fichiers. </p> 

<p> Et pour plus de détails, on pourra toujours consulter le <strong>guide en ligne</strong> fourni par le <strong>projet <em class="mark">GNU</em></strong> au lien suivant <a class="external" href="https://gcc.gnu.org/onlinedocs/cpp/index.html" target="_BLANK"></a>. </p>
</div><!-- exergue -->  </p>




















<h2> Prétraitements implicites du fichier source </h2>


<div class="expert">
<p> Les <strong class="title">prétraitements implicites</strong> opérés par le préprocesseur <strong>CPP</strong> correspondent selon la norme aux <strong class="defin">phases 1</strong> à <strong class="defin">6</strong> de traduction, à l'exception de tous ceux de la prise en compte des directives qui constituent des <strong>prétraitements explicites</strong>, regroupés dans la <strong>phase 4</strong>. </p>

<p> Ces phases se déroulent en principe dans l'ordre de leur numérotation, mais avec des phases de <strong class="defin">rétroaction</strong> lorsque la <strong>phase 4</strong> est abordée. </p>
</div><!-- expert -->



<h3> Invocation du préprocesseur </h3>



<div class="important">
<p> Un préprocesseur <strong class="title">CPP</strong> est <strong class="defin">intégré</strong> à toute chaîne de compilation <strong>GCC</strong> pour les langages <strong>C</strong> et <strong>C++</strong>. Implicitement, l'exécution d'une commande <code class="cmd">gcc</code> ou <code class="cmd">g++</code> commence l'invocation de ce préprocesseur pour traiter le ou les fichiers sources passés en argument. </p>

<p> On parle de <strong class="title">prétraitements</strong> (en anglais, <em class="english">preprocessing</em>) pour désigner le travail effectué sur le code source par un préprocesseur. </p>
</div><!-- important -->


<h4> Visualisation des prétraitements du préprocesseur </h4>


<div class="important">
<p> Si l'on souhaite <strong class="title">observer les prétraitements</strong> accomplis par le <strong class="title">préprocesseur seul</strong> – c'est‑à‑dire, sans aller plus loin dans la chaîne de compilation, et en obtenant comme sortie un <strong class="specialM">fichier de texte</strong> – il suffit de saisir une <strong>commande système</strong> de la forme : </p>
<div class="inline">
  <code class="displayDark"><span class="displayDarkGreen" >cpp</span> <span class="nocode"><strong class="specialG">fichier source</strong></span> <span class="displayDarkRed">-o</span> <span class="nocode"><strong class="specialSG">fichier prétraité</strong></span></code>
</div>
<p> sachant que si l'<strong>option</strong> <code class="cmd">-o</code> n'est <strong class="defin">pas invoquée</strong>, le fichier prétraité prend par défaut le <strong class="specialN">même nom</strong> que le fichier source, et l'<strong class="specialN">extension</strong> <code class="filename">.i</code></p>

<p> Dans la forme ci‑dessus, on peut aussi remplacer la <strong>commande</strong> <code class="cmd">cpp</code> par <code class="cmd">gcc <span class="red">-E</span></code> (ou <code class="cmd">g++</code> pour le <strong>C++</strong>) où l'<strong>option</strong> <code class="cmd"><span class="red">-E</span></code> a pour effet d'<strong class="defin">arrêter l'exécution de la commande juste après les prétraitements</strong> opérés par le préprocesseur (donc, sans compilation proprement dite). </p>
</div><!-- important -->

<div class="complement">
<p> Le <strong class="title">fichier prétraité</strong> produit en sortie par la commande <code class="cmd">cpp</code> est seulement une <strong class="defin">image textuelle</strong> du <strong>flot de tokens prétraités</strong>, c'est‑à‑dire une succession d'<strong>unités lexicales</strong> qui est en réalités fournies par le préprocesseur au compilateur. </p>

<p> Le contenu de ce fichier est consultable avec n'importe quel <strong>éditeur de code</strong> ou commande système de visualisation comme <code class="cmd">cat</code> ou <code class="cmd">more</code> sous <em class="mark">Linux</em>. Il s'apparente à du code <strong>C</strong> ou <strong>C++</strong> et son <strong>extension conventionnelle</strong> <code class="filename">.i</code> peut permettre facilement aux éditeurs de code de le reconnaître comme tel.  </p>
</div><!-- complement -->

<div id="premierExemple", class="exemples">
<p class="exemple"> À partir du <strong class="title">code source académique</strong> ci‑dessous, enregistré par exemple dans un fichier <code class="filename">simpleProg.c</code> :  </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
/* Useless but very simple program to test CPP */
char a = 5;

int main(void) {
  a++;
  // no output
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

<p> la <strong>commande</strong> <code class="displayDark"><span class="displayDarkGreen">cpp</span> simpleProg.c</code> produit en sortie le <strong class="specialSG">fichier prétraité</strong> <code class="filename">simpleProg.i</code> listé ci‑dessous : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
# 1 "oneVar.c"
# 1 "&lt;built-in&gt;"
# 1 "&lt;command-line&gt;"
# 31 "&lt;command-line&gt;"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 32 "&lt;command-line&gt;" 2
# 1 "oneVar.c"

char a = 5;

int main(void) {
 a++;

 return 0;
}
</pre>
<!---------- ne pas indenter ---------->

<p> On verra ci‑après en détails en quoi consistent les prétraitement accomplis par le préprocesseur. </p>
</div><!-- exemple -->


<div class="remarques">
<p class="remarque"> La commande <code class="cmd">cpp</code> (ou ses équivalents <code class="cmd">gcc <span style="color: #FF2020; font-weight: 600">-E</span></code> et <code class="cmd">g++ <span style="color: #FF2020; font-weight: 600">-E</span></code>) possède de <strong class="title">nombreuses options</strong>. On peut en trouver la <strong>liste exhaustive</strong> sur cette page web <a class="external" href="https://gcc.gnu.org/onlinedocs/cpp/Invocation.html" target="_BLANK"></a> du site de référence du <strong>projet <em class="mark">GNU</em></strong>. </p>
</div><!-- remarque -->



<h3> Prétraitements implicites opérés par le préprocesseur</h3>



<div class="important">
<p> Le travail du préprocesseur commence par des <strong class="title">prétraitements préliminaires</strong> sur le code source pour <strong class="pros">faciliter la compilation</strong> qui va suivre. Ces prétraitements peuvent être considérés comme <strong class="defin">implicites</strong> dans la mesure où ils sont effectués par défaut, même en l'absence de toute directive. </p>
</div><!-- important -->

<div class="expert"> 
<div class="complement">
<p> <strong class="title">Certaines options</strong> de la commande <code class="cmd">cpp</code> sont parfois <strong class="warning">indispensables</strong> pour obtenir un code exécutable satisfaisant, notamment si le <strong class="specialDG">fichier source</strong> n'est <strong class="cons">pas encodé en <em class="sigle">UTF‑8</em></strong>. </p>


<p> Quant aux <strong class="title">autres options</strong>, elles permettent de moduler les prétraitements opérés de façon <strong class="pros">très pertinente</strong> en fonction des spécificités du projet sur lequel on travaille. Dans tous les cas, on se situe déjà dans un <strong>usage avancé</strong> de la chaîne de compilation. </p>
</div><!-- complement -->

<p> Seuls les prétraitements les plus remarquables sont exposés par la suite. Pour une présentation exhaustive, on pourra consulter cette page web <a class="external" href="https://gcc.gnu.org/onlinedocs/cpp/Initial-processing.html" target="_BLANK"></a> du site de référence du <strong>projet <em class="mark">GNU</em></strong>. </p>


<!-- expert -->
<h4 id="cppTrancoding"> Transcodage du jeu de caractères du fichier source </h4>


<p> A priori, un <strong class="specialDG">fichier source</strong> en langage <strong>C</strong> (idem en <strong>C++</strong>) peut être encodé dans <strong>n'importe quel jeu de caractères</strong>, selon le paramétrage du poste de travail, de son système d'exploitation et de l'éditeur de code employé. On peut déterminer cet encodage : </p>
<ul>
  <li> soit par une <strong>commande système</strong> ; </li>

  <div class="nobullet"> par exemple, sous <strong class="specialLB">Linux</strong>, il suffit de saisir dans un terminal <code class="displayDark" style="padding-top: 0.1em; padding-bottom: 0.2em;"><span class="displayDarkGreen">file</span> <span class="nocode"><strong class="specialG">fichier source</strong></span></code> ; </div>
  
  
  <li> soit en consultant les propriétés du fichier dans un <strong>éditeur de code</strong> ; </li>

  <div class="nobullet" style="display: inline-block;">
    <img class="top-right" src="../img/SublimeText_encoding.png" width="500px">
  par exemple, avec <strong class="Sublime">Sublime Text</strong>, le format d'encodage du fichier s'affiche tout à droite dans la <strong>barre d'état</strong> (à condition d'avoir saisi le paramétrage <code>"show_encoding": "true"</code> dans le fichier <code class="filename">Settings</code> accessible via le menu <code>Preferences</code>). </li>
  </div><!-- display -->
</ul>


<p> Mais un compilateur n'est pas capable de s'adapter seul à toute la diversité des jeux de caractères. Conformément à la norme <em class="sigle">ISO 10046</em> du langage <strong>C</strong>, les algorithmes des compilateurs <strong class="title">GCC</strong> sont conçus pour traiter des fichiers encodés en <strong class="defin"><em class="sigle">UTF‑8</em></strong> (cf. chap. C3‑VIII <a class="previous" href="../C3-Numeration/Cc3-9_typesCaracteresEtendus.html#formatUTF-8" target="_BLANK"></a>). </p>

<div class="complement">
<p> Aussi, avant même tout prétraitement, le préprocesseur <strong>CPP</strong> du <strong>projet <em class="mark">GNU</em></strong> opère le <strong class="title">transcodage</strong> dans le <strong>format <em class="sigle">UTF‑8</em></strong> des fichiers sources passés en arguments de la commande <code>gcc</code> ou <code>g++</code>. Toutefois, il est nécessaire pour cela d'<strong class="warning">indiquer précisément</strong> le <strong>format d'encodage</strong> de ces fichiers source, à l'aide de l'<strong class="defin">option</strong> <code class="displayDarkRed">-finput-charset=<span class="nocode"><em style="color: yellow;">source_format</em></span></code>. </p>
</div><!-- complement -->

<p> Selon la norme, ce travail de transcodage constitue la <strong>phase 1</strong> de traduction du code source en code exécutable. </p>


<div class="exemples">
<p class="exemple"> Prenons le cas académique d'une <strong class="title">instruction de sortie standard</strong> comme celle ci‑dessous, dont la chaîne de format contient des <strong class="specialO">caractères accentués</strong>.  </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:5">
  printf("Connecté au réseau.\n");
</pre>
<!---------- ne pas indenter ---------->

<p> Typiquement, si le <strong class="specialDG">fichier source</strong> est codé sur un PC <em class="mark">Windows</em> dans le format <strong><em class="sigle">ISO-8859‑1</em></strong> dit <em class="mark">Latin‑1</em>  ou le format <strong><em class="sigle">CP1252</em></strong> (cf. chap. C3‑VIII <a class="previous" href="../C3-Numeration/Cc3-8_typesCaracteres.html#ASCIIfrancais" target="_BLANK"></a>) puis compilé sur un PC <em class="mark">Linux</em> avec la commande <code class="cmd">gcc</code> <strong class="warning">sans option</strong>, on obtient à l'exécution en sortie standard : </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Connect� au r�seau.
</pre>
<!---------- ne pas indenter ---------->

<p> Mais si ce même <strong class="specialDG">fichier source</strong> est compilé avec l'<strong class="defin">option</strong> <code class="cmd"><span class="red">-finput-charset</span>=ISO8895-1</code> ou <code class="cmd"><span class="red">-finput-charset</span>=Windows-1252</code>, on obtient une <strong class="pros">sortie correcte</strong> des caractères accentués : </p> 

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Connecté au réseau.
</pre>
<!---------- ne pas indenter ---------->

<p style="margin-top: 1em"> <em class="remark">Remarque</em>. Le <strong class="title">transcodage du jeu de caractères</strong> du <strong class="specialDR">fichier source</strong> peut également être opéré avec l'<strong>éditeur de code</strong>, avant tout appel de la chaîne de compilation. </p>

<div style="display: inline-block;">
  <img class="top-right" src="../img/SublimeText_encodingMenu.png" width="300px">
<p> Par exemple, avec <strong class="Sublime">Sublime Text</strong>, il suffit de cliquer sur l'indication de format dans la <strong>barre d'état</strong> et de sélectionner le format <strong><em class="sigle">UTF‑8</em></strong> via le menu déroulant. Le fichier source étant ainsi préalablement transcodé, le préprocesseur se trouve déchargé de cette tâche. </p>
</div><!-- display -->

</div><!-- exemple -->


<!-- expert -->
<h4> Transcodage (inverse) du jeu de caractères pour l'environnement d'exécution </h4>



<div class="complement">
<p> Après tous les prétraitements qu'il opère (y compris ceux des directives), le préprocesseur <strong>CPP</strong> peut à nouveau <strong class="title">transcoder les constantes</strong> de type <strong>caractère</strong> et <strong>chaîne de caractères</strong>, dans un <strong class="defin">autre format</strong> que <strong><em class="sigle">UTF‑8</em></strong>, afin qu'il corresponde à celui de l'<strong class="defin">environnement d'exécution</strong> du programme.  </p>

<p> Pour cela, il suffit d'employer l'<strong class="defin">option</strong> <code class="cmd"><span class="red">-fexec-charset</span>=<span class="nocode"><strong class="specialY">output format</strong></span></code>. </p>
</div><!-- complement -->

<p> Selon la norme, ce travail constitue la <strong>phase 5</strong> de traduction du code source en code exécutable. </p>

<div class="exemples">
<p class="exemple"> Si un <strong class="title">programme</strong> est <strong class="specialLB">compilé sous Linux</strong> mais destiné à être <strong class="specialLB">exécuté sous Windows</strong> – on parle alors de <strong>compilation croisée</strong> (cf. chap. C4‑IV <a class="next" href="Cc4-4_chaineCompilation.html#compilNativeCroisee" target="_BLANK"></a>) – on peut saisir l'option <code class="cmd"><span class="red">-fexec-charset</span>=windows-1252</code>, en veillant à ce que cette page de code soit bien activée dans la fenêtre de terminal d'exécution (cf. chap. C3‑VIII <a class="previous" href="../C3-Numeration/Cc3-8_typesCaracteres.html#windowsCP" target="_BLANK"></a>). </p>
</div><!-- exemples -->
</div><!-- expert -->


<h4 id="antislash"> Suppression des sauts de ligne « fictifs » </h4>


<p> En programmation, un <strong class="specialDG">fichier source</strong> est constitué de <strong class="title">lignes</strong> séparées les unes des autres par un caractère <strong><em class="sigle">LF</em></strong> ou <strong><em class="sigle">CR</em></strong> (voire une séquence de caractères <strong><em class="sigle">CR LF</em></strong>) de <strong class="defin">fin de ligne</strong> (cf. chap. C2‑II <a class="previous" href="../C2-ElementsLangage/Cc2-2_syntaxeFondamentale.html#separateursBlancs" target="_BLANK"></a>). </p>

<div class="complement">
<p> Mais on a vu également qu'en langages <strong>C</strong> et <strong>C++</strong>, il est possible de coder, à destination du préprocesseur, la <strong>suppression d'un saut de ligne</strong> en faisant précéder ce dernier par le symbole <code class="prettyprint lang-c">\</code> (cf. chap. C2‑II <a class="previous" href="../C2-ElementsLangage/Cc2-2_syntaxeFondamentale.html#separateursBlancs" target="_BLANK"></a>).  </p>
</div><!-- complement --> 


<div class="important">
<p> On dit d'un <strong class="title">saut de ligne</strong> ainsi codé qu'il est « <strong class="title">fictif</strong> ». </p>

<p> Dans un tel cas, le préprocesseur <strong>CPP</strong> <strong class="defin">ignore</strong> tout simplement le symbole <code class="prettyprint lang-c">\</code> et le caractère (ou à la séquence de caractères) de <strong class="defin">fin de ligne</strong> <strong>immédiatement consécutif</strong> et continue son travail sur la suite du fichier source. </p>
</div><!-- important -->

<div class="expert">
<p> Selon la norme, ce travail constitue la <strong>phase 2</strong> de traduction du code source en code exécutable. </p>
</div><!-- expert -->


<h4> Suppression des commentaires </h4>


<p> Rappelons qu'en programmation, les <strong class="title">commentaires</strong> ne constituent <strong class="defin">pas du code</strong> à proprement parler (cf. chap. C2‑II <a class="previous" href="../C2-ElementsLangage/Cc2-2_syntaxeFondamentale.html#commentaires" target="_BLANK"></a>) et doivent donc être ignorés par le compilateur. </p>

<div class="important">
<p> Pour alléger d'autant la mémoire sur laquelle la chaîne de compilation opère (car un fichier source peut être très volumineux), il est pertinent de <strong class="title">supprimer</strong> <strong class="pros">au plus tôt</strong> les commentaires. C'est donc le préprocesseur qui s'en charge : dans son travail, il les <strong class="defin">ignore</strong> tout simplement. </p>

<p> Avec le <strong>CPP</strong> du <strong>projet <em class="mark">GNU</em></strong>, cette suppression ne fait l'objet d'<strong>aucune substitution</strong> sauf éventuellement – si nécessaire – par un caractère <strong>espace</strong>. </p>
</div><!-- important -->


<div class="expert">
<p> Selon la norme, la suppression des commentaire est incluse dans la <strong>phase 3</strong> de traduction du code source en code exécutable. </p>
</div><!-- expert -->  


<div class="exemples">
<p class="exemple"> Dans le premier exemple supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#premierExemple"></a>, les deux <strong class="title">commentaires</strong> présents dans le <strong class="specialDG">fichier source</strong> (en lignes nº 1 & 6) sont <strong>absents</strong> dans le <strong class="specialSG">fichier prétraité</strong> là où ils « auraient dû » être (en principe, aux lignes nº 8 & 13). </p>

<div style="display: inline-flex; margin‑left: 0.5em">
  <div style="width: 80%; margin-right: 1em">
<!---------- ne pas indenter ---------->

<pre class="prettyprint lang-c linenums:1">
/* Useless but... */
char a = 5;

int main(void) {
  a++;
  // no output
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

  </div><!-- pre -->

  <div style="width: 80%; margin-right: 0.5em">

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:8">

char a = 5;

int main(void) {
 a++;

 return 0;
}
</pre>
<!---------- ne pas indenter ---------->

</div><!-- pre -->
</div><!-- display -->


<p> Toutefois, les <strong class="title">sauts de lignes</strong> ne faisant pas partie des commentaires, ils sont <strong>maintenus</strong>. Avec un éditeur de code qui affiche les caractères d'espacement, on peut constater que les lignes nº 8 & 13 correspondantes sont complètement vides. </p>

<p> <em class="remark">Remarque</em>. L'éditeur de code <strong class="Sublime">Sublime Text</strong> affiche les <strong>caractères d'espacement</strong> dans une portion de code sélectionnée (en surbrillance) si le <strong>paramétrage</strong> <code>"draw_white_space": "selection"</code> est codé dans le fichier <code class="filename">Settings</code>, lequel est accessible via le menu <code>Preferences</code>. </p>
</div><!-- exemple -->


<div class="expert">
<div class="complement">
<p> Il est néanmoins possible de <strong class="title">garder les commentaires</strong> dans le <strong class="specialSG">fichier prétraité</strong> généré par la commande <code class="cmd">cpp</code> : il suffit d'employer l'<strong class="defin">option</strong> <code class="cmd"><span class="red">-C</span></code>.   </p>
</div><!-- complement -->


<!-- expert -->
<h4 id="tokenisation"> Tokénisation </h4>


<div class="complement">
<p> Le préprocesseur <strong>CPP</strong> est également chargé de transformer le texte du code source en un <strong class="title">flux de tokens</strong> de prétraitement (<em class="english">preprocessing tokens</em>), à destination du compilateur. Le terme <strong>token</strong> est un anglicisme qu'on pourrait traduire littéralement par « jeton » et qui désigne une <strong class="defin">unité lexicale</strong> sur laquelle le compilateur va pouvoir aisément travailler. Sans entrer dans les détails, les tokens sont distingués de <strong class="defin">cinq catégories</strong> possibles : </p>

<ul>
  <li> <strong>identificateurs</strong>, y compris les mots‑clefs ;  </li>

  <li> <strong>nombres</strong>, sans distinction de types (cette tâche est dévolue au compilateur lui‑même), </li>

  <li> <strong>caractère</strong> isolés et <strong>chaînes de caractères</strong>, </li>

  <li> <strong>ponctuateurs</strong> (délimiteurs, opérateurs, etc.), </li>

   <li> <strong>autres</strong>, sachant que la présence d'un seul token de cette catégorie déclenche une erreur (autrement dit, tous les tokens doivent être normalement de l'une des quatre catégories précédentes). </li> 
</ul>
</div><!-- complement -->


<p> Selon la norme, cette tokénisation est incluse dans la <strong>phase 3</strong> de traduction du code source en code exécutable. Elle n'est <strong class="cons">pas visualisable</strong> dans le <strong class="specialSG">fichier prétraité</strong> de la commande <code class="cmd">cpp</code>. </p>


<!-- expert -->
<h4> Uniformisation des caractères d'espacement </h4>


<p> Rappelons que les langages <strong>C</strong> et <strong>C++</strong> sont dits <strong class="defin">à format libre</strong> (cf. chap. C2‑II <a class="previous" href="../C2-ElementsLangage/Cc2-2_syntaxeFondamentale.html#formatLibre" target="_BLANK"></a>), au sens où on peut ajouter autant de <strong class="title">caractères d'espacement</strong> que l'on souhaite entre les différents éléments de langage d'un programme source – ces caractères d'espacement étant dans la pratique des <strong>espaces</strong> (code <em class="sigle">UTF‑8</em> <code>0x20</code>) ou des <strong>sauts de tabulation</strong> (code <em class="sigle">UTF‑8</em> <code>0x09</code>). </p>

<div class="complement">
<p> Au cours de la tokénisation, le préprocesseur <strong>CPP</strong> fait en sorte que deux tokens successifs soient séparés par <strong class="title">un seul caractère espace</strong>. Ce faisant, il <strong class="warning">supprime</strong> donc : </p>
<ul>
  <li> tous les caractères de <strong>tabulation</strong>, </li>

  <li> et tous les caractères <strong>espaces surnuméraires</strong>. </li>
</ul>
<p> Mais ce travail – encore en <strong>phase 3</strong> de traduction du code source en code exécutable – n'est <strong>pas obligatoire</strong> selon la norme (il est laissé à la liberté de l'implémentation, et les concepteurs de <em>CPP</em> ont fait le choix de le mettre en œuvre). </p>
</div><!-- complement -->

<p> <em class="remark">Attention</em>, dans le <strong class="specialSG">fichier prétraité</strong> de la commande <code class="cmd">cpp</code>, les caractères d'espacement surnuméraires ne sont <strong class="warning">pas forcément supprimés</strong>, le but étant que le code traité soit présenté de façon similaire à celle du fichier source pour faciliter sa lecture par le codeur. </p>


<div class="exemples">
<p class="exemple"> Dans le premier exemple supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#premierExemple"></a>, on peut voir que les <strong class="title">tabulations</strong> d'indentation – d'une valeur de 2 espaces – présentes dans le <strong class="specialDG">fichier source</strong> au début des lignes nº 5 & 7 ont été <strong>remplacées</strong> dans le <strong class="specialSG">ficher prétraité</strong> par de <strong>simples espaces</strong> au début des lignes nº 12 & 14. </p>

<div style="display: inline-flex; margin‑left: 0.5em">
  <div style="width: 80%; margin-right: 1em">

<!---------- ne pas indenter ---------->

<pre class="prettyprint lang-c linenums:4">
int main(void) {
  a++;
  // no output
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

  </div><!-- pre -->

  <div style="width: 80%; margin-right: 0.5em">

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:11">
int main(void) {
 a++;

 return 0;
}
</pre>
<!---------- ne pas indenter ---------->

  </div><!-- pre -->
</div><!-- display -->

</div><!-- exemple -->
</div><!-- expert -->


<h4 id="marquesLignes"> Marques de lignes </h4>


<div class="important">
<p> Pour localiser de potentielles erreurs détectées par la chaîne de compilation, le préprocesseur <strong>CPP</strong> ajoute des <strong class="title">marques de lignes</strong> (en anglais, <em class="english">line‑markers</em>) des <strong>fichiers sources</strong> parcourus au fur et à mesure des prétraitements. Ces marques de lignes ne sont pas des tokens, elles sont ignorées par les algorithmes du compilateur lors du traitement du code source. Mais elles apparaissent dans le <strong class="specialSG">fichier prétraité</strong> de la commande <code class="cmd">cpp</code>. </p>

<p> Lorsqu'une <strong class="warning">erreur</strong> est détectée, le <strong class="specialDG">fichier source</strong> dans laquelle elle se trouve est identifié par la <strong>marque de ligne</strong> <strong class="defin">immédiatement en amont</strong>. </p>
</div><!-- important -->

<div class="expert">
<div class="complement">
<p> Une <strong class="title">marque de ligne</strong> se présente de la forme : <br>
<span class="inline">
  <code class="prettyprint lang-c"># <span class="nocode"><strong class="specialLGr">numéro de ligne</strong></span> <span class="nocode"><strong class="specialDGr">fichier</strong></span> <span class="nocode"><strong class="specialLGr">drapeaux</strong></span></code>
</span> <br> 
sachant que les <strong class="specialLGr">drapeaux</strong> sont <strong class="defin">facultatifs</strong> et qu'ils ne sont que des <strong>chiffres</strong> parmi les suivants :   </p>
<ul>
  <li> <code class="cmd" style="color: darkgrey">1</code> qui indique le <strong>début d'un nouveau fichier</strong> ;  </li>

  <li> <code class="cmd" style="color: darkgrey">2</code> qui indique le <strong>retour dans un fichier</strong> (typiquement après une inclusion) ;  </li>

  <li> <code class="cmd" style="color: darkgrey">3</code> qui indique que le code à suivre provient d'un <strong>fichier d'en‑tête</strong> et que certains avertissements de la chaîne de compilation seront inhibés ; </li>

  <li> <code class="cmd" style="color: darkgrey">4</code> qui indique que le code à suivre doit être considéré comme un <strong>bloc externe</strong> en langage <strong>C</strong>. </li>
</ul>
</div><!-- complement -->

<div class="remarques">
<p class="remarque"> L'<strong class="title">ajout de marques de lignes</strong> n'est <strong>pas mentionné dans la norme</strong>. Il est donc difficile de savoir dans quelle phase ce travail s'inscrit. On pourrait même supposer qu'il intervient avant même la phase 1 de traduction du code source en code exécutable.  </p>  
</div><!-- remarque -->

<div class="exemples" id="exempleMarquesLignes">
<p class="exemple"> Dans le premier exemple supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#premierExemple"></a>, <strong class="title">sept marques de lignes</strong> apparaissent au début du <strong class="specialSG">fichier prétraité</strong> obtenu par appel de la commande <code class="cmd">cpp</code> (on les retrouve en principe pour tous les programmes) :  </p>


<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
# 1 "oneVar.c"
# 1 "&lt;built-in&gt;"
# 1 "&lt;command-line&gt;"
# 31 "&lt;command-line&gt;"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 32 "&lt;command-line&gt;" 2
# 1 "oneVar.c"
</pre>
<!---------- ne pas indenter ---------->

<p> On peut ainsi <strong class="defin">retracer certains prétraitements</strong> « cachés » de la chaîne de compilation : </p>

<ul>
  <li> <code class="prettyprint lang-c"># 1 "oneVar.c"</code> signale que le préprocesseur commence son travail à la ligne nº 1 du fichier <code class="filename">oneVar.c</code>, qui est ici le seul <strong class="specialDG">fichier source</strong>. Cette indication sert surtout à préciser le nom du fichier source, car son prétraitement effectif est immédiatement différé par ce qui suit. </li>

  <li> <code class="prettyprint lang-c"># 1 "&lt;built-in&gt;"</code> signale que le préprocesseur commence (à partir de la ligne nº 1) le prétraitement du <strong>fichier virtuel</strong> <code>built-in</code> où sont codées des directives qui prédéfinissent des <strong>pseudo‑constantes</strong> des langages <em class="mark">C/C++</em> permettant d'obtenir la valeur de nombreuses variables d'environnement (cf. infra <a class="infra" href="http://www.lycee-ferry-versailles.fr/snir/ModuleC/C4-Fonctions/pseudoConstPredef"></a>).  </li>

  <li> <code class="prettyprint lang-c"># 1 "&lt;commande-line&gt;"</code> signale que le préprocesseur commence (à partir de la ligne nº 1) le prétraitement du <strong>fichier virtuel</strong> <code>command-line</code> où sont codées des directives qui prédéfinissent des <strong>pseudo‑constantes</strong> qui sont spécifiques à la <strong>ligne de commande</strong> (en fonction des options de compilation choisies ou par défaut) ainsi qu'au terminal d'exécution.   </li>

  <li> <code class="prettyprint lang-c"># 31 "&lt;commande-line&gt;"</code> signale que le préprocesseur effectue un prétraitement particulier à la ligne nº 31 du fichier virtuel <code>command-line</code>. L'explication est donnée à la marque de ligne suivante. </li>

  <li> <code class="prettyprint lang-c"># 1 "/usr/include/stdc-predef.h" 1 3 4</code> signale que le préprocesseur commence (à partir de la ligne nº 1) le prétraitement d'un <strong>nouveau fichier</strong> – d'où le drapeau <code class="cmd" style="color: darkgrey">1</code> – dont le chemin d'accès est <code class="filename">/usr/include/stdc-predef.h</code>. On verra qu'il s'agit en fait d'une <strong>directive d'inclusion</strong>. On a également le drapeau <code class="cmd" style="color: darkgrey">3</code> puisqu'il s'agit d'un fichier d'en‑tête et le drapeau <code class="cmd" style="color: darkgrey">4</code> puisque ce fichier contient du code en langage <em class="mark">C</em>.  </li>

  <li> <code class="prettyprint lang-c"># 32 "&lt;commande-line&gt;"</code> signale que le préprocesseur reprend à la ligne nº 32 le prétraitement du fichier virtuel <code>command-line</code>. Le drapeau <code class="cmd" style="color: darkgrey">2</code> indique qu'il s'agit d'un <strong>retour</strong> (après la prise en compte de la directive d'inclusion du fichier <code class="filename">stdc-predef.h</code> qui vient d'avoir lieu).  </li>

  <li> <code class="prettyprint lang-c"># 1 "oneVar.c"</code> signale que le préprocesseur commence (cette fois pour de bon) à la ligne nº 1 le prétraitement du fichier source <code class="filename">oneVar.c</code>. </li>

  <div class="nobullet"> Comme il n'y a <strong>pas de directives d'inclusion</strong> codées dans ce fichier, il n'y a <strong>pas d'autres marques de lignes</strong> qui suivent dans le <strong class="specialSG">fichier prétraité</strong> généré par la commande <code class="cmd">cpp</code>. </div>
</ul>
</div><!-- exemple -->
</div><!-- expert -->





















<h2> Syntaxe générale des directives au préprocesseur </h2>



<p> Ainsi qu'il a été énoncé en introduction de ce chapitre, les <strong class="title">directives</strong> au préprocesseur <strong>CPP</strong> constituent un <strong class="defin">métalangage</strong> qui est <strong>distinct</strong> du langage <strong>C</strong> ou <strong>C++</strong> employé pour coder les instructions du programme. Néanmoins, il est commode de considérer parfois que ces directives font « partie » de ces deux langages, tant elles sont indispensables. </p>

<p> Après avoir effectué la plupart des prétraitements implicites décrits supra, le <strong class="title">préprocesseur</strong> traite les directives <strong>une par une</strong> au fur et à mesure de leur présence dans le code, et ce jusqu'à ce qu'il n'y en ait plus aucune. </p>

<div class="expert">
<p> La norme considère ces prétraitements comme la <strong>phase 4</strong> de la traduction du code source en code exécutable. Les débutants ont tendance à croire que c'est là que commence véritablement le travail du compilateur (mais on a vu qu'il ne faut pas négliger tous les prétraitements implicites qui les précèdent). </p>
</div><!-- expert -->



<h3> Lignes de contrôles  </h3>



<h4> Isolement et symbole initial </h4>


<div class="important">
<p> En langages <strong>C</strong> et <strong>C++</strong>, toute <strong class="specialLB">directive</strong> au préprocesseur est codée par une ou plusieurs <strong class="title">lignes de contrôles</strong> dont chacune : </p> 

<ul>
	<li> s'inscrit nécessairement <strong class="defin">seule dans une ligne</strong> de fichier source, c'est‑à‑dire <strong class="warning">sans aucune instruction</strong> dans cette même ligne ; </li>

	<li> débute toujours (avec une éventuelle indentation) par le <strong class="defin">symbole</strong> <code class="prettyprint lang-c">#</code>, dit <strong>croisillon</strong> <a class="external" href="https://fr.wikipedia.org/wiki/Croisillon_(signe)" target="_BLANK">W</a>, dont le rôle est d'indiquer sans ambiguïté que cette ligne est du ressort du préprocesseur.  </li>
</ul>
</div><!-- important -->

<div class="complement">
<p> Après traitement des directives par le préprocesseur, toutes les <strong class="title">lignes de contrôle</strong> sont en quelque sorte « <strong class="defin">supprimées</strong> » du <strong class="specialDG">code source</strong>. En fait, elles n'ont tout simplement pas leur place dans le flot de tokens que le préprocesseur transmet au compilateur. Et bien évidemment, elles n'apparaissent pas dans le <strong class="specialSG">fichier prétraité</strong> généré par la commande <code class="cmd">cpp</code> . </p>
</div><!-- complement -->

<div class="exemples">
<p class="exemple"> La <strong>directive d'inclusion</strong> ci‑dessous est constitué d'<strong class="defin">une seule</strong> <strong class="title">ligne de contrôle</strong> : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;
</pre>
<!---------- ne pas indenter ---------->

<p> Dans le <strong class="specialSG">fichier prétraité</strong>, cette ligne n'existe plus, et pour cause : elle est <strong>remplacée par l'intégralité du contenu</strong> du fichier d'en‑tête <code class="filename">stdio.h</code> de la bibliothèque standard du langage <em class="mark">C</em> (cf. infra <a class="infra" href="Cc4-3_directivesPreprocesseur.html#include"></a> pour plus de détails). </p>
</div><!-- exemple -->

<div class="remarques"><p class="remarques"></p>

<ol class="littered">
  <li>  Le symbole <strong class="title">croisillon</strong> <a class="external" href="https://fr.wikipedia.org/wiki/Croisillon_(signe)" target="_BLANK">W</a> (en anglais <em class="english">hash</em>, d'où le terme <em class="mark">hashtag</em>) ne doit <strong class="cons">pas être confondu</strong> avec le symbole musical <strong>dièse</strong> ♯ (en anglais <em class="english">sharp</em>) – et ce même si le croisillon est abusivement utilisé pour désigner le langage « <em class="mark">C‑sharp</em> ». </li>

  <li>  Les <strong class="title">lignes de contrôle</strong> ne doivent bien évidemment <strong class="warning">pas être confondues</strong> avec les <strong>marques de lignes</strong> générées par le préprocesseur (cf. supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#marquesLignes"></a>). Même si elles commencent aussi par un croisillon, ces dernières n'ont <strong>pas du tout le même rôle</strong>. </li>
</ol>
</div><!-- remarques -->


<h4> Mot réservé d'une ligne de contrôle </h4>


<div class="important">
<p> Dans toute <strong class="specialLB">ligne de contrôle</strong> d'une directive figure un <strong class="title">mot réservé</strong> qui précise <strong class="defin">quel contrôle</strong> exerce la ligne sur le code : <code class="prettyprint lang-c">include</code>, <code class="prettyprint lang-c">define</code>, <code class="prettyprint lang-c">undef</code>, <code class="prettyprint lang-c">ifdef</code>, <code class="prettyprint lang-c">ifndef</code>, etc. </p>
</div><!-- important -->

<div class="complement">
<p> Un <strong class="title">mot réservé</strong> désignant une <strong>ligne de contrôle</strong> n'est <strong class="warning">pas un mot‑clef</strong> du langage. S'il y a homonymie, il ne faut pas confondre. </p>
</div><!-- complement -->

<div class="exemples">
<p class="exemple"> Une <strong class="title">ligne de contrôle</strong> de <strong>compilation conditionnelle</strong> <code class="prettyprint lang-c">#if <span class="nocode">…</span></code> ne doit <strong class="warning">pas être confondue</strong> avec une <strong>structure de contrôle</strong> de bifurcation <code class="prettyprint lang-c">if (<span class="nocode"><strong style="color: green">condition</strong></span>)</code> (cf. chap. C2‑V <a class="previous" href="../C2-ElementsLangage/Cc2-5_structuresControle.html#testIf" target="_BLANK"></a>). </p>
</div><!-- exemple -->



<h4 id="terminaisonLigne"> Terminaison d'une ligne de contrôle </h4>



<div class="important">
<p> Par défaut, toute <strong class="specialLB">ligne de contrôle</strong> d'une directive doit se terminer à la <strong>fin de la ligne</strong> <strong class="warning">sans délimiteur</strong> <code class="prettyprint lang-c" style="background: lightgrey;">;</code>. </p>

<p> C'est le <strong>caractère de contrôle</strong> de <strong class="title">saut de ligne</strong>, le plus souvent invisible dans le fichier, typiquement <strong><em class="sigle">CR</em></strong> (<em class="english">carriage return</em>) ou <strong><em class="sigle">LF</em></strong>  (<em class="english">line feed</em>) ou les deux <a class="external" href="https://fr.wikipedia.org/wiki/Carriage_Return_Line_Feed" target="_BLANK">W</a> – cf. chap. C2-II <a class="previous" href="../C2-ElementsLangage/Cc2-2_syntaxeFondamentale.html#separateursBlancs" target="_BLANK"></a>) qui code implicitement la fin de la ligne de contrôle. </p>
</div><!-- important -->

<div class="exemples">
<p class="exemple"> La <strong>directive de définition</strong> ci‑dessous est constituée d'<strong class="defin">une seule</strong> <strong class="title">ligne de contrôle</strong> : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#define LED_PIN 2
</pre>
<!---------- ne pas indenter ---------->

<p> Comme énoncé dans la règle ci‑dessus, elle s'achève <strong>sans</strong> le délimiteur d'instruction <code class="prettyprint lang-c">;</code> puisqu'il ne s'agit <strong class="warning">pas</strong> d'une <strong>instruction</strong>. </p>

<p style="margin-top: 1em"> <em class="remark">Remarque</em>. On peut également observer l'<strong class="warning">absence</strong> de l'<strong>opérateur d'affectation</strong>, même si cette directive « donne » à la pseudo‑constante <code class="prettyprint lang-c">LED_PIN</code> la valeur <code class="prettyprint lang-c">2</code>. </p>
</div><!-- exemple -->


<div class="complement">
<p> Comme on l'a vu supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#antislash"></a>, une <strong class="specialLB">ligne de contrôle</strong> peut néanmoins être <strong class="title">prolongée</strong> à la <strong>ligne suivante</strong> si le symbole <strong>contre‑oblique</strong> <code class="prettyprint lang-c">\</code> (en anglais, <em class="english">antislash</em> ou <em class="english">backslash</em>) de <strong class="specialO">suppression de saut de ligne</strong> est ajouté <strong class="warning">juste avant le saut de ligne</strong> (aucun caractère, même de commentaire, ne doit être placé entre un symbole <code class="prettyprint lang-c">\</code> et le saut de ligne dont ce  symbole code la suppression). </p>

<p> Autant de suppression de sauts de lignes consécutifs que nécessaires peuvent être employés pour coder des directives complexes (notamment des macro‑définitions de pseudo‑fonctions).  </p>
</div><!-- complement -->


<div class="exemples">
<p class="exemple"> La <strong>directive de définition</strong> ci‑dessous (qui sera expliquée en détail plus loin <a class="infra" href="Cc4-3_directivesPreprocesseur.html#macroPlusieursLignes"></a>) est constituée d'<strong class="warning">une seule</strong> <strong class="title">ligne de contrôle</strong> :  </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#define swapValues(a, b) { \
  double c = a; \
  a = b; \
  b = c; \
}
</pre>
<!---------- ne pas indenter ---------->

<p> mais elle est répartie sur <strong>5 lignes du fichier source</strong> grâce à <strong>4 symboles de suppression</strong> de saut de ligne employés en fin des lignes nº 1, 2, 3 & 4. </p>


<p style="margin-top: 1em"> <em class="remark">Remarque</em>. Cette directive aurait aussi pu être codée de façon <strong class="cons">moins lisible</strong> sur une seule ligne du fichier source : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#define swapValues(a, b) {double c = a; a = b; b = c;}
</pre>
<!---------- ne pas indenter ---------->

<p> C'est d'ailleurs ainsi que la précédente forme codée sur 5 lignes serait d'abord transformée après les prétraitements implicites du préprocesseur. </p>

</div><!-- exemples -->


<h4 id="contraintesFormat"> Séparateurs « blancs » et commentaires </h4>


<p> On rappelle (cf. chap. C2‑II <a class="previous" href="../C2-ElementsLangage/Cc2-2_syntaxeFondamentale.html" target="_BLANK"></a>) que les langages <strong>C</strong> et <strong>C++</strong> sont à <strong class="pros">format libre</strong>, c'est‑à‑dire qu'ils autorisent l'insertion de <strong>séparateurs blancs</strong> et de <strong>commentaires</strong> partout dans les instructions (mais pas au sein des atomes, bien entendu), sachant que les <strong class="specialLB">séparateurs « blancs »</strong> sont usuellement les caractères <strong>espaces</strong>, <strong>saut de tabulations</strong> horizontale et <strong>saut de ligne</strong>. </p>


<div class="complement">
<p> Dans les <strong>lignes de contrôle</strong> des directives, ces <strong class="title">règles de format libre</strong> sont <strong class="specialO">presque</strong> les mêmes :  </p>
<ul>
	<li> les caractères <strong class="specialLB">espaces</strong> et <strong class="specialLB">saut de tabulation</strong> sont <strong>insérables</strong> en quantités illimitées, sauf bien sûr dans les atomes (mots réservés, identificateurs) ; </li>
  
  <div class="expert">
  <div class="nobullet"> et on a vu supra qu'ils sont <strong>uniformisés</strong> en <strong>espaces</strong> et laissés uniquement pour séparer les tokens ; </div>
  </div><!-- expert -->

	<li> en revanche, les <strong class="specialLB">sauts de lignes</strong> sont <strong class="warning">à éviter</strong> dans la mesure du possible ;  </li>
  
  <div class="expert">
  <div class="nobullet"> on vient de voir que s'il faut insérer un saut de ligne, il doit être précédé par le symbole <code class="prettyprint lang-c">\</code> pour être supprimés par le préprocesseur comme indiqué supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#terminaisonLigne"></a> ;  </div>
  </div><!-- expert -->
</ul>
<p> et il en va de même pour les <strong class="specialLB">commentaires</strong> qui sont, rappelons‑le, insérables partout où un espace est autorisé (cf. chap. C2‑II <a class="previous" href="../C2-ElementsLangage/Cc2-2_syntaxeFondamentale.html#commentaires" target="_BLANK"></a>), mais qu'il est préférable de <strong class="pros">cantonner aux fins de ligne</strong>. </p>
</div><!-- complement -->

<div class="exemples">
<p class="exemple"> La <strong>directive de définition </strong>: </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#define LED_PIN 2
</pre>
<!---------- ne pas indenter ---------->

<p> aurait pu être <strong class="cons">truffée d'espaces et de commentaires</strong> par un esprit « fantasque » : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
	#   define /*this is a directive*/ LED_PIN        2
</pre>
<!---------- ne pas indenter ---------->

<p> Mais, évidemment, en termes de lisibilité, l'indentation initiale et le commentaire en plein milieu sont l'un et l'autre <strong class="cons">à éviter</strong>, à moins que la ligne de contrôle soit complexe et nécessite des explications localement détaillées. </p>

<p> La <strong class="pros">bonne pratique</strong> consiste évidemment à privilégier le <strong>commentaire de fin de ligne</strong>, comme ci‑dessous : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#define LED_PIN 2 // this is a directive
</pre>
<!---------- ne pas indenter ---------->

<p> de la même manière usuelle que pour les instructions. </p>
</div><!-- exemple -->

<div class="remarques">
<p class="remarque"> À la <strong class="title">fin</strong> d'une <strong>ligne de contrôle</strong>, il est <strong class="warning">impossible</strong> de placer un symbole de suppression de saut de ligne <code class="prettyprint lang-c">\</code> <strong class="warning">après</strong> un <strong>commentaire de fin de ligne</strong>. En effet, ce symbole ne serait pas reconnu comme voulu mais comme un commentaire, et par conséquent ignoré par le préprocesseur. </p>

<p> Pour <strong class="title">commenter une ligne de contrôle</strong> formatée <strong>sur plusieurs lignes</strong> du fichier source, il est donc <strong class="defin">nécessaire</strong> d'avoir recours aux délimiteurs de <strong>blocs de commentaires</strong> <code class="prettyprint lang-c">/* */</code>. </p>
</div><!-- remarque -->



<h3> Position et effet des directives dans le code </h3>



<div class="important">
<p> En principe, une <strong class="title">directive</strong> peut être codée <strong class="pros">partout</strong> dans un <strong class="specialDG">fichier source</strong>, y compris dans une <strong>fonction</strong> ou un <strong>bloc</strong>, quel que soit son niveau hiérarchique dans le fichier (cf. chap. C4‑II <a class="previous" href="Cc4-2_porteeDonnees.html#niveauDonnee" target="_BLANK"></a>) </p>
</div><!-- important -->

<div class="complement">
<p> Toutefois, la <strong class="title">position d'une ligne de contrôle</strong> dans le <strong class="specialDR">fichier source</strong> n'est pas indifférente. En particulier, une <strong>directive</strong> <code class="prettyprint lang-c">#define</code> ou <code class="prettyprint lang-c">#include</code> : </p>

<ul>
	<li> ne prend effet qu'à <strong class="defin">partir de</strong> <strong class="specialN">la ligne</strong> où elle est codée ; </li>

	<li> opère <strong class="defin">jusqu'à</strong> <strong class="specialN">la fin du fichier</strong>, sauf directive contraire (par exemple, <code>#undef</code> – cf. infra <a class="infra" href="Cc4-3_directivesPreprocesseur.html#undef"></a>) ; </li>

	<li> n'a <strong class="defin">aucun effet</strong> <strong>dans les autres fichiers sources</strong> du programme (sauf, évidemment, via une directive d'inclusion). </li>
</ul>

<p> Pour des questions de <strong class="pros">lisibilité</strong>, on s'efforce de coder ces directives de préférence <strong class="defin">en début de fichier</strong>, <strong class="warning">hors de toute fonction</strong> et plutôt avant les déclarations (mais pas forcément…). </p>

<p> En revanche, ces recommandations de bonnes pratiques ne concernent <strong class="warning">pas</strong> les directives de <strong class="title">compilation conditionnelle</strong>. </p>
</div><!-- complement -->


















<h2 id="include"> Directive d'inclusion d'un fichier source </h2>



<h3>  Syntaxe d'une directive <code class="prettyprint lang-c">#include</code> </h3>



<div class="important">
<p> Dans un <strong class="specialDG">fichier source</strong> qu'on peut qualifier de <strong class="specialDG">primaire</strong>, une <strong class="title">directive d'inclusion</strong> d'un <strong class="defin">fichier source secondaire</strong> se code par <strong>une seule ligne de contrôle</strong> de la forme :  </p>
<span class="inline">
	<code class="prettyprint lang-c">#include <span class="nocode"><strong class="specialG">chemin délimité</strong></span></code>
</span> <br>
où le <strong class="specialG">chemin délimité</strong> est un chemin dans l'arborescence des fichiers du poste de travail, encadré dans une <strong>paire de délimiteurs</strong> <code class="prettyprint lang-c">&lt; &gt;</code> <code class="prettyprint lang-c">" "</code> selon une syntaxe qui sera détaillée infra <a class="infra" href="Cc4-3_directivesPreprocesseur.html#syntaxeChemin"></a>. </p>
</div><!-- important -->

<div class="complement">
<p> Le <strong class="defin">fichier secondaire</strong> doit bien évidemment être <strong>accessible en lecture</strong> dans l'arborescence des fichiers du poste de travail où le programme est compilé. </p>
</div><!-- complement -->



<h3> Prétraitement d'une directive <code class="prettyprint lang-c">#include</code> </h3>



<div class="important">
<p> Lorsque le préprocesseur « rencontre » une <strong class="title">directive d'inclusion</strong>, il <strong class="defin">suspend</strong> les prétraitements du <strong class="specialDG">fichier primaire</strong> pour <strong>enchaîner</strong> ceux du <strong class="specialG">fichier secondaire</strong>, dans le même ordre immuable (prétraitements implicites puis prétraitements explicites, si le fichier secondaire contient lui‑même des directives). </p>

<p> C'est seulement une fois que tous les prétraitements du fichier secondaire sont achevés (y compris leurs effets dans le fichier primaire) qu'intervient la <strong class="defin">reprise des prétraitements</strong> du <strong class="specialDG">fichier primaire</strong>, à la ligne qui suit immédiatement celle de la directive d'inclusion. </p>
</div><!-- important -->

<div class="complement">
<p> Dans le <strong class="specialSG">fichier prétraité</strong> généré par la commande <code class="cmd">cpp</code>, toute directive d'inclusion se voit tout simplement <strong class="defin">remplacée par le contenu intégral</strong> du <strong>fichier secondaire</strong>. </p>
</div><!-- complement -->

<div class="expert">
<p> Du fait que le préprocesseur effectue une <strong>tokénisation</strong> du code (cf. supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#tokenisation"></a>), le fichier secondaire doit <strong class="warning">obligatoirement</strong> contenir des <strong class="defin">unités lexicales complètes</strong>. Toutefois, il est <strong class="pros">vivement conseillé</strong> de coder des <strong class="defin">instructions complètes</strong> (autrement dit, ne pas coder une instruction à cheval sur plusieurs fichiers).  </p>
</div><!-- expert -->

<div class="exemples">
<p class="exemple"> Voici un <strong>programme académique</strong> qui <strong class="title">compte le nombre de caractères</strong> dans une <strong class="specialO">chaîne de caractères</strong> mémorisée dans une variable nommée  <code class="prettyprint lang-c">testString</code>, déclarée en ligne nº 1. Ici, pour ne pas faire usage d'une fonction d'entrée‑sortie standard comme <code>printf</code> qui nécessiterait l'inclusion du fichier d'en‑tête volumineux <code>stdio.h</code>, on utilise de façon non conventionnelle la <strong class="defin">valeur retournée</strong> par la fonction <code class="prettyprint lang-c">main</code> pour obtenir le résultat. </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
char testString[] = "12345";

int main(void) {
  char * pC = testString, * start = testString;
  while (*pC) pC++;
  return pC - start;
}
</pre>
<!---------- ne pas indenter ---------->

<p> Cependant, si la <strong class="specialO">chaîne de caractères</strong> était <strong>très longue</strong> (imaginons qu'il s'agisse d'un texte de plusieurs pages), le reste du code serait <strong class="cons">malcommode</strong> à consulter puisqu'il faudrait naviguer loin dans le fichier source pour trouver le début de la fonction <code class="prettyprint lang-c">main</code>. </p>

<p> La solution la plus intuitive consiste donc à <strong class="defin">déporter la ligne nº 1</strong> dans un <strong>fichier secondaire</strong> nommé par exemple <code class="filename">testString.h</code> : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
char testString[] = "12345";
</pre>
<!---------- ne pas indenter ---------->

<p> et placé dans le <strong>même répertoire</strong> que le fichier source (primaire) du programme. Au début de ce dernier, il suffit alors de coder la <strong class="title">directive d'inclusion</strong> ci‑dessous : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include "testString.h"

int main(void) {
  char * pC = testString, * start = testString;
  while (*pC) pC++;
  return pC - start;
}
</pre>
<!---------- ne pas indenter ---------->

<p> Avec la commande <code class="displayDark"><span class="displayDarkGreen">cpp</span> exampleInclude.c <span class="displayDarkRed">-o</span> exampleInclude.i</code> on obtient le <strong class="specialSG">fichier prétraité</strong> suivant : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
# 1 "exampleInclude.c"
# 1 "&lt;built-in&gt;"
# 1 "&lt;command-line&gt;"
# 31 "&lt;command-line&gt;"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 32 "&lt;command-line&gt;" 2
# 1 "exampleInclude.c"
# 1 "testString.h" 1
char testString[] = "12345";
# 2 "exampleInclude.c" 2

int main(void) {
  char * pC = testString, * start = testString;
  while (*pC) pC++;
  return pC - start;
}
</pre>
<!---------- ne pas indenter ---------->

<p> où l'on voit que la <strong>directive</strong> <code class="prettyprint lang-c">#include</code> a bien été <strong class="defin">remplacée</strong> à la ligne nº 9 par le <strong>contenu du fichier</strong> <code class="filename">testString.h</code> (la déclaration de la chaîne <code class="prettyprint lang-c">testString</code>). </p>

<p> Sous <em class="mark">Linux</em>, on peut aisément vérifier que le programme se compile et s'exécute correctement en enchaînant les commandes (cf. chap. C2‑I <a class="previous" href="../C2-ElementsLangage/Cc2-1_squeletteCode.html#fonctionMain" target="_BLANK"></a>) : </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
<span class="displayDarkGreen">gcc</span> exampleInclude.c <span class="displayDarkRed">-o</span> exampleInclude
./exampleInclude
<span class="displayDarkGreen">echo</span> "Program returned value "<span class="displayDarkBlue">$?</span>
</pre>
<!---------- ne pas indenter ---------->

<p> On obtient bien la valeur retournée <code class="displayDark">5</code> puisque la chaîne déclarée <code class="prettyprint lang-c">testString</code> comporte cinq caractères. </p>
</div><!-- exemple -->



<h3 id="syntaxeChemin"> Syntaxe du chemin d'accès au fichier source secondaire </h3>



<div class="important">
<p> Le <strong class="title">chemin</strong> d'accès au <strong class="title">fichier secondaire</strong> à inclure est formé avec le caractère <code class="prettyprint lang-c">/</code> (<em class="english">slash</em>) comme <strong>séparateur générique de répertoires</strong> (opérationnel même si le système d'exploitation – notamment <em class="mark">Windows</em> – en utilise un autre). </p>

<p> Il peut être <strong class="title">délimité</strong> selon <strong>deux syntaxes</strong> qui ne doivent pas être confondues :  </p>

<ol class="numbered" style="margin-top: 0.5em; padding-top: 0em; margin-bottom: 0em;">
  <li> <code class="prettyprint lang-c">#include &lt;<span class="nocode"><strong class="specialG">chemin</strong></span>&gt;</code>  (entre <strong style="color:blue">chevrons</strong>), si le fichier est ciblé à partir d'un des <strong class="defin">répertoires connus</strong> par la chaîne de compilation (typiquement, par la variable d'environnement <code>PATH</code>) ;  </li>

  <li> <code class="prettyprint lang-c">#include "<span class="nocode"><strong class="specialG">chemin</strong></span>"</code>  (entre <strong style="color:darkorange">guillemets</strong>), si le fichier est ciblé : </li>
    <ul>
      <li> d'abord à partir du <strong class="defin">répertoire de compilation</strong>,  </li>

      <li> puis, s'il n'y est pas trouvé, à partir d'un des <strong class="defin">répertoires connus</strong> par la chaîne de compilation ; </li>
    </ul>
</ol>
<p> sachant qu'en dernier recours, le préprocesseur cherche le fichier à partir du répertoire <strong class="defin">racine</strong> du poste de travail. On peut donc spécifier aussi bien un <strong>chemin</strong> <strong class="specialG">relatif</strong> qu'<strong class="specialG">absolu</strong>. </p>
</div><!-- important -->


<div class="complement">
<p> En pratique, la <strong class="title">syntaxe</strong> <code class="prettyprint lang-c">&lt;<span class="nocode"><strong class="specialG">chemin</strong></span>&gt;</code> s'emploie de préférence lorsque le fichier secondaire à inclure est un <strong class="defin">fichier d'en‑tête</strong> issu : </p>
<ul>
  <li> de la <strong>bibliothèque standard</strong> du langage <strong>C</strong> (par exemple <code class="filename">stdio.h</code>, <code class="filename">stdlib.h</code>, <code class="filename">math.h</code>…) ou du langage <strong>C++</strong> (par exemple <code class="filename">iostream</code>, <code class="filename">cmath</code>… et dans ce cas, on rappelle l'absence d'extension <code class="filename">.h</code>  – cf. C2‑I <a class="previous" href="../C2-ElementsLangage/Cc2-1_squeletteCode.html#cPlusPlus" target="_BLANK"></a>) ; </li>

  <li> des <strong>bibliothèques enregistrées</strong> d'un <em class="english">framework</em> dans un environnement de programmation comme par exemple <strong class="Arduino">Arduino</strong>, par exemple <code class="filename">SD.h</code>, <code class="filename">SPI.h</code>, <code  class="filename">avr/interrupt.h</code>, etc. </li>
</ul>

<p> Quant à la <strong class="title">syntaxe</strong> <code class="prettyprint lang-c">"<span class="nocode"><strong class="specialG">chemin</strong></span>"</code>, elle peut aussi fonctionner dans les cas précédents, mais la <strong class="pros">bonne pratique</strong> consiste à l'employer <strong>seulement</strong> pour un fichier secondaire stocké dans le <strong class="defin">répertoire de projet</strong> (ou éventuellement ses sous‑répertoires) du programme que l'on compile. En effet, dans un tel cas, la syntaxe entre chevrons ne fonctionne pas. </p>
</div><!-- complement -->

<div class="expert">
<p> Dans tous les cas, le <strong class="title">chemin</strong> est reconnu par le préprocesseur comme une <strong class="specialG">chaîne de caractères</strong>, avec pour conséquences : </p>
<ul>
  <li> qu'elle ne peut faire l'objet d'<strong>aucune substitution</strong> via une directive <code class="prettyprint lang-c">#define</code> (cf. infra <a class="infra" href="Cc4-3_directivesPreprocesseur.html#macros"></a>) ; </li>

  <li> qu'elle ne peut comporter <strong>aucun commentaire</strong> ; </li>

  <li> qu'elle est <strong>insensible aux séquences d'échappement</strong> (cf. chap. C3‑VIII <a class="previous" href="../C3-Numeration/Cc3-8_typesCaracteres.html#sequenceEchap" target="_BLANK"></a>). </li>
</ul>
</div><!-- expert -->

<p> Enfin, le <strong class="title">nom</strong> du fichier secondaire obéit aux <strong class="defin">mêmes contraintes</strong> que pour n'importe que <strong class="specialDG">fichier source</strong> codé en langage <strong>C</strong> ou <strong>C++</strong> (extension sans importance, pas d'espace ni symboles, ni caractères spéciaux, etc. – cf. chap. C2‑I <a class="previous" href="../C2-ElementsLangage/Cc2-1_squeletteCode.html#C" target="_BLANK"></a>). </p>



<div class="exemples"><p class="exemples"></p>
<ol class="numbered">
  <li> Dans un programme qui fait appel à un ou plusieurs <strong class="title">fonctions mathématiques</strong> définies dans la bibliothèque standard, on code :  </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;math.h&gt;
</pre>
<!---------- ne pas indenter ---------->
  
  <li> Dans un programme qui ferait appel à un <strong class="title">fichier source secondaire</strong> <code class="filename">display.h</code> rangé dans un <strong>répertoire</strong> <code class="filename">LIB</code> lui‑même créé dans le <strong class="defin">répertoire de projet</strong>, on coderait : </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include "LIB/display.h"
</pre>
<!---------- ne pas indenter ---------->
</ol>  
</div><!-- exemples -->


<div class="remarques"><p class="remarques"></p>
<p> Lorsqu'il existe <strong class="title">plusieurs fichiers homonymes</strong> dans la liste des répertoires que le préprocesseur scanne pour une directive d'inclusion, c'est le <strong class="defin">premier trouvé</strong> qui est inclus. </p>

<p> Sur terminale de commande <em class="mark">Linux</em>, on peut afficher la liste des répertoires scannés par la commande :  </p>
<div class="inline">
  <code class="displayDark"><span class="displayDarkGreen">cpp</span> <span class="displayDarkRed">-v</span> /dev/null <span class="displayDarkRed">-o</span> /dev/null</code>
</div>

<p> Plus généralement, le préprocesseur <strong>CPP</strong> accepte diverses <strong class="title">options</strong> pour gérer précisément la liste des répertoires où chercher les fichiers à inclure. Pour plus de détails, on peut se reporter à ce lien <a class="external" href="https://gcc.gnu.org/onlinedocs/cpp/Search-Path.html#Search-Path" target="_BLANK"></a>. </p>
</div><!-- remarque -->



<h3> Emploi des directives d'inclusion </h3>



<div class="important">
<p> Les <strong class="title">directives d'inclusion</strong> constituent un outil essentiel de la <strong class="pros">conception modulaire</strong> des langages <strong>C</strong> et <strong>C++</strong>, puisque c'est le seul moyen pour exploiter leurs <strong class="defin">bibliothèques standards</strong> respectives et toutes les <strong>autres bibliothèques</strong> déjà développées. </p>

<p> En termes de lisibilité, la bonne pratique consiste à coder toutes les directives d'inclusion des <strong class="title">fichiers d'en‑tête</strong> <strong class="pros">au tout début</strong> des fichiers sources. </p>
</div><!-- important -->

<div class="complement">
<p> Dans le cadre du <strong class="title">développement d'un programme</strong>, il est bien évidemment recommandé d'adopter la <strong class="pros">même stratégie</strong> en répartissant le code sur plusieurs fichiers. Les aspects techniques d'une telle décomposition sont étudiés en détail au chap. C4‑V <a class="nest" href="Cc4-5_programmationMultifichiers.html" target="_BLANK"></a>.  </p>

<p> Mais un <strong class="title">autre emploi</strong> usuel des directives d'inclusion est de pouvoir déporter dans des fichiers séparés des <strong>textes volumineux</strong>, comme des longs messages d'entrée‑sortie ou même du <strong>code <em class="sigle">HTML/CSS/JS</em></strong>. </p>
</div><!-- complement -->

<div class="exemples">
<p class="exemple"> Pour les exercices nº 5 à 8 du TP nº R3‑3 (partie <span class="partie">R3</span> du module de formation aux réseaux <a class="TP" href="../../ModuleR/R3-TransportReseauLiaison/Rtp3-3_objetConnecte.html#exo5" target="_BLANK"></a>), on embarque dans une carte à microcontrôleur un <strong>serveur web</strong>, dont la <strong class="title">page d'accueil</strong> est codée dans un <strong>fichier séparé</strong> nommé <code class="filename">index_html.h</code> dont une version simplifiée est : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
const char index_html[] PROGMEM = R<span class="nocode" style="color: darkorange; font-style: italic; font-weight: 600; font-family: source code pro;" >"=====(
&lt;!DOCTYPE html&gt;
&lt;html lang="fr"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;LED&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h2&gt; LED state: %LED% &lt;/h2&gt;

    &lt;h2 style="display: inline;"&gt; LED control: 
      &lt;a href="/switchLedOn"&gt;&lt;button style="font-size: 100%;"&gt;ON&lt;/button>&lt;/a&gt;
      &lt;a href="/switchLedOff"&gt;&lt;button style="font-size: 100%;"&gt;OFF&lt;/button>&lt;/a&gt;
    &lt;/h2&gt;
  &lt;/body&gt;
&lt;/html&gt;
)====="</span>;
</pre>
<!---------- ne pas indenter ---------->

<p> <em class="remark">Attention</em>. Même si ce fichier contient principalement du code <strong><em class="sigle">HTML</em></strong>, il <strong class="warning">ne doit pas être nommé</strong> avec une <strong>extension</strong> <code>.html</code> car il reste fondamentalement du code <strong>C</strong> ou <strong>C++</strong>. Cependant, dans un éditeur de code, rien n'interdit de le visualiser avec une coloration syntaxique adaptée au langage <strong><em class="sigle">HTML</em></strong> (avec <strong class="Sublime">Sublime Text</strong>, il suffit de cliquer sur le nom du langage dans le coin droit de la barre d'état et de cocher le langage voulu). </p>
</div><!-- exemple -->

<div class="remarques">
<p class="remarque"> Si les <strong class="title">fichiers à inclure</strong> sont <strong class="warning">volumineux</strong>, l'ajout de nombreuses directives d'inclusion peut <strong class="cons">augmenter significativement</strong> le <strong>temps de compilation</strong> du programme. C'est une des raisons qui justifie le fait que les <strong class="defin">fichiers d'en‑tête</strong> ne contiennent <strong class="pros">seulement</strong> des <strong>déclarations</strong> et des <strong>directives</strong>, afin de rester aussi légers que possible. Les blocs de définition des fonctions sont quant à eux codés dans des fichiers distincts, compilables séparément. </p>
</div><!-- remarque -->


















<h2 id="define"> Généralités sur les macro‑définitions </h2>



<p> D'une façon générale, en programmation, on appelle <strong class="title">macro‑définition</strong> <a class="external" href="https://fr.wikipedia.org/wiki/Macro-définition" target="_BLANK">W</a> – et on emploie usuellement le terme abrégé « <strong>macro</strong> » pour le désigner – un <strong class="specialN">fragment de code</strong> auquel on attribue un <strong class="specialG">nom</strong>. </p>

<p> Ce <strong class="specialG">nom</strong> ainsi défini peut ensuite être utilisé <strong class="defin">à la place</strong> du <strong class="specialN">fragment de code</strong> dans tout le code consécutif à cette macro‑définition. </p>



<h3 id="macros"> Syntaxe générale d'une macro‑définition </h3>



<div class="important">
<p> En langages <strong>C</strong> et <strong>C++</strong>, les <strong class="title">macro‑définitions</strong> sont codées à l'aide d'une <strong>directive</strong> constituée d'une <strong class="defin">une seule ligne de contrôle</strong> de la forme :  <br>
<span class="inline">
  <code class="prettyprint lang-c">#define <span class="nocode"><strong class="specialLG">expression d'identification</strong>   <strong class="specialN">fragment de code</strong> </span></code>
</span> </p>
</div><!-- important -->

<div class="complement">
<p> Cette forme syntaxique présente des <strong class="title">subtilités</strong> auxquelles il faut dès maintenant prêter la plus grande attention : </p>
<ul>
  <li> L'<strong class="specialLG">expression d'identification</strong> comporte le <strong class="specialG">nom</strong> de la macro et éventuellement des <strong class="specialT">arguments</strong> (un peu comme une fonction). Elle est soumise à de <strong class="warning">fortes contraintes syntaxiques</strong> (il ne peut pas s'agir de n'importe quelle chaîne de caractères). </li>

  <li> Le <strong class="specialN">fragment de code</strong>, qui est considéré comme étant la « <strong>définition de la macro</strong> », est a contrario soumis à <strong class="pros">peu de contrainte syntaxiques</strong>. </li>

  <div class="nobullet"> On parle aussi de <strong class="specialN">chaîne de substitution</strong> au sens où ce fragment de code peut être considéré <strong class="specialO">comme une « chaîne de caractères »</strong> dans le fichier source (mais avec un sens beaucoup plus général que celui d'une donnée de type « chaîne de caractères » en langage <em>C</em>) qui vient se <strong class="defin">substituer</strong> au <strong class="specialG">nom</strong>. C'est donc ce terme de chaîne de substitution que nous privilégierons par la suite. </div>
</ul>
</div><!-- complement -->

<div class="expert">
<p> Pour se faire une première idée, on retiendra donc que par les contraintes syntaxiques portant sur le nom, une <strong class="title">directive</strong> <code class="prettyprint lang-c">#define</code> est <strong class="cons">moins souple</strong> qu'une fonctionnalité « <strong>rechercher/remplacer</strong> » dans un éditeur de code, mais également <strong class="pros">plus puissante</strong> puisqu'elle peut admettre des arguments.  </p>
</div><!-- expert -->



<h3 id="emploiMacros"> Principaux emplois des macro‑définitions </h3>



<div class="important">
<p> La <strong class="title">directive</strong> <code class="prettyprint lang-c">#define</code> est principalement employée pour coder dans un fichier source des <strong class="specialLB">pseudo‑constantes</strong> et des <strong class="specialLB">pseudo‑fonctions</strong>. </p>
</div><!-- important -->


<div class="complement">
<p class="square" style="margin-top: 0em"> Une <strong class="specialLB">pseudo‑constante</strong> (en anglais, <em class="english">objet‑like macro</em>) est défini par une macro dont : </p>
<ul>
  <li> l'<strong class="specialG">expression d'identification</strong> est simplement le <strong class="specialG">nom</strong> de la macro, c'est‑à‑dire simplement un <strong>identificateur</strong> ; </li>

  <li> la <strong class="specialN">chaîne de substitution</strong> est une expression dont l'évaluation prend, après expansion complète (cf. infra <a class="infra" href="Cc4-3_directivesPreprocesseur.html#traitementDefine"></a>), la valeur d'une <strong>constante littérale</strong> du langage. </li>
</ul>
</div><!-- complement -->

<div class="exemples">
<p class="exemple"> Dans le <strong>fichier d'en‑tête</strong> <code class="filename">Arduino.h</code> pour cartes à cœur <strong><em class="sigle">AVR</em></strong>, on trouve la <strong class="title">macro‑définition</strong> de la <strong class="specialLB">pseudo‑constante</strong> :  </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:43">
#define DEG_TO_RAD 0.017453292519943295769236907684886
</pre>
<!---------- ne pas indenter ---------->

<p> On conçoit aisément son utilité : il est <strong class="pros">bien plus lisible</strong> d'employer son <strong class="specialG">identificateur</strong> <code class="prettyprint lang-c">DEG_TO_RAD</code> que la valeur numérique codée par sa <strong class="specialN">chaîne de substitution</strong> <code class="prettyprint lang-c">0.017<span class="nocode">…</span></code> qu'il est difficile pour un codeur d'identifier immédiatement. </p>
</div><!-- exemple -->

<div class="complement">
<p class="square" style="margin-top: 0em"> Une <strong class="specialLB">pseudo‑fonction</strong> (en anglais, <em class="english">function‑like macro</em>) est défini par une macro dont : </p>
<ul>
  <li> l'<strong class="specialLG">expression d'identification</strong> de la macro est composé d'un <strong class="specialG">identificateur</strong> associé une <strong class="specialT">liste d'arguments formels</strong> codée entre parenthèses <code class="prettyprint lang-c">()</code> comme pour une « vraie » fonction mais <strong class="warning">sans typage</strong> </li>

  <li> la <strong class="specialN">chaîne de substitution</strong> est une expression qui peut comporter autant d'<strong>occurrences</strong> que voulu des <strong class="specialT">arguments formels</strong>. </li>
</ul>
</div><!-- complement -->

<div class="exemples">
<p class="exemple"> Toujours dans le <strong>fichier d'en‑tête</strong> <code class="filename">Arduino.h</code> pour cartes à cœur <strong><em class="sigle">AVR</em></strong>, on trouve la <strong class="title">macro‑définition</strong> de la <strong class="specialLB">pseudo‑fonction</strong> :  </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:97">
#define radians(deg) ((deg)*DEG_TO_RAD)
</pre>
<!---------- ne pas indenter ---------->

<p> Elle permet de convertir en <strong>radians</strong> – c'est justement ce terme qui est choisi pour son <strong class="specialG">identificateur</strong> – un angle exprimé en degrés – son <strong class="specialT">argument formel</strong> <code class="prettyprint lang-c">deg</code>. </p>

<p> Sa <strong class="specialN">chaîne de substitution</strong> code tout simplement la multiplication de son <strong class="specialT">argument formel</strong> <code class="prettyprint lang-c">deg</code> par la pseudo‑constante <code class="prettyprint lang-c">DEG_TO_RAD</code> préalablement définie. </p>

<p> Dans la suite du code, une expression comme <code class="prettyprint lang-c">radians(180)</code> serait remplacée par le préprocesseur par l'expression :  </br>
<span class="inline">
  <code class="prettyprint lang-c">((180) * 0.017453292519943295769236907684886)</code>
</span> <br>
laquelle serait ensuite évaluée environ <code>3.141592653589793</code> par le compilateur. </p>

<div class="expert"> 
<p> Pour les tester, on peut employer ces deux macro‑définition en les codant dans un <strong>programme académique</strong> en langage <strong>C</strong> comme ci‑dessous : </p>


<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:97">
#include &lt;stdio.h&gt;

#define radians(deg) ((deg)*DEG_TO_RAD)
#define DEG_TO_RAD 0.017453292519943295769236907684886

int main(void) {
  printf("Pi approximately equals %.15f \n", radians(180));
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

</div><!-- expert -->
</div><!-- exemple -->



<h3 id="traitementDefine"> Prétraitement d'une directive <code class="prettyprint lang-c">#define</code> </h3>



<div class="important">
<p> De façon générale, lorsqu'il rencontre une <strong class="title">directive</strong> <code class="prettyprint lang-c">#define</code> dans un fichier source (y compris si cette directive provient d'un fichier inclus), le préprocesseur remplace séquentiellement, dans toute la suite du code source, <strong class="defin">chaque occurrence</strong> de l'<strong class="specialG">identificateur</strong> par sa <strong class="specialN">chaîne de substitution</strong>. </p>

<p>  On dit qu'il procède ainsi à l'<strong class="title">expansion</strong> de la <strong>macro‑définition</strong> codée par cette directive. </p>
</div><!-- important -->

<div class="complement">
<p> En revanche, contrairement au compilateur, le préprocesseur ne procède à <strong class="warning">aucun calcul</strong> dans une expression formée par l'expansion d'une macro‑définition. </p>
</div><!-- complement-->


<div class="exemples">
<p class="exemple"> Le <strong>programme académique</strong> ci‑dessous affiche le prix d'une baguette de pain <em>hors‑taxe</em> (<em class="sigle">HT</em>) puis <em>toute taxe comprise</em> (<em class="sigle">TTC</em>), compte tenu du <strong>taux de <em class="sigle">TVA</em></strong> de 0,055 % sur les produits alimentaires <a class="external" href="https://fr.wikipedia.org/wiki/Taxe_sur_la_valeur_ajoutée" target="_BLANK">W</a>. Ce taux est codé à la ligne nº 3 par la <strong class="title">macro‑définition</strong> d'une <strong class="specialLB">pseudo‑constante</strong> dont l'<strong class="specialG">identificateur</strong> est <code class="prettyprint lang-c">TVA</code> et la <strong class="specialN">chaîne de substitution</strong> <code class="prettyprint lang-c">0.055</code> sa valeur numérique  :  </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include  &lt;stdio.h&gt;

#define TVA 0.055 // %

int main(void) {
  const float prixBaguetteHT  = 1.14; // euros
  const float prixBaguetteTTC = prixBaguetteHT * (1 + TVA);
  printf("Baguette HT  : %.2f euros\n", prixBaguetteHT);
  printf("Baguette TTC : %.2f euros\n", prixBaguetteTTC);
  printf("(taux de TVA appliqué %.1f %%)\n", TVA * 100);
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

<p> À partir de cette ligne, dans toute la suite du code source, le préprocesseur remplace les <strong>deux occurrences</strong> (lignes nº 3 & 10) de <code class="prettyprint lang-c">TVA</code> par <code class="prettyprint lang-c">0.055</code>. Et en effet, dans le <strong class="specialSG">fichier prétraité</strong> généré par la commande <code class="cmd">cpp</code>, la fonction <code class="prettyprint lang-c">main</code> devient :  </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:731">
int main(void) {
  const float prixBaguetteHT  = 1.14; // euros
  const float prixBaguetteTTC = prixBaguetteHT * (1 + 0.055);
  printf("Baguette HT  : %.2f euros\n", prixBaguetteHT);
  printf("Baguette TTC : %.2f euros\n", prixBaguetteTTC);
  printf("(taux de TVA appliqué %.1f %%)\n", 0.055 * 100);
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

</div><!-- exemple -->


<div class="expert">
<h4 id="occurrencesExpansion"> Occurrences d'expansion d'une macro‑définition </h4>


<div class="complement">
<p> Insistons sur le fait que le premier élément d'une directive de macro‑définition est un <strong class="specialG">identificateur</strong>  et non <strong class="warning">pas</strong> une <strong>simple chaîne de caractères</strong>. Dans le fichier source, son <strong class="title">expansion</strong> n'opère donc <strong class="warning">pas</strong> pour certaines occurrences de la suite de caractères que forme son identificateur, en particulier : </p>

<ul>
  <li> ni dans les objets de type <strong class="specialO">chaîne de caractères</strong> ; </li>

  <li> ni à l'intérieur (sur des parties) d'<strong class="defin">autres identificateurs</strong> qui sont, rappelons‑le, des éléments lexicaux atomiques (cf. chap. C2‑IV <a class="previous" href="../C2-ElementsLangage/Cc2-2_syntaxeFondamentale.html#compositionExpression" target="_BLANK"></a>) ; </li>

  <li> ni bien évidemment dans les <strong class="specialLGr">commentaires</strong> (où il ne peut y avoir  d'identificateur puisqu'il ne s'agit pas de code). </li>
</ul>
</div><!-- complement -->

<div class="exemples">
<p class="exemple"> À la ligne nº 10 du fichier source de l'<strong class="title">exemple précédent</strong> : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:10">
  printf("(taux de TVA appliqué %.1f %%)\n", TVA * 100);
</pre>
<!---------- ne pas indenter ---------->

<p> le préprocesseur n'a <strong class="warning">pas</strong> effectué d'expansion dans la <strong class="specialO">chaîne de format</strong> de la fonction <code class="prettyprint lang-c">printf</code> puisqu'il s'agit d'une chaîne de caractères et que les trois lettres successives « <code style="color: darkorange;">TVA</code> » qui y figurent ne constituent <strong>pas un identificateur</strong>. </p> 

<p> Il en serait de même si l'on avait codé la macro‑définition d'une <strong class="specialLB">deuxième pseudo‑constante</strong> à la suite de la première, comme par exemple  : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:4">
#define FACTEUR_TVA (1 + TVA)
</pre>
<!---------- ne pas indenter ---------->

<p> Lors de l'expansion de la première macro‑définition, le préprocesseur aurait opéré à la ligne nº 4 la substitution de l'identificateur <code class="prettyprint lang-c">TVA</code> par <code class="prettyprint lang-c">0.055</code> dans l'expression <code class="prettyprint lang-c">(1 + TVA)</code> (ou l'identificateur <code class="prettyprint lang-c">TVA</code> est <em>utilisé</em>) mais <strong class="warning">pas</strong> <strong>dans l'identificateur</strong> <code class="prettyprint lang-c">FACTEUR_TVA</code> car il ne peut pas être décomposé (c'est un atome). </p>
</div><!-- exemple -->
</div><!-- expert -->  




<h3 id="undef"> Inhibition d'une macro‑définition : la directive <code class="prettyprint lang-c">#undef</code> </h3>



<div class="important">
<p> <strong>En aval d'une macro‑définition</strong> (et même si elle figure dans un autre fichier préalablement inclus), il est possible de coder son <strong class="title">inhibition</strong> grâce à une <strong>ligne de contrôle</strong> de la forme : <br>
<span class="inline"> 
  <code class="prettyprint lang-c">#undef <span class="nocode"><strong class="specialG">identificateur</strong></span></code>
</span> </p>
<p> Au delà de cette ligne, l'<strong class="specialG">identificateur</strong> devient <strong class="specialO">non défini</strong> au sens où il n'est plus reconnu comme tel par le préprocesseur. </p>
</div><!-- important -->

<div class="complement">
<p> Après son inhibition, l'<strong class="specialG">identificateur</strong> d'une directive de macro‑définition peut alors être <strong class="defin">réutilisé</strong>  pour une <strong class="title">nouvelle macro‑définition</strong> ou une <strong>déclaration</strong> <strong class="pros">sans surcharge</strong> (cf. infra <a class="infra" href="Cc4-3_directivesPreprocesseur.html#surcharge"></a>). Ainsi, on peut notamment : </p>
<ul>
  <li> <strong class="defin">changer la valeur</strong> <strong>d'une pseudo‑constante</strong> en la redéfinissant autant de fois que nécessaire dans le fichier source ;  </li>

  <li> <strong class="defin">localiser</strong> <strong>une pseudo‑constante</strong> dans une partie de code en inhibant définitivement son identificateur à une ligne voulue du fichier source, et ce <strong class="pros">indépendamment de toute structuration du code</strong> – c'est‑à‑dire, dans un même bloc, ou même à cheval sur plusieurs niveaux de blocs… </li>
</ul>
</div><!-- complement -->

<div class="remarques">
<p class="remarque"> Lors d'une <strong class="title">inhibition</strong>, si l'<strong class="specialG">identificateur</strong> n'est <strong class="warning">pas préalablement défini</strong>, alors la directive est <strong class="defin">inopérante mais silencieuse</strong> : elle ne déclenche pas d'erreur ni d'avertissement du préprocesseur. </p>
</div><!-- remarque -->

<div class="exemples">
<p class="exemple"> Dans le <strong>programme académique</strong> ci‑dessous, à la ligne nº 8, on a codé l'<strong class="title">inhibition de la macro‑définition</strong> de la <strong>pseudo‑constante</strong> <code class="prettyprint lang-c">TVA</code> pour la redéfinir avec une <strong class="defin">nouvelle valeur</strong> à la ligne suivante : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;

#define     TVA   0.055  // %

int main(void) {
  printf("(taux de TVA appliqué %.1f %%)\n", TVA * 100);

#undef      TVA
#define     TVA   0.2    // %

  printf("(taux de TVA appliqué %.1f %%)\n", TVA * 100);
  return 0;
}    
</pre>
<!---------- ne pas indenter ---------->

<p> On évite ainsi de définir <strong class="cons">deux pseudo‑constantes</strong> distinctes <code>TVA_1</code> et <code>TVA_2</code>, voire une <strong class="cns">variable</strong> dont on changerait la valeur. </p>

<div class="expert">
<p> Néanmoins, l'avantage de telle ou telle solution en termes de lisibilité et de robustesse aux erreurs ne peut être jugé qu'au cas par cas, au regard d'autres aspects du programme. </p>
</div><!-- expert -->
</div><!-- exemple -->



<div class="expert">
<h3> Emplois spéciaux de la directive <code class="prettyprint lang-c">#define</code> </h3> 



<div class="complement">
<p> On peut concevoir des <strong class="title">emplois</strong> de la directive <code class="prettyprint lang-c">#define</code> potentiellement <strong class="warning">plus complexes</strong>  que la macro‑définition de <strong>pseudo‑constantes</strong> et de <strong>pseudo‑fonctions</strong>. Pour se faire une idée des possibilités, la <strong class="title">directive</strong> <code class="prettyprint lang-c">#define</code> permet : </p>

<ul>
  <li> de substituer des <strong class="specialLB">synonymes</strong> aux <strong>mots‑clefs</strong> et aux <strong>opérateurs</strong> du langage (mais cet usage doit rester exceptionnel car en général peu lisible – cf. l'exemple ci‑après) ; </li>

  <li> de composer séparément des <strong class="specialLB">fragments de codes incomplets</strong> pour les réunir ensuite en fonction du contexte de la compilation ; </li>

  <li> de composer des <strong class="specialLB">chaînes de caractères variables</strong> en fonction du contexte de la compilation, etc. </li>
</ul>
 
<p> Seuls les <strong class="warning">mots réservés des directives</strong> (<code>include</code>, <code>define</code>, etc.) et les <strong class="warning">opérateurs du C++</strong> ne peuvent faire l'objet d'une macro‑définition (en fait, ces derniers possèdent déjà des mots‑clefs alternatifs prédéfinis ; par exemple, <code class="prettyprint lang-c">and</code> pour <code class="prettyprint lang-c">&&</code>, <code class="prettyprint lang-c">or</code> pour <code class="prettyprint lang-c">||</code>, etc.). </p>
</div><!-- complement --> 


<div class="exemples"><p class="exemples"></p>
<ol class="numbered">
  <li> On a vu au chap. C3‑III <a class="previous" href="../C3-Numeration/Cc3-3_typesBooleens.html#or_xnor" target="_BLANK"></a> que les langages <strong>C/C++</strong> ne disposaient <strong class="cons">pas de symboles spécifiques</strong> pour coder les opérateurs booléens <strong class="title">xor</strong> (<strong>ou exclusif</strong> <a class="external" href="https://fr.wikipedia.org/wiki/Fonction_OU_exclusif" target="_BLANK"></a>) et <strong class="title">xnor</strong>. </li>

  <div class="nobullet"> Néanmoins, il est <strong class="pros">très facile</strong> de pallier cette lacune en codant les deux <strong class="title">macro‑définitions</strong> suivantes :  </div>

  <!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:10">
#define xor  !=
#define xnor ==
</pre>
<!---------- ne pas indenter ---------->

  <div class="nobullet"> Elles permettent ensuite d'employer les identificateurs <code class="prettyprint lang-c">xor</code> et <code class="prettyprint lang-c">xnor</code> comme des opérateurs, respectivement <strong class="pros">à la place</strong> des <strong>opérateurs de comparaison</strong> <code class="prettyprint lang-c">!=</code> et <code class="prettyprint lang-c">==</code> qui, l'un comme l'autre, ne sont <strong class="cons">pas lisibles</strong> comme opérateurs booléens. </div>

  <div class="nobullet"> <em class="remark">Remarques</em>. </div>
  <ul>
    <li> De telles directives ne définissent <strong class="warning">ni</strong> des <strong>pseudo‑constantes</strong> (car leur chaîne de substitution n'est pas une constante littérale), <strong class="warning">ni</strong> des <strong>pseudo‑fonctions</strong> (car elles n'ont pas d'argument). </li>
  
    <li> Il n'est <strong class="warning">pas possible</strong> de procéder de même pour définir les opérateurs booléens <strong class="title">nand</strong> et <strong class="title">nor</strong>. En effet, ces deux opérateurs sont seulement codables l'un comme l'autre par <strong>composition de deux opérateurs</strong> . On peut donc les macro‑définir comme des pseudo‑fonctions, mais <strong class="cons">pas comme des opérateurs</strong>. </li>
  </ul>
  

  <li style="margin-top: 1.5em;"> <em class="remark">À éviter</em> ! Un francophone « allergique » à l'anglais pourrait être tenté de coder le programme ci‑dessous, qui commence par <strong>quatre directives</strong> pour définir des <strong class="title">synonymes français aux mots‑clefs</strong> et autres éléments de langages prédéfinis : </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;

#define entier              int 
#define retourne            return
#define fonctionPrincipale  main
#define affiche             printf

entier fonctionPrincipale() {
  affiche("Bonjour, Monde !");
  retourne 0;
}
</pre>
<!---------- ne pas indenter ---------->
  
  <div class="nobullet"> Grâce au préprocesseur, ce programme serait parfaitement <strong class="pros">compilable et exécutable</strong>, en <strong>C</strong> comme en <strong>C++</strong>. Et en effet, si l'on observait le contenu du <strong class="specialSG">fichier prétraité</strong> engendré par la commande <code class="cmd">cpp</code>, on y retrouverait tous les éléments de langage originaux : </div>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:733">
int main(void) {
  printf("Bonjour, Monde !");
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->
  
  <div class="nobullet"> Toutefois, même pour un codeur débutant, une telle démarche est <strong class="warning">vivement déconseillée</strong>. En effet, au delà d'une hypothétique commodité individuelle, ces macro‑définitions <strong class="cons">nuisent gravement à la lisibilité du code</strong>. En définissant de tels synonymes, on s'exclut de la communauté des codeurs expérimentés et dans la perspective d'un futur projet en équipe, il faut en effet penser à tous les lecteurs potentiels du code qui n'auront pas en tête ces directives de « traduction » personnelles et <strong>ne voudront pas</strong> prendre du temps pour se familiariser avec. </div>
</ol>
</div><!-- exemples -->


<p class="square"> Par ailleurs, il faut savoir que les normes des langages <strong>C</strong> et <strong>C++</strong> <strong class="warning">interdisent</strong> en principe de <strong class="title">redéfinir un mot‑clef</strong>, c'est‑à‑dire de coder une macro‑définition dont ce mot‑clef est l'<strong class="specialG">identificateur</strong>. </p>

<p> Mais dans la pratique, les préprocesseurs sont le plus souvent <strong class="cons">permissifs</strong> sur ce point. Et un tel procédé est <strong>parfois utilisé</strong> pour adapter un programme à un compilateur particulier, notamment sur le typage des variables, comme l'illustre l'exemple ci‑après. </p>

<p> Il va sans dire que ce genre de pratique est <strong class="warning">vivement déconseillée</strong> à tout codeur débutant. </p>

<div class="exemples">
<p class="exemple"> Dans le <strong class="title">programme académique</strong> ci‑dessous, la directive codée en ligne nº 3 redéfinit le <strong class="specialDR">mot‑clef</strong> <code class="prettyprint lang-c">const</code> par une <strong class="specialN">chaîne de substitution</strong> <strong class="specialV">vide</strong> : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;

#define const   // empty substitution string => keyword deleted below

int main(void) {
  const int a = 5;
  a = 0;
  printf("%d\n", a);
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->



<p> Autrement dit, à partir de la ligne nº 4, le préprocesseur <strong class="warning">supprime</strong> purement et simplement toutes les occurrences du <strong>mot‑clef</strong> <code class="prettyprint lang-c">const</code>. De ce fait, la donnée <code class="prettyprint lang-c">a</code> déclarée en ligne nº 6 devient une <strong class="defin">variable</strong> et peut faire l'objet d'une <strong>nouvelle affectation</strong> comme celle codée en ligne nº 7. </p>

<p> Bien évidemment, cet exemple n'est surtout pas à suivre systématiquement (il n'y a pas d'intérêt à déclarer une constante pour ensuite vouloir changer sa valeur par une astuce). Mais pour <strong class="title">adapter un code source</strong> volumineux à une <strong class="defin">chaîne de compilation ancienne</strong> qui ne comprend <strong class="warning">pas</strong> le mot‑clef <code class="prettyprint lang-c">const</code> (car il n'a pas toujours existé en langage <em class="mark">C</em>), il est bien plus commode de recourir à une <strong class="pros">directive astucieuse</strong> plutôt que de procéder par des copier‑coller fastidieux dans tous les fichiers source du programme. </p>
</div><!-- exemple -->

</div><!-- expert -->
























<h2> Règles générales de codage des macro‑définitions </h2>



<p> Le <strong class="title">codage des macro‑définitions</strong> obéit à des <strong class="warning">règles différentes</strong> de celles qui s'imposent <strong>déclarations de constantes</strong> et de <strong>fonctions</strong>. Il faut en avoir pleinement conscience pour éviter certains écueils « classiques ». </p>

<div class="expert">
<p> Les <strong class="title">règles générales</strong> qui suivent sont considérées comme telles car elles sont <strong class="defin">valables</strong>  pour les <strong class="specialLB">pseudo‑constantes</strong> <em class="remark">et</em> les <strong class="specialLB">pseudo‑fonctions</strong>. C'est seulement pour des raisons de simplicité pédagogique qu'elles sont illustrées avec des exemples mettant en œuvre des pseudo‑constantes uniquement. </p>

<p> Les <strong>règles spécifiques</strong> au codage des <strong class="specialLB">pseudo‑fonctions</strong> seront abordées dans une partie suivante <a class="infra" href="Cc4-3_directivesPreprocesseur.html#macrocommandes"></a>. </p>
</div><!-- expert -->



<h3> Choix du nom d'une macro‑définition </h3>



<div class="important">
<p> Comme expliqué supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#emploiMacros"></a>, le <strong class="title">nom</strong> d'une macro‑définition doit être un <strong class="specialG">identificateur</strong>. Cette contrainte répond au fait que le préprocesseur exige le respect des <strong>mêmes</strong> <strong class="defin">règles lexicographiques</strong> de formation des noms (cf. chap. C2‑II <a class="previous" href="../C2-ElementsLangage/Cc2-2_syntaxeFondamentale.html#choixIdentificateur" target="_BLANK"></a>) que le compilateur. </p>
</div><!-- important -->

<div class="complement">
<p>  De plus, pour une <strong class="title">pseudo‑constante</strong>, il est d'usage de coder son <strong class="specialG">identificateur</strong> tout <strong class="defin">en majuscules</strong>, <strong>comme pour une constante</strong> (cf. chap. C2‑IX <a class="previous" href="../C2-ElementsLangage/Cc2-9_bonnesPratiques.html#majuscules" target="_BLANK"></a>).  </p>
</div><!-- complement -->


<div class="exemples"><p class="exemples"></p>
<ul>
  <li> <strong class="title">Identificateurs</strong> <strong class="defin">valides</strong> : <br>
  <span class="inline">
    <code class="prettyprint">D5</code>    <code class="prettyprint">NEW_VOLTAGE</code>   <code class="prettyprint">FORFAIT_EN_EUROS</code>   <code class="prettyprint">_RAM_SIZE</code>  …
  </span> </li>

  <li> <strong class="title">Identificateurs</strong> <strong class="warning">non valides</strong> : </li>
  <ul>
    <li> <code class="grey">5D</code>  (<strong class="cons">chiffre initial</strong> interdit), </li>

    <li> <code class="grey">FORFAIT_EN_€</code>  (<strong class="cons">symbole « <code>€</code> »</strong> interdit), </li>

    <li> <code class="grey">NEW VOLTAGE</code>  (<strong class="cons">espace</strong> interdit), </li>

    <li> <code class="grey">NEW-VOLTAGE</code>  (<strong class="cons">trait d'union</strong> interdit). </li>
  </ul>
</ul>
</div><!-- exemple -->



<h3> « Portée » d'une macro‑définition </h3>



<div class="important">
<p> Par défaut, l'<strong>expansion</strong> d'une macro‑définition n'est <strong class="warning">pas localisée</strong> dans un éventuel <strong>bloc</strong> où sa ligne de contrôle serait codée. En effet, le préprocesseur ignore totalement la structuration des instructions. La « <strong class="title">portée</strong> » d'une <strong class="title">macro‑définition</strong> est donc <strong>a priori</strong> <strong class="defin">globale</strong>. </p>
</div><!-- important -->

<div class="complement">
<p> En l'absence de toute ligne de contrôle d'inhibition, une <strong class="title">macro‑définition</strong> opère donc <strong class="defin">jusqu'à la fin du code source</strong> que le préprocesseur est amené à traiter, c'est‑à‑dire jusqu'à la <strong>fin du fichier</strong> où elle est codée – ainsi que dans tous les fichiers où ce dernier serait éventuellement inclus. </p>
</div><!-- complement -->



<div class="expert">
<h3> Non‑récursivité de l'expansion </h3>



<div class="complement">
<p> Une <strong>macro‑définition</strong> peut être codée de façon <strong class="title">récursive</strong>, c'est‑à‑dire en employant son <strong>propre</strong> <strong class="specialG">identificateur</strong> dans sa <strong class="specialN">chaîne de substitution</strong>. </p>

<p> Néanmoins, le préprocesseur n'effectue <strong class="warning">pas d'expansion</strong> de ces <strong class="title">occurrences récursives</strong> d'identificateur, sinon il s'enfermerait dans un travail sans fin.</p>
</div><!-- complement -->

<p> Pour que le code généré par le préprocesseur soit par la suite compilable, il faut qu'un tel identificateur : </p>
<ul>
  <li> ne soit jamais utilisé dans les <strong>instructions</strong> du programme ;   </li>

  <li> ou alors fasse par ailleurs l'objet d'une <strong>déclaration</strong>.</li>
</ul>
<p> Dans la pratique, un tel codage n'a de sens que dans le cadre plus large de directives de <strong class="defin">compilation conditionnelle</strong> <a class="infra" href="Cc4-3_directivesPreprocesseur.html#compilCondi"></a>.   </p>


<div class="exemples">
<p class="exemple"> Dans le code académique (incomplet) ci‑dessous : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
enum {AM, PM} midDay;

#define  AM AM
</pre>
<!---------- ne pas indenter ---------->

<ul>
  <li> on déclare une <strong>variable</strong> de <strong>type énuméré anonyme</strong> dont chaque élément (<code class="prettyprint lang-c">AM</code>, <code class="prettyprint lang-c">PM</code>) est, rappelons‑le, implicitement une constante déclarée de type <code class="prettyprint lang-c">int</code> (cf. chap. C3‑IV <a class="previous" href="http://www.lycee-ferry-versailles.fr/snir/ModuleC/C4-Fonctions/C3-Numeration/Cc3-4_typesEnumeres.html" target="_BLANK"></a>) ; </li>

  <li> et on code (avant ou après, peu importe) une <strong class="title">macro‑définition</strong> <strong class="specialO">homonyme</strong> – donc <strong class="title">récursive</strong> – de <code class="prettyprint lang-c">AM</code> ; il s'agit donc d'une <strong class="specialLB">pseudo‑constante</strong> (sa valeur vaut <code>0</code>). </li>
</ul>

<p> L'<strong class="pros">intérêt</strong> d'une telle directive est qu'elle permet ensuite coder une ligne de contrôle de <strong class="defin">compilation conditionnelle</strong> comme par exemple <code class="prettyprint lang-c">#ifdef AM</code>. </p>
</div><!-- exemple -->


<!-- expert -->
<h3 id="surcharge"> Surcharge d'un identificateur déjà défini ou déclaré </h3>  


<div class="complement">
<p> Les <strong>diverses possibilités</strong> de <strong class="title">surcharge d'un identificateur</strong> par une macro‑définition de ce dernier, qu'il s'agissent d'un identificateur de <strong class="specialG">donnée</strong> (variable ou constante) ou d'une <strong class="specialLB">pseudo‑constante</strong>, sont décrites ci‑après. Elles sont intéressantes notamment pour effectuer des <strong class="defin">modifications ponctuelles</strong> d'un <strong>code existant</strong>, en agissant <strong class="pros">uniquement par des directives</strong>, donc sans toucher aux instructions. </p>
</div><!-- complement -->


<p class="square"> Plus « souple » que le compilateur, le préprocesseur accepte la <strong class="title">surcharge de l'identificateur</strong> d'une macro‑définition par une <strong>autre macro‑définition</strong> <strong class="defin">dans la même portée</strong> (cf. chap. C4‑II <a class="previous" href="http://www.lycee-ferry-versailles.fr/snir/ModuleC/C4-Fonctions/Cc4-2_porteesDonnees.html#visibilite" target="_BLANK"></a>). </p>

<p> <em class="remark">Toutefois</em>, une telle surcharge n'est <strong class="cons">pas conforme</strong> aux règles de <strong>bonnes pratiques</strong>, aussi le préprocesseur la signale par un <strong class="specialO">avertissement</strong>. Pour bien faire, il faut <strong class="pros">préalablement inhiber</strong> une macro‑définition avant de la redéfinir (cf. supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#undef"></a>), et alors on peut considérer qu'il n'y a plus de surcharge à proprement parler. </p>


<div class="exemples">
<p class="exemple"> Dans le programme académique ci‑dessous de calculs financiers, la macro‑définition de la <strong class="specialLB">pseudo‑constante</strong> <code class="prettyprint lang-c">TVA</code> à la ligne nº 3 est <strong class="title">surchargée</strong> par celle de la ligne nº 8 avec une <strong class="warning">valeur différente</strong>. </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include  &lt;stdio.h&gt;

#define     TVA   0.055 // %

int main(void) {
  printf("(taux de TVA appliqué %.1f %%)\n", TVA * 100);

#define     TVA   0.2  // %
  
  printf("(taux de TVA appliqué %.1f %%)\n", TVA * 100);
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

<p> À l'invocation de la commande <code class="cmd">cpp</code> ou <code class="cmd">gcc</code>, même sans option particulière, on obtient donc un <strong class="specialO">avertissement</strong>, comme ci‑dessous :  </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
$ <span class="displayDarkGreen">gcc</span> testDefineTVA2.c <span class="displayDarkRed">-o</span> testDefineTVA2

testDefineTVA2.c:8: warning: "TVA" redefined
    8 | #define     TVA   0.2   // %
      | 
testDefineTVA2.c:3: note: this is the location of the previous definition
    3 | #define     TVA   0.055 // %
      | 
</pre>
<!---------- ne pas indenter ---------->


<p> Néanmoins, la compilation n'échoue pas et on obtient une <strong class="pros">exécution satisfaisante</strong> avec la sortie ci‑dessous :  </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
$ ./testDefineTVA2
(taux de TVA appliqué 5.0 %)
(taux de TVA appliqué 20.0 %)
</pre>
<!---------- ne pas indenter ---------->

</div><!-- exemple -->

<div class="remarques">
<p class="remarque"> Si la <strong>surcharge de l'identificateur</strong> d'une macro‑définition procède par une <strong class="title">redéfinition à l'identique</strong>, le préprocesseur n'émet <strong class="defin">pas d'avertissement</strong>. </p>

<p> Cela peut arriver notamment lorsqu'un <strong>fichier d'en‑tête</strong> redéfinit à l'identique une macro‑définition d'un autre fichier d'en‑tête préalablement inclus.</p>

<p> <em class="remark">Attention</em>, pour qu'une redéfinition soit reconnue par le préprocesseur comme étant <strong class="title">identique</strong> à la précédente, il faut qu'elle engendre les <strong class="defin">mêmes tokens</strong>, ce qui peut être assez subtil en termes d'espacements. </p>
</div><!-- remarque -->

<p class="square"> En revanche, comme tout <strong class="specialG">identificateur</strong> de macro‑définition est <strong>systématiquement remplacé</strong> par sa chaîne de substitution <em class="remark">avant</em> <strong>transmission au compilateur</strong>, il peut être employé en <strong class="title">surcharge d'une déclaration antérieure</strong> y compris dans la portée</strong> de cette déclaration. Il n'y a alors <strong class="defin">aucun avertissement</strong> du préprocesseur. </p>


<div class="exemples">
<p class="exemple"> Dans le programme académique ci‑dessous, après la déclaration à la ligne nº 3 de la <strong>constante globale</strong> <code class="prettyprint lang-c">TVA</code>, on <strong class="title">surcharge</strong> à la ligne nº 8 son identificateur avec la macro‑définition d'une <strong class="specialLB">pseudo‑constante</strong> qui change sa valeur. </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include  &lt;stdio.h&gt;

const float TVA = 0.055; // %

int main(void) {
  printf("(taux de TVA appliqué %.1f %%)\n", TVA * 100);

#define     TVA   0.2    // %

  printf("(taux de TVA appliqué %.1f %%)\n", TVA * 100);
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

<p> La chaîne de compilation opère <strong class="defin">sans avertissement</strong> et l'exécution du programme se déroule comme pour l'exemple précédent, ainsi qu'on peut s'y attendre. Dans le <strong class="specialSG">fichier prétraité</strong> généré par la commande <code class="cmd">cpp</code>, on obtient :  </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:728">
const float TVA = 0.055;

int main(void) {
  printf("(taux de TVA appliqué %.1f %%)\n", TVA * 100);



  printf("(taux de TVA appliqué %.1f %%)\n", 0.2 * 100);
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

<p> On voit donc que la déclaration de la <strong>constante globale</strong> <code class="prettyprint lang-c">TVA</code> est intacte, puisqu'elle est antérieure à la macro‑définition. Mais après l'emplacement où figurait la macro (ligne nº 733), cette déclaration devient <strong class="defin">inopérante</strong> : l'identificateur surchargé a été remplacé par la constante littérale <code class="prettyprint lang-c">0.2</code>. </p>

<p style="margin-top: 1em"> <em class="remark">Remarque</em>. En revanche, si on avait codé la <strong class="title">macro‑définition</strong> de <code class="prettyprint lang-c">TVA</code> <strong class="warning">avant la déclaration</strong> de la <strong>constante globale</strong> du même nom, cette déclaration serait devenue <strong class="cons">non compilable</strong> après prétraitement par le préprocesseur : <br>
<span class="inline">
  <code class="prettyprint lang-c" style="background: lightgrey;">const float 0.2 = 0.055; </code>
</span> </p>  
</div><!-- exemple -->

<p class="square"> De plus, contrairement à ce que pourrait laisser penser la remarque supra, on peut aussi <strong class="title">surcharger une déclaration ultérieure</strong> de l'<strong class="specialG">identificateur</strong> d'une <strong class="specialG">donnée</strong> par une <strong>macro‑définition</strong>, mais à condition que la chaîne de substitution de cette dernière soit elle‑même un <strong class="defin">identificateur</strong> (il ne s'agit pas alors d'une véritable pseudo‑constante).  </p>

<p> Un tel procédé revient donc seulement à changer l'identificateur de cette déclaration. </p>

<div class="exemples">
<p class="exemple"> Dans le programme académique ci‑dessous, avant la déclaration à la ligne nº 5 de la <strong>constante globale</strong> <code class="prettyprint lang-c">TVA</code>, on <strong class="title">surcharge</strong> à la ligne nº 3 son <strong class="specialG">identificateur</strong> avec une macro‑définition qui le transforme en <code class="prettyprint lang-c">VAT</code> (sigle anglais signifiant <em class="english">value added tax</em>). </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include  &lt;stdio.h&gt;

#define     TVA   VAT

const float TVA = 0.055; // %

int main(void) {
  printf("(taux de TVA appliqué %.1f %%)\n", TVA * 100);
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

<p> Là encore, la chaîne de compilation opère <strong class="defin">sans avertissement</strong> et on obtient une <strong class="pros">exécution normale</strong> du programme. Dans le <strong class="specialSG">fichier prétraité</strong> généré par la commande <code class="cmd">cpp</code>, on obtient :  </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:731">
const float VAT = 0.055; 

int main(void) {
  printf("(taux de TVA appliqué %.1f %%)\n", VAT * 100);
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

<p style="margin-top: 1em"> <em class="remark">Remarque</em>. Dans cet exemple, la surcharge n'a <strong class="cons">pas vraiment d'utilité</strong> dans la mesure où, a priori, on a aucune raison de générer le fichier prétraité, sauf pour vérifier le travail accompli par le préprocesseur. </p>
</div><!-- exemple -->



<!-- expert -->
<h3> Contraintes d'antériorité </h3>



<div class="complement">
<p> Rappelons qu'en règle générale, en langages <strong>C</strong> et <strong>C++</strong>, un <strong class="specialG">identificateur</strong> peut être invoqué dans un code source <strong class="defin">seulement après avoir été déclaré</strong> (cf. chap. C2‑III <a class="previousl" href="../C2-ElementsLangage/Cc2-3_declarationDonnees.html#pourquoi" target="_BLANK"></a>) – aussi bien s'il s'agit d'un identificateur de donnée ou de fonction.  </p>

<p> Mais lorsque l'on compose la chaîne de substitution d'une macro‑définition, cette <strong class="title">contrainte d'antériorité</strong> ne s'applique pas toujours – et même <strong class="warning">assez rarement</strong>.  Pour le comprendre, il faut analyser la façon dont le préprocesseur opère l'expansion des macros, et ce en amont du compilateur. On s'y attachera dans les exemples ci‑après. </p>

<p> Néanmoins, il est quand même <strong class="pros">préférable de coder</strong> les macro‑définitions <strong>comme s'il s'agissait de déclarations</strong>, en respectant la règle usuelle d'antériorité. </p>
</div><!-- complement -->


<div class="exemples">
<p class="exemple"> Dans le programme académique ci‑dessous, la chaîne de substitution de la macro‑définition codée en ligne nº 3 invoque l'<strong class="specialG">identificateur</strong> <code class="prettyprint lang-c">TVA</code> qui n'est <strong class="title">pas encore défini</strong> (il l'est à la ligne suivante).  </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include  &lt;stdio.h&gt;

#define     TVA_100  (TVA * 100)
#define     TVA       0.055 

int main(void) {
  printf("(taux de TVA appliqué %.1f %%)\n", TVA_100);
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

<p> Pourtant la compilation s'effectue <strong class="defin">sans avertissement</strong> et on obtient une <strong class="pros">exécution normale</strong>. Dans le <strong class="specialSG">fichier prétraité</strong> généré par la commande <code class="cmd">cpp</code>, on obtient :  </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:732">
int main(void) {
  printf("(taux de TVA appliqué %.1f %%)\n", (0.055 * 100));
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

<p> Comme le préprocesseur a‑t‑il opéré ? </p>
<ul>
  <li> Il a prétraité la <strong>première directive</strong> <code class="prettyprint lang-c">#define</code> en scannant le fichier source. Il a trouvé la ligne nº 7 une occurrence de l'identificateur <code class="prettyprint lang-c">TVA_100</code> qu'il a remplacée par <code class="prettyprint lang-c">(TVA * 100)</code>. </li>

  <li> Puis il a prétraité la <strong>deuxième directive</strong> <code class="prettyprint lang-c">#define</code> en scannant le code qu'il a <strong class="defin">déjà prétraité</strong>. Il a donc trouvé une occurrence de l'<strong class="specialG">identificateur</strong> <code class="prettyprint lang-c">TVA</code> qu'il a remplacée par <code class="prettyprint lang-c">0.055</code>. </li>
</ul>

<p> Et il en aurait fait de même pour toute autre occurrence de la pseudo<code class="prettyprint lang-c">TVA_100</code> codée après sa macro‑définition. </p>
</div><!-- exemple -->

<div class="remarques">
<p class="remarques"> Dans l'exemple précédent : </p>

<ol class="littered">
  <li> Si on avait codé les deux <strong>macro‑définitions</strong> dans l'<strong class="title">ordre inverse</strong> : </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:3">
#define     TVA       0.055 
#define     TVA_100  (TVA * 100)
</pre>
<!---------- ne pas indenter ---------->  

  <div class="nobullet"> on aurait obtenu le <strong class="pros">même</strong> <strong class="specialSG">fichier prétraité</strong>. En effet : </div>
  <ul>
    <li> le préprocesseur aurait remplacé par <code class="prettyprint lang-c">0.055</code> l'occurrence de l'identificateur <code class="prettyprint lang-c">TVA</code> dans la chaîne de substitution de la macro‑définition de <code class="prettyprint lang-c">TVA_100</code>, laquelle serait devenue <code class="prettyprint lang-c">(0.055 * 100)</code> ; </li>

    <li> puis il aurait remplacé l'occurrence de <code class="prettyprint lang-c">TVA_100</code> en ligne nº 7 par cette nouvelle de substitution modifiée. </li>
  </ul>
  
  <li> Si on avait déclaré <code class="prettyprint lang-c">TVA</code> comme une <strong class="title">« vraie » constante</strong> avant ou après la macro‑définition de <code class="prettyprint lang-c">TVA_100</code>, par exemple ainsi : </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:3">
#define     TVA_100  (TVA * 100)
const float TVA = 0.055;
</pre>
<!---------- ne pas indenter ---------->  

  <div class="nobullet"> on aurait obtenu un <strong class="specialSG">fichier prétraité</strong> différent : </div>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:730">
const float TVA = 0.055;

int main(void) {
  printf("(taux de TVA appliqué %.1f %%)\n", (TVA * 100));
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->  

  <div class="nobullet"> mais <strong class="pros">compilable</strong> avec une <strong class="pros">exécution satisfaisante</strong>. </div>

  <li> En revanche, si l'on avait déclaré <code class="prettyprint lang-c">TVA_100</code> comme une « vraie » constante en premier : </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:3">
const float TVA_100 = TVA * 100;
#define     TVA       0.055 
</pre>
<!---------- ne pas indenter ---------->  

  <div class="nobullet"> on aurait obtenu un <strong class="specialSG">fichier prétraité</strong> <strong class="warning">non compilable</strong> : </div>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:730">
const float TVA_100 = TVA * 100;


int main(void) {
  printf("(taux de TVA appliqué %.1f %%)\n", TVA_100);
  return 0;
}
</pre>
<!---------- ne pas indenter ----------> 

  <div class="nobullet"> puisque dans sa déclaration, l'affectation sur <code class="prettyprint lang-c">TVA_100</code> invoque l'identificateur <code class="prettyprint lang-c">TVA</code> qui n'est <strong class="warning">pas déclaré</strong> ! En effet, l'expansion de sa macro‑définition dans le fichier source n'a pas eu lieu dans cette <strong>déclaration antérieure</strong>. Il aurait donc fallu coder la coder <em class="remark">après</em> la macro‑définition de la pseudo‑constante <code class="prettyprint lang-c">TVA</code>. </div>

  <div class="nobullet"> Dans notre exemple, c'est donc le <strong class="defin">seul cas</strong> où une <strong class="title">contrainte d'antériorité</strong> s'impose. </div>
</ol><!-- littered -->
</div><!-- remarque -->

</div><!-- expert -->


<h3 id="parentheses"> Règles de parenthésage </h3>



<div class="complement">
<p> On rappelle (cf. supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#traitementDefine"></a>) que lors de l'<strong class="title">expansion d'une macro‑définition</strong>, le préprocesseur compose des expressions par <strong class="defin">substitution</strong> de son identificateur et de ses éventuels arguments, mais <strong class="warning">sans faire de calculs</strong> d'évaluation des expressions produites par substitution. C'est seulement lors de la compilation ou de l'exécution que les expressions ainsi composées seront évaluées. </p>
</div><!-- complement -->

<div class="important">
<p> En règle générale, pour garantir une <strong class="pros">évaluation correcte</strong> – et ce quels que soient les rangs de priorité des opérateurs mis en jeu dans les expressions invoquant la macro‑définition – il est vivement recommandé d'<strong class="title">encapsuler dans des parenthèses</strong> : </p>
<ul>
  <li> sa <strong class="specialN">chaîne de substitution</strong> toute entière ; </li>

  <li> et dans cette dernière, s'il s'agit d'une pseudo‑fonction, chaque <strong>occurrence</strong> de chaque <strong class="specialO">argument</strong>. </li>
</ul>
<p> On verra plus loin <a class="infra" href="Cc4-3_directivesPreprocesseur.html#pseudoFonction"></a> que cette règle <strong class="warning">ne s'applique pas</strong> forcément dans certains cas particuliers, notamment à une pseudo‑fonction dont la <strong class="specialN">chaîne de substitution</strong> code <strong>plusieurs instructions</strong>. </p>
</div><!-- important -->


<div class="exemples">
<p class="exemple"> Dans le programme académique ci‑dessous de calcul du <strong class="title">prix d'une baguette</strong> de pain <strong>avec et sans <em class="sigle">TVA</em></strong> : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;

#define TVA          0.055 // %
#define TVA_100     (100 * TVA)
#define FACTEUR_TVA (1 + TVA)

const float prixBaguetteHT  = 1.14; // euros

int main(void) {
  printf("Baguette HT  : %.2f euros\n", prixBaguetteHT);
  printf("Baguette TTC : %.2f euros\n", prixBaguetteHT * FACTEUR_TVA);
  printf("(taux de TVA appliqué %.1f %%)\n", TVA_100);
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->


<p> Avec les <strong class="defin">parenthèses</strong> encapsulant les <strong class="specialN">chaînes de substitution</strong> des macro‑définition de <code>TVA_100</code> et <code>FACTEUR_TVA</code>, ce programme est <strong class="pros">codé correctement</strong>. En effet, dans le <strong class="specialL">fichier prétraité</strong> engendré par la commande <code class="cmd">cpp</code>, la fonction <code class="prettyprint lang-c">main</code> devient : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:735">
int main(void) {
  printf("Baguette HT  : %.2f euros\n", prixBaguetteHT);
  printf("Baguette TTC : %.2f euros\n", prixBaguetteHT * (1 + 0.055));
  printf("(taux de TVA appliqué %.1f %%)\n", (100 * 0.055));
  return 0;
}
</pre>
<!---------- ne pas indenter ----------> 

<p> où l'expression <code class="prettyprint lang-c">prixBaguetteHT * (1 + 0.055)</code> sera ensuite évaluée comme attendu <em class="bold" style="color: green;">1,44 × 1,055</em> par le compilateur, grâce aux parenthèses encapsulant l'addition. </p>

<p class="square"> En revanche, si à la ligne nº 5 du fichier source on avait codé la macro‑définition comme ci‑dessous, avec sa <strong class="specialN">chaîne de substitution</strong> <strong class="warning">sans les parenthèses</strong> : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:4">
#define FACTEUR_TVA  1 + TVA
</pre>
<!---------- ne pas indenter ---------->

<p> alors on aurait obtenu dans le <strong class="specialL">fichier prétraité</strong> : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:737">
  printf("Baguette TTC : %.2f euros\n", prixBaguetteHT * 1 + 0.055);
}
</pre>
<!---------- ne pas indenter ----------> 

<p> où l'expression <code class="prettyprint lang-c">prixBaguetteHT * 1 + 0.055</code> serait ensuite évaluée <em class="bold" style="color: red;">1,44 + 0,055</em> par le compilateur – <strong class="warning">valeur non conforme</strong> à l'objectif du programme.  </p>
</div><!-- exemple -->

<div class="remarques"><p class="remarques"></p>
<ol class="littered">
  <li> On peut noter que le <strong class="cons">non respect</strong> de la <strong class="title">règle de parenthésage</strong> ne provoque <strong class="warning">pas systématiquement</strong> des <strong>dysfonctionnements</strong> : tout dépend des opérateurs mis en jeu. Dans l'exemple supra, si à la ligne nº 4 du fichier source, la macro‑définition de <code class="prettyprint lang-c">TVA_100</code> était codée sans parenthèses, cela ne poserait pas de problème dans le programme puisque cette macro‑définition est invoquée seule dans une expression. </li>

  <div class="nobullet"> Le <strong class="pros">respect</strong> de la <strong class="title">règle de parenthésage</strong> n'en reste pas moins <strong class="defin">vivement recommandée</strong> par <strong>principe de précaution</strong>, dans l'hypothèse où le programme serait par la suite développé en faisant d'autres usages de cette macro, potentiellement problématiques sans parenthésage. </div>

  <li> Contrairement au compilateur, le préprocesseur ne procède <strong class="warning">aucune vérification</strong> de l'<strong class="title">équilibre des paires de délimiteurs</strong> (parenthèses, crochets, accolades) dans la chaîne de substitution d'une macro‑définition. Cela permet de définir des objets « composites » qui se complètent après expansion pour former un code compilable. </li>
</ol>
</div><!-- remarques -->






















<h2 id="pseudoConstante"> Macro‑définition d'une pseudo‑constante </h2>



<h3 id="notionPseudoConst"> Notion détaillée de pseudo‑constante </h3>



<div class="important">
<p> Une macro‑définition introduit une <strong class="title">pseudo‑constante</strong> lorsque : </p>
<ul>
  <li> son <strong class="specialLG">expression d'identification</strong> est <strong class="defin">sans argument</strong> – c'est un <strong>simple</strong> <strong class="specialG">identificateur</strong> ; </li>

  <li> sa <strong class="specialN">chaîne de substitution</strong> est telle que son expansion aboutit systématiquement à une <strong class="defin">expression constante</strong> (cf. chap. C2‑II <a class="previous" href="../C2-ElementsLangage/Cc2-2_syntaxeFondamentale.html#expressionConstante" target="_BLANK"></a>). </li>
</ul>
</div><!-- important -->


<div class="complement">
<p> Même si aucune règle syntaxique ne s'y oppose, la <strong class="title">notion de pseudo‑constante</strong> <strong class="warning">exclut l'emploi</strong> de tout identificateur de <strong class="specialM">variable</strong> dans sa <strong class="specialN">chaîne de substitution</strong>. En effet, cela créerait sinon une <strong class="cons">expression a priori non constante</strong>, ce qui n'est évidemment pas l'objectif.  </p>

<p> De plus, il est <strong class="warning">déconseillé</strong> d'employer dans cette chaîne de substitution un <strong>identificateur de constante</strong> car sinon : </p>
<ul>
  <li> l'expansion de la pseudo‑constante ne serait <strong class="pros">pas conforme</strong> à une <strong>expression constante entière</strong> (cf. chap. C2‑II <a class="previous" href="../C2-ElementsLangage/Cc2-2_syntaxeFondamentale.html#expressionConstanteEntiere" target="_BLANK"></a>), ce qui est parfois précisément l'objectif de l'emploi d'une pseudo‑constante – cf. infra <a class="infra" href="Cc4-3_directivesPreprocesseur.html#comparaisonConstante"></a> ; </li>

  <li> cela compose un code source <strong class="cons">hétérogène en termes de niveaux de langage</strong> ; il est préférable de rester homogène en n'employant que des constantes littérales, et éventuellement d'autres <strong class="defin">pseudo‑constantes</strong>. </li>
</ul>

<div class="expert">
<p> Néanmoins, il peut arriver de devoir <strong class="cons">déroger à cette règle</strong>, en particulier lorsqu'on veut coder une <strong class="title">pseudo‑constante</strong> dont la valeur dépend de celle d'une <strong>constante déclarée</strong> dans un <strong class="defin">fichier d'en‑tête de bibliothèque</strong>. </p>
</div><!-- expert -->
</div><!-- complement -->

<div class="expert">
<p> Même en respectant la règle ci‑dessus, une macro‑définition de pseudo‑constante permet de coder des <strong class="pros">objets plus complexes</strong> qu'une <strong>simple constante</strong>. </p>


<div class="exemples">
<p class="exemple"> On verra au chapitre C5‑III <a class="next" href="../C5-StructuresPointeurs/Cc5-3_tableauxDeclarations.html#declarationTab" target="_BLANK"></a> qu'en langage <strong>C</strong> ou <strong>C++</strong>, l'<strong>initialisation</strong> d'une variable de type <strong class="defin">tableau</strong> peut être effectuée par une <strong class="title">liste d'expressions</strong>. </p> 

<p> Si, dans un programme, une liste particulière était d'usage multiple, il serait souhaitable de la déclarer comme une <strong>constante</strong>, dans un objectif légitime de factorisation du code. Malheureusement, cela n'est syntaxiquement <strong class="cons">pas possible</strong>. </p>

<p> En revanche, rien n'interdit de définir une <strong class="defin">pseudo‑constante</strong> comme dans l'exemple académique ci‑dessous : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:3">
#define  INITIAL_SPEED_VALUES  1.05, 5.001, -3.2

double speedVector[3] = { INITIAL_SPEED_VALUES };
</pre>
<!---------- ne pas indenter ---------->
</div><!-- exemple -->
</div><!-- expert -->



<h3 id="comparaisonConstante"> Comparaison avec l'emploi d'une « vraie » constante </h3>


<div class="complement">
<p> Rappelons que l'emploi des <strong class="title">constantes déclarées</strong> à la place de <strong>constantes littérales</strong> (ou d'expressions composées avec des constantes littérales) est <strong class="defin">vivement recommandé</strong> pour la <strong class="pros">lisibilité</strong> et la <strong class="pros">robustesse aux erreurs</strong> de codage (cf. chap. C2‑III <a class="previous" href="../C2-ElementsLangage/Cc2-3_declarationDonnees.html#bonnePratiqueConstantes" target="_BLANK"></a>).  </p>

<p> Le recours à une <strong class="title">pseudo‑constante</strong> doit partir des <strong class="defin">mêmes motivations</strong> et s'imposer lorsqu'il n'est pas possible de procéder avec une simple constante déclarée. </p>
</div><!-- complement -->



<div class="important">
<p> Lorsqu'on code une macro‑définition avec les restrictions syntaxiques évoquées supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#notionPseudoConst"></a>, on parle de <strong class="title">« pseudo‑constante »</strong> parce que, même si elle permet de représenter par un identificateur une valeur constante comme une <strong>« vraie » constante déclarée</strong>, elle jouit de <strong class="specialO">propriétés fondamentalement différentes</strong>, puisqu'elle procède par expansion dans le code source et non pas par mémorisation d'une donnée lors de l'exécution.  </p>
</div><!-- important -->


<h4> Codage d'expressions constantes entières en langage <em class="mark">C</em> </h4>


<div class="complement">
<p> En langage <strong>C</strong> (mais pas en <em class="mark">C++</em>), le <strong class="title">principal intérêt</strong> de la notion de <strong>pseudo‑constante</strong> est de surmonter l'obstacle que constitue la contrainte de devoir coder obligatoirement une <strong class="defin">expression constante entière</strong> (cf. chap. C2‑II <a class="previous" href="../C2-ElementsLangage/Cc2-2_syntaxeFondamentale.html#expressionConstanteEntiere" target="_BLANK"></a>) dans certaines formes syntaxiques, en particulier pour : </p>
<ul>
  <li> les <strong>étiquettes de cas</strong> d'une bifurcation multiple <code class="prettyprint lang-c">switch</code> (cf. chap. C2‑V <a class="previous" href="../C2-ElementsLangage/Cc2-5_structuresControle.html#switchCases" target="_BLANK"></a>) ; </li>

  <li> les <strong>valeurs explicites</strong> des <strong class="specialLT">constantes entières</strong> listées dans la déclaration d'un <strong class="specialT">type énuméré</strong>, qu'il soit anonyme ou nommé (cf. chap. C3‑IV <a class="previous" href="../C3-Numeration/Cc3-4_typesEnumeres.html#valeursExplicites" target="_BLANK"></a>) ; </li>

  <li> le <strong>nombre d'éléments</strong> d'un <strong class="specialLB">tableau</strong>, aussi bien dans une déclaration de type que de donnée (cf. chap. C5‑III <a class="previous" href="../C5-StructuresPointeurs/Cc5-3_tableauxDeclarations.html#declarationTab" target="_BLANK"></a>) ; </li>

  <li> la <strong>largeur d'un champ de bits</strong> d'une <strong class="specialLB">structure hétérogène</strong>, aussi bien dans une déclaration de type ou de donnée (cf. chap. C5‑V <a class="previous" href="../C5-StructuresPointeurs/Cc5-3_tableauxDeclarations.html#declarationTab" target="_BLANK"></a>). </li>
</ul>

<p> Dans ces cas répertoriés, plutôt que de devoir coder des expressions à base de <strong class="cons">constantes littérales uniquement</strong>, on peut recourir à des <strong class="title">pseudo‑constantes</strong> dont l'expansion produira les expressions souhaitées. On parvient ainsi à une factorisation du code comme avec l'usage d'une constante déclarée. </p>
</div><!-- complement -->

<div class="expert">
<div class="exemples">
<p class="exemple"> Supposons que l'on veuille mémoriser dans un tableau les <em class="bold">100</em> premiers <strong>nombres premiers</strong>. En langage <strong>C</strong>, il est pertinent de vouloir coder la valeur <code>100</code> dans une <strong class="title">pseudo‑constante</strong>, nommée par exemple <code class="prettyprint lang-c">NUMBER_OF_PRIMES</code>, car on en aura besoin à la fois pour déclarer le tableau, et pour parcourir ses éléments avec une boucle de répétition <code class="prettyprint lang-c">for</code>. Le programme pourra donc débuter par le code ci‑dessous : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

#define NUMBER_OF_PRIMES 100

bool isNotPrime(int n);

int main(void) {
  int primes[NUMBER_OF_PRIMES] = {2, 0};
  int testedNumber = 3;
  printf("The %d first prime numbers are: \n", NUMBER_OF_PRIMES);
  printf("%4d", 2);
  for (int i = 1; i < NUMBER_OF_PRIMES; i++) { 
    // ...
</pre>
<!---------- ne pas indenter ---------->
</div><!-- exemple -->
</div><!-- expert -->


<p class="square"> Par ailleurs <strong class="title">deux autres aspects essentiels</strong> peuvent justifier de recourir à une <strong>pseudo‑constante</strong> plutôt qu'une « vraie » constante déclarée : </p>
<ul>
  <li> le <strong class="specialLB">coût mémoire</strong>, qui est a priori <strong class="pros">nul</strong> pour une pseudo‑constante (à moins que la valeur de cette dernière occupe plus de place qu'une adresse). </li>

  <li> le <strong class="specialLB">typage des valeurs</strong>, qui peut être <strong class="defin">nul</strong> ou du moins <strong class="defin">très faible</strong> pour une pseudo‑constante, avec l'avantage que cela apporte en termes de <strong class="pros">puissance d'expression</strong>, mais aussi l'inconvénient en termes de <strong class="cons">risques d'erreurs de codage</strong>. </li>
</ul>

<div class="expert">
<p> Mais ces deux aspects sont plus <strong class="warning">complexes</strong> qu'il n'y paraît et nécessitent quelques approfondissements. </p>  


<!-- expert -->
<h4 id="coutMemoirePseudoConst"> Coût mémoire </h4>


<div class="complement">
<p> La macro‑définition d'une <strong class="title">pseudo‑constante</strong> ne requiert <strong class="pros">aucun espace réservé en mémoire</strong> lors de l'<strong>exécution</strong>, ni dans les segments de données statiques (<code class="cmd">.data</code>, <code class="cmd">.rodata</code> ou <code class="cmd">.bss</code>), ni dans la pile (cf. chap. C4‑II <a class="previous" href="Cc4-2_porteeDonnees.html#allocationMemoire" target="_BLANK"></a>). Sa valeur est <strong>« disséminée » dans le code exécutable</strong> du programme (segment <code class="cmd">.text</code>) à chaque fois qu'elle est utilisée dans une expression, à la place du pointeur d'adresse qui renverrait à son espace mémoire si elle avait été déclarée comme une « vraie » constante. </p>

<p> En termes d'occupation mémoire, cette stratégie est donc a priori <strong class="pros">intéressante</strong> uniquement la valeur de la pseudo‑constante est encodée sur moins voire autant d'octets qu'un pointeur d'adresse. Mais dans le cas contraire, elle risque fort d'être <strong class="cons">contre‑productive</strong>. </p>

<p> Et en tout état de cause, elle ne se justifie que dans le cadre d'un programme développé pour une <strong>machine cible</strong> <strong class="specialO">très pauvre en mémoire</strong>, typiquement :  </p>
<ul>
  <li>  le microcontrôleur <em class="mark">Atmel ATmega328P</em> qui équipe les <strong>cartes</strong> <strong class="Arduino">Arduino Uno</strong> et <strong class="Arduino">Nano</strong> (32 ko pour le programme, 2 ko pour les données – cf. C1‑III <a class="previous" href="../C1-Generalites/Cc1-3_ArduinoTinkercad.html#carteUno" target="_BLANK"></a>) ; </li>


  <li> ou plus encore, l'<em class="mark">Atmel ATtiny85</em> (8 ko pour le programme, 512 o pour les données – cf. C1‑III <a class="previous" href="../C1-Generalites/Cc1-3_ArduinoTinkercad.html#ATtiny" target="_BLANK"></a>). </li>
</ul>
</div><!-- complement -->


<p> Par ailleurs, il importe de <strong class="defin">ne pas surestimer l'hypothétique avantage</strong> du gain d'espace en mémoire. En effet, les compilateurs des langages <strong>C</strong> et <strong>C++</strong> intègrent depuis longtemps des <strong class="defin">algorithmes d'optimisation</strong> qui peuvent mettre en œuvre le même genre de travail qu'un préprocesseur pour les <strong>constantes</strong>, c'est‑à‑dire remplacer dans le segment <code class="cmd">.text</code> les occurrences de l'identificateur de cette constante non pas par son adresse mais par sa valeur. Par conséquent, lorsque l'on déclare une constante globale, cela n'engendre le plus souvent <strong class="pros">aucune consommation d'espace mémoire</strong> dans le segment <code class="cmd">.rodata</code>. </p>

<div class="exemples">
<p class="exemple"> On peut deviner l'existence d'un tel mécanisme d'optimisation en compilant dans l'<strong><em class="sigle">IDE</em></strong><strong class="Arduino"> Arduino</strong> le programme <em class="english">blink</em> ci‑dessous (cf. chap. C2‑VIII <a class="previous" href="../C2-ElementsLangage/Cc2-8_gestionTemps.html#blinkDelay" target="_BLANK"></a>) :  </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#define blinkHalfPeriod 500              // comment to test the difference
// const uint16_t blinkHalfPeriod = 500; // uncomment to test the difference

void setup() {
  pinMode(LED_BUILTIN, OUTPUT);
}

void loop() {
  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));
  delay(blinkHalfPeriod);
}
</pre>
<!---------- ne pas indenter ---------->

<p> En effet, que l'on utilise la ligne nº 1 (macro‑définition d'une <strong>pseudo‑constante</strong>) ou la ligne nº 2 (déclaration d'une <strong>constante</strong>) pour mémoriser la valeur de la demi‑période de clignotement, <strong class="pros">aucune différence</strong> n'apparaît dans le résultat de la compilation affiché par l'<em class="sigle">IDE</em> : </p>

<!---------- ne pas indenter ---------->
<pre class="displayDark">
Le croquis utilise 960 octets (2%) de l'espace de stockage de programmes. Le maximum est de 32256 octets.
Les variables globales utilisent 9 octets (0%) de mémoire dynamique, ce qui laisse 2039 octets pour les variables locales. Le maximum est de 2048 octets.
</pre>
<!---------- ne pas indenter ---------->
<p> sachant que les 9 octets utilisés correspondent à des données cachées, présentes même avec un programme vide. </p>
</div><!-- exemple -->

<div class="remarques">
<p class="remarque"> L'<strong class="title">optimisation</strong> du code exécutable par le compilateur en traitant une constante par recopie de sa valeur dans le segment <code class="cmd">.text</code> n'est <strong class="cons">pas possible</strong> si le codeur déclare un <strong>pointeur</strong> sur cette constante (cf. chap. C5‑I <a class="next" href="../C5-StructuresPointeurs/Cc5-1_pointeursgeneralites.html" target="_BLANK"></a>). Dans ce cas, l'allocation d'un espace mémoire adressable à cette donnée est indispensable. </p>

<p> Mais en termes de comparaison avec l'emploi d'une pseudo‑constante, l'avantage qu'on pourrait avoir à utiliser cette dernière ne tient pas, puisqu'on ne peut pas déclarer un pointeur sur une pseudo‑constante… </p>
</div><!-- remarque -->


<!-- expert -->
<h4 id="typagePseudoConst"> Typage des données </h4>


<div class="complement">
<p> Contrairement à ce que pourrait penser un codeur débutant, la macro‑définition d'une pseudo‑constante laisse quand même des <strong class="pros">possibilités</strong> de <strong class="title">typage</strong> de la valeur attribuée, notamment via : </p>

<ul>
  <li> les règles de syntaxe de codage des <strong>constantes littérales</strong>, et notamment l'emploi de <strong class="defin">suffixes</strong> (cf. chap. C3‑II <a class="previous" href="../C3-Numeration/Cc3-2_typesEntiers.html#specifTypage" target="_BLANK"></a> et chap. C3‑V <a class="previous" href="../C3-Numeration/Cc3-5_typesFlottants.html#suffixe" target="_BLANK"></a>) ; </li>

  <li> l'opérateur de <strong class="defin">conversion explicite</strong> (cf. chap. C3‑VI <a class="previous" href="../C3-Numeration/Cc3-6_conversionsTypes.html#cast" target="_BLANK"></a>). </li>
</ul>

<p> Mais en l'absence de typage explicite, une constante littérale est a priori compilée dans le <strong class="specialG">type standard</strong> par <strong>défaut</strong> ou <strong>compatible</strong> avec sa valeur, et il en va de même pour une expression (cf. chap. C3‑VI <a class="previous" href="../C3-Numeration/Cc3-6_conversionsTypes.html" target="_BLANK"></a>). </p>
</div><!-- complement -->

<p> Le fait de laisser au codeur le choix de typer ou non la valeur d'une pseudo‑constante apporte une <strong class="title">puissance d'expression</strong> qui peut être vue comme un <strong class="pros">avantage</strong> mais aussi un <strong class="cons">inconvénient</strong>. En effet, la versatilité du type d'une donnée est potentiellement porteuse d'une <strong class="warning">ambiguïté</strong>.  </p>


<div class="exemples">
<p class="exemple"> Dans le code <strong class="cons">maladroit</strong> ci‑dessous : </p>  

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:5">
#define NOMINAL_VOLTAGE  13
#define STARTING_VOLTAGE (NOMINAL_VOLTAGE / 2)
</pre>
<!---------- ne pas indenter ---------->

<p> le codeur a <strong class="warning">oublié</strong> de coder les points décimaux « de précaution », notamment à la valeur de la <strong class="title">pseudo‑constante</strong> <code class="prettyprint lang-c">NOMINAL_VOLTAGE</code> (il aurait dû coder <code class="prettyprint lang-c">13.0</code>). Il en résulte que la pseudo‑constante <code class="prettyprint lang-c">STARTING_VOLTAGE</code> prend, après expansion des macro‑définitions, la <strong>valeur entière</strong> <code class="prettyprint lang-c">6</code> et non pas la <strong>valeur décimale</strong> <code class="prettyprint lang-c">6.5</code> qu'il est logique d'attendre, étant donné ce que cette pseudo‑constante est censée représenter – une tension, donc fondamentalement un <strong>nombre décimal</strong>.  </p>

<p> Une telle <strong class="warning">erreur</strong> serait <strong class="pros">évitée</strong> en recourant à une <strong class="title">« vraie » constante déclarée</strong> comme par exemple ci‑dessous : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:5">
const double NOMINAL_VOLTAGE = 13;
const double STARTING_VOLTAGE = NOMINAL_VOLTAGE / 2;
</pre>
<!---------- ne pas indenter ---------->

<p> En effet, même en l'absence des points décimaux dans les constantes littérales <code class="prettyprint lang-c">13</code> et <code class="prettyprint lang-c">2</code>, la <code class="prettyprint lang-c">STARTING_VOLTAGE</code> prend la valeur <code class="prettyprint lang-c">6.5</code> car dans l'expression <code class="prettyprint lang-c">NOMINAL_VOLTAGE / 2</code>, la constante <code class="prettyprint lang-c">NOMINAL_VOLTAGE</code> <strong class="defin">impose son type décimal</strong> et conduit le compilateur à une <strong class="pros">évaluation correcte</strong>. </p>
</div><!-- exemple -->


<!-- expert -->
<h4> Retour d'expérience sur l'emploi des pseudo‑constantes </h4>


<p> Historiquement, l'emploi des macro‑définitions de <strong class="title">pseudo‑constantes</strong> a toujours été très fréquent dans les programmes codés en langage <strong class="title">C</strong>. Malgré le peu d'avantages qu'apporte aujourd'hui cette technique compte tenu des mécanismes d'optimisation mis en œuvre par les compilateurs, elle reste appréciée des codeurs en raison de sa <strong class="pros">commodité</strong>, et sans doute aussi parce que les <strong class="warning">risques</strong> qu'elle présente sont <strong>sous‑estimés</strong>… et que les habitudes ont la vie dure. </p>

<div class="complement">
<p> En revanche, les spécialistes du <strong class="title">C++</strong> sont nettement <strong class="cons">moins enthousiastes</strong>. Ils savent que le développement de ce langage a aussi été l'occasion de <strong class="pros">corriger les défauts</strong> du langage <strong>C</strong> pour pouvoir se passer des macro‑définitions. Sauf cas particuliers, ils préfèrent de loin la déclaration de « vraies » <strong class="specialG">constantes typées</strong>. </p>
</div><!-- complement -->
</div><!-- expert -->



<h3 id="pseudoConstPredef"> Pseudo‑constantes prédéfinies </h3>


<div class="important">
<p> En langages <strong>C</strong> et <strong>C++</strong>, plus d'une <strong class="specialLB">centaine de pseudo‑constantes</strong> sont <strong class="title">prédéfinies</strong> pour permettre au codeur de récupérer des valeurs de <strong>variables d'environnement</strong>. Leur <strong class="specialG">identificateur</strong> est presque toujours de la forme <code class="prettyprint lang-c">__<span class="nocode"><strong style="color: green">NOM-EN-MAJUSCULES</strong></span>__</code>. </p>

<div class="expert">
<p> Ces pseudo‑constantes ne font pas explicitement partie du noyau du langage puisque leur valeur dépend du contexte, mais elles sont néanmoins <strong>utilisables</strong> <strong class="pros">sans requérir une directive d'inclusion</strong> de fichiers de bibliothèque. Elles sont incluses par le préprocesseur dans le code source via des <strong class="defin">fichiers virtuels</strong> (cf. supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#exempleMarquesLignes"></a>). </p>
</div><!-- expert -->
</div><!-- important -->


<div class="complement">
<p> Parmi ces <strong class="title">pseudo‑constantes prédéfinies</strong>, on distingue <strong>3 catégories</strong> dites <strong class="specialLB">standards</strong>, <strong class="specialLB">communes</strong> et <strong class="specialLB">spécifiques</strong>.  </p>
</div><!-- complement -->

<div class="expert">
<ol class="numbered">
  <li> Parmi les pseudo‑constantes prédéfinies <strong class="specialLB">standards</strong> aux langages <strong>C</strong> et <strong>C++</strong>, on trouve notamment : </li>
  <ul>
    <li> <code class="prettyprint lang-c">__STDC_VERSION__</code> et <code class="prettyprint lang-c">__cplusplus</code> qui donnent la <strong>version du langage</strong> employé (on les a déjà présentées au chap. C1‑II <a class="previous" href="../C1-Generalites/Cc1-2_langagesCetCpp.html#varEnvVersion" target="_BLANK"></a>) ; </li>

    <li> <code class="prettyprint lang-c">__DATE__</code> et <code class="prettyprint lang-c">__TIME__</code> qui donnent, sous la forme d'une chaîne de caractères formatée, respectivement la <strong>date</strong> et l'<strong>heure</strong> de compilation du programme (informations données par le système d'exploitation du poste de travail) ; </li>

    <li> <code class="prettyprint lang-c">__FILE__</code> et <code class="prettyprint lang-c">__LINE__</code> qui donnent respectivement le <strong>chemin absolu du fichier</strong> en cours de compilation sous la forme d'une chaîne de caractères et le <strong>numéro de ligne</strong> courant dans ce fichier sous la forme d'un entier.  </li>
  </ul>

  <li> Les pseudo‑constantes prédéfinies <strong class="specialLB">communes</strong> dépendent de la <strong>chaîne de compilation utilisée</strong> et de la <strong>machine cible</strong>. Très nombreuses, elles permettent notamment de caractériser les types de données utilisables. </li>

  <div class="nobullet"> Par exemple, on trouve la pseudo‑constante <code class="prettyprint lang-c">__FLT_MIN__</code> qui donne, pour la machine cible, la plus petite valeur des données de type <code class="prettyprint lang-c">float</code>. C'est la valeur de cette variable d'environnement qui permet ensuite de définir la pseudo‑constante <code class="prettyprint lang-c">FLT_MIN</code> dans le fichier d'en‑tête <code class="filename">float.h</code> <a class="external" href="https://sites.uclouvain.be/SystInfo/usr/include/float.h.html" target="_BLANK">C</a> de la bibliothèque standard du langage <em class="mark">C</em> (cf. chap. C3‑V <a class="previous" href="../C3-Numeration/Cc3-5_typesFlottants.html#caracteristiques" target="_BLANK"></a>) : </div>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c">
#define FLT_MIN                __FLT_MIN__
</pre>
<!---------- ne pas indenter ---------->

  <li> Les <strong>pseudo‑constantes prédéfinies</strong> <strong class="specialLB">spécifiques</strong> à la <strong>machine cible</strong> permettent d'identifier cette dernière, notamment son s<strong>ystème d'exploitation </strong>pour coder des programmes portables via des directives de compilation conditionnelle (cf. infra <a class="infra" href="Cc4-3_directivesPreprocesseur.html#compilCondi"></a>). </li>

  <div class="nobullet"> Par exemple, la pseudo‑constante <code class="prettyprint lang-c">__linux__</code> est prédéfinie et prend la valeur <code class="prettyprint lang-c">1</code> en compilation native sur un poste de travail disposant d'un système d'exploitation <strong>Linux</strong>.   </div>
</ol><!-- numbered -->

<p> Sur un poste de travail, on peut obtenir la <strong class="title">liste exhaustive</strong> de toutes les <strong class="specialLB">pseudo‑constantes prédéfinies</strong> par le préprocesseur <strong>CPP</strong> pour un fichier source donné via la commande : <br>
<span class="inline">
  <code>cpp -dM <span class="nocode"><em>fichier source</em></span></code> 
</span> <br>
le mnémonique de l'option <code>-dM</code> étant « <em class="english">defined macros</em> ». </p>
</div><!-- expert -->


























<h2 id="macrocommandes"> Macro‑définition d'une pseudo‑fonction </h2>



<h3 id="notionPseudoFonct"> Notion de pseudo‑fonction </h3>



<div class="important">
<p> Supra <a class="supra" href="http://www.lycee-ferry-versailles.fr/snir/ModuleC/C4-Fonctions/emploiMacros"></a>, on a vu que la syntaxe de la directive <code class="prettyprint lang-c">#define</code> accepte la <strong class="specialLB">notion d'argument</strong>, comme dans une fonction (cf. chap. C4‑I <a class="previous" href="Cc4-1_fonctionsGeneralites.html#aspectsFondamentaux" target="_BLANK"></a>). On parle alors de <strong class="title">pseudo‑fonction</strong> dans la mesure où il y <strong>quelques différences</strong> subtiles avec la notion de « vraie » fonction mais que par ailleurs, on y retrouve de <strong>nombreuses similitudes</strong> dans les concepts sous‑jacents (arguments formels, effectifs, etc.). </p>
</div><!-- important -->


<div class="complementExpert">
<p> En effet, dans la macro‑définition d'une <strong class="title">pseudo‑fonction</strong>, par <strong class="defin">analogie</strong>, on peut considérer :  </p>   

<ul>
  <li> que la <strong>ligne de contrôle</strong> d'une telle directive constitue la <strong class="defin">définition</strong> de la pseudo‑fonction, où : </li>
  
  <ul>
    <li> l'<strong class="specialLG">expression d'identification</strong> joue le rôle d'<strong>en‑tête</strong>, dans laquelle on retrouve un <strong class="specialG">identificateur</strong> suivi d'une <strong>liste</strong> d'<strong class="specialT">arguments formels</strong>, mais <strong class="warning">sans typage</strong> ; </li>

    <li> la <strong class="specialLB">chaîne de substitution</strong> joue le rôle de <strong>corps de définition</strong> de la pseudo‑fonction – avec beaucoup moins de contrainte syntaxiques, bien sûr –, et où l'on peut insérer autant d'occurrences que voulu des <strong class="specialLB">arguments formels</strong> listés dans l'expression d'identification ; </li>
  </ul>

  <li> que dans la suite du code, toute occurrence de l'<strong class="specialG">identificateur</strong> de la pseudo‑fonction peut alors être associée à des expressions formant ses <strong class="specialO">arguments effectifs</strong> – il doit y en avoir <strong>autant</strong> que d'<strong class="specialT">arguments formels</strong> – dans ce qui s'apparente à une expression d'<strong class="defin">appel</strong> – ou d'<strong class="defin">invocation</strong> – de la pseudo‑fonction ; </li>

  <div class="nobullet"> sachant que la <strong class="defin">transmission</strong> des arguments effectifs aux arguments formels ne procède ni par valeur, ni par adresses ou références, mais par <strong class="warning">substitution</strong>. </div>
</ul>

<p> On adoptera donc ce vocabulaire d'« <strong class="specialT">argument formel</strong> » et d'« <strong class="specialO">argument effectif</strong> » relatif aux vraies fonctions tout en ayant bien conscience des différences qui existe (absence de typage, transmission par substitution). </p>
</div><!-- complementExpert -->



<h3 id="syntaxePseudoFonct"> Syntaxe de codage d'une macro‑définition de pseudo‑fonction </h3>



<div class="important">
<p> On code la macro‑définition d'une <strong class="title">pseudo‑fonction</strong> par une directive <code class="prettyprint lang-c">#define</code> respectant la forme syntaxique suivante : <br>
<span class="inline">	
	<code class="prettyprint lang-c">#define 
		<span class="nocode"><strong class="specialG">identificateur</strong></span>(<span class="nocode"><strong class="specialT">argument formel 1</strong></span>, 
		<span class="nocode"><strong class="specialT">argument formel 2</strong></span>,
		<span class="nocode"><strong>…</strong></span> )
		<span class="nocode"><strong class="specialN">chaîne de substitution</strong></span>
	</code>
</span> <br>
où les <strong class="specialT">arguments formels</strong> sont simplement des <strong>identificateurs</strong> <strong class="warning">sans typage</strong>, et dont la « portée » se réduit à la chaîne de substitution de la macro‑définition. </p>
</div><!-- important -->


<div class="complement">
<p> Bien que simple en apparence, cette syntaxe récelle <strong class="warning">plusieurs subtilités</strong>. </p>  
<p class="square"> Contrairement au codage d'une fonction, une <strong class="specialLG">expression d'identification</strong> n'est pas à format libre : le codeur ne peut placer <strong class="warning">aucun espace</strong> entre l'<strong class="specialG">identificateur</strong> et la <strong>parenthèse ouvrante</strong> <code class="prettyprint lang-c">(</code> de la liste des arguments formels. Sinon, cet espace serait reconnu par le préprocesseur comme le séparateur entre l'expression d'identification et la chaîne de substitution et alors, la liste des arguments formels serait intégrée à cette dernière, générant quasi‑certainement un code non compilable ! </p>

<p> En revanche, comme pour une fonction, la <strong class="title">liste</strong> des <strong class="specialT">arguments formels</strong> peut éventuellement être <strong class="defin">vide</strong>, c'est‑à‑dire codée de la forme <code class="prettyprint lang-c">()</code> si la pseudo‑fonction n'emploie pas d'arguments. </p>

<div class="expert">
<p> Mêmes vides, les <strong class="title">parenthèses</strong> joue un rôle syntaxique déterminant : elles permettent au préprocesseur d'identifier une macro‑définition de <strong class="defin">pseudo‑fonction</strong> et non <strong class="warning">pas</strong> de <strong>pseudo‑constante</strong>. On verra infra <a class="infra" href="Cc4-3_directivesPreprocesseur.html#particularitesExpansionPseudoFonct"></a> que les <strong>règles d'expansion</strong> ne sont <strong class="warning">pas les mêmes</strong> pour ces deux catégories de macro‑définitions. </p>
</div><!-- expert -->

<p class="square"> Quant à la <strong class="specialN">chaîne de substitution</strong>, elle ne répond à <strong class="defin">aucune contrainte syntaxique</strong> en matière de <strong class="title">délimiteurs</strong> (accolades non obligatoires, parenthésage pas forcément équilibrés, etc.). Mais en règle générale, on encapsule cette chaîne de substitution : </p>

<ul>
  <li> <strong class="title">entre parenthèses</strong> <code class="prettyprint lang-c">( )</code> si la pseudo‑fonction est codée dans la perspective d'être invoquée <strong class="defin">au sein d'expressions</strong> (comme une « vraie » fonction qui <strong>retourne une valeur</strong>), en vertu des mêmes règles que pour une pseudo‑constante (cf. supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#parentheses"></a>) ; </li>

  <div class="nobullet"> de plus, il est vivement recommandé d'encapsuler entre parenthèses chaque <strong>occurrence</strong> de chaque <strong class="title">argument formel</strong>, dans la mesure où son <strong class="specialO">argument effectif</strong> correspondant peut éventuellement être une <strong>expression composée d'opérateurs</strong> qui, après expansion, devra être <strong class="pros">évaluée avant</strong> que les opérateurs codés dans la chaîne de substitution n'interviennent ; </div>

  <li> dans une <strong class="title">structure de contrôle</strong> <code class="prettyprint lang-c">do { } while (0)</code> (cf. chap. C2‑V <a class="previous" href="../C2-ElementsLangage/Cc2-5_structuresControle.html#doWhile" target="_BLANK"></a>, mais attention, <strong class="warning">sans séparateur</strong> <code class="prettyprint lang-c">;</code> à la fin) si la pseudo‑fonction est codée dans la perspective d'être invoquée <strong class="defin">seule dans une instruction</strong>, comme une fonction de <strong>type</strong> <code class="prettyprint lang-c">void</code>.  </li>

  <div class="expert"> 
  <div class="nobullet"> (Cette structure de contrôle garantit l'exécution de son bloc <strong>une et une seule fois</strong>. Elle permet d'éviter la présence indésirable d'une <strong class="cons">instruction vide</strong> à chaque fin d'expansion de la macro – cf. la section <em class="english">Swallowing the semicolon</em> de la notice de <strong>CPP</strong> <a class="external" href="https://gcc.gnu.org/onlinedocs/cpp/Swallowing-the-Semicolon.html" target="_BLANK"></a>.) </div> 
  </div><!-- expert -->
</ul>

<p> En dehors de ces deux emplois usuels, et notamment si la pseudo‑fonction est codée dans la perspective d'être invoquée dans une <strong class="defin">déclaration</strong>, aucune règle générale ne se dégage : c'est <strong>au cas par cas</strong> qu'on doit s'assurer de la validité du code généré après l'expansion de sa macro‑définition. </p>
</div><!-- complement -->


<div class="exemples" id="exemplesPseudoFonction"><p class="exemples"></p>
<ol class="numbered">
  <li> Dans le fichier d'en‑tête <code class="filename">Arduino.h</code> <a class="external" href="https://github.com/arduino/ArduinoCore-avr/blob/master/cores/arduino/Arduino.h" target="_BLANK"></a> pour cartes à cœur <strong><em class="sigle">AVR</em></strong>, on trouve la macro‑définition : </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:99">
#define sq(x) ((x)*(x))
</pre>
<!---------- ne pas indenter ---------->

<div class="nobullet"> Cette directive définit une pseudo‑fonction nommée <code class="prettyprint lang-c">sq</code> (abréviation de l'anglais <em class="english">square</em>) : </div>

<ul>
  <li> qui admet un <strong class="specialT">argument formel</strong> nommé <code class="prettyprint lang-c">x</code> ; </li>

  <li> dont la <strong class="specialN">chaîne de substitution</strong> <code class="prettyprint lang-c">((x)*(x))</code> utilise deux occurrences de son argument (elle consiste en la multiplication de <code class="prettyprint lang-c">x</code> par <code class="prettyprint lang-c">x</code>) ; </li>
</ul>

<div class="nobullet"> Elle est codée dans la perspective d'être invoquée <strong class="defin">au sein d'expressions</strong>, d'où l'<strong>encapsulation globale</strong> entre parenthèses ainsi que l'encapsulation individuelle de chacune des deux occurrences de l'argument formel. </div>

<div class="expert">
<p style="margin-top: 1em"> <em class="remark">Remarque</em>. Cette façon simple d'<strong>élever au carré</strong> son argument présente l'<strong class="pros">avantage</strong> de ne pas recourir à une fonction <em>puissance</em> de la bibliothèque standard, mais présente aussi un <strong class="cons">inconvénient</strong> en termes d'effet de bord (cf. infra <a class="infra" href="Cc4-3_directivesPreprocesseur.html"></a>) </p></p>
</div><!-- expert -->

  <li style="margin-top: 1em;"> Pour implémenter une procédure de <strong>permutation des valeurs de deux variables</strong>, la macro‑définition codée ci‑dessous aux lignes nº 3 à 6 peut constituer une bonne alternative à la solution proposée au cf. chap. C4‑I <a class="previous" href="Cc4-1_fonctionsGeneralites.html#transmissionReferenceSyntaxe" target="_BLANK"></a> : </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:3">
#define swapValues(a, b) do { \
  double c = a; \
  a = b, b = c; \
} while (0) 
</pre>
<!---------- ne pas indenter ---------->

  <div class="nobullet"> Elle est codée dans la perspective d'être invoquée <strong class="defin">seule dans une instruction</strong>, d'où l'encapsulation dans la structure de contrôle <code class="prettyprint lang-c">do { } while (0)</code>. </div>

  <div class="expert">
  <div class="nobullet"> Remarquons qu'ici, les occurrences des <strong class="specialT">arguments formels</strong> <code class="prettyprint lang-c">a</code> et <code class="prettyprint lang-c">b</code> ne sont <strong class="warning">pas encapsulés</strong> entre parenthèses. En effet, les opérateurs utilisés ici (<code class="prettyprint lang-c">=</code> et <code class="prettyprint lang-c"> ,</code>) ont les rangs de priorité les plus <strong>bas</strong> (respectivement 14 et 15 – cf. chap. C2‑IV <a class="previous" href="../C2-ElementsLangage/Cc2-4_manipulationDonnees.html#priorites" target="_BLANK"></a>) et dans une expression d'invocation de la pseudo‑fonction, les <strong class="specialO">arguments effectifs</strong> ne peuvent être qu'atomiques ou composés d'opérateurs à très hauts rangs de priorité (typiquement, l'opérateur de déréférencement <code class="prettyprint lang-c">*</code> – cf. chap. C5‑I <a class="previous" href="../C5-StructuresPointeurs/Cc5-1_pointeursGeneralites.html#operDeref" target="_BLANK"></a>). </div>
  </div><!-- expert -->
</ol><!-- numbered -->  
</div><!-- exemple -->



<h3 id="invocation"> Invocation d'une macro‑définition de pseudo‑fonction </h3>



<div class="important">
<p> Après sa macro‑définition, une <strong>pseudo‑fonction</strong> peut être <strong class="title">invoquée</strong> dans le code source, à chaque fois que nécessaire, par une <strong class="defin">expression</strong> de la forme : <br>
<span class="inline"> 
  <code class="prettyprint lang-c"><span class="nocode"><strong class="specialG">identificateur</strong></span> (<span class="nocode"><strong class="specialO">argument effectif 1</strong></span>, 
    <span class="nocode"><strong class="specialO">argument effectif 2</strong></span>,
    <span class="nocode"><strong>…</strong></span> )
  </code>
</span> <br>
où les <strong class="specialO">arguments effectifs</strong> sont des <strong>expressions</strong> correspondant aux <strong class="specialT">arguments formels</strong> codés dans l'expression d'identification de la macro‑définition, dans l'ordre de leurs positions respectives. </p>

<p> Contrairement une expression d'identifiction, une expression d'invocation est à <strong class="pros">format libre</strong> : elle peut notamment être codée avec un voire des <strong>séparateurs blancs</strong> entre l'identificateur et la liste d'arguments effectifs. </p>
</div><!-- important -->


<div class="complement">
<p> À chaque <strong>invocation</strong>, le préprocesseur effectue l'<strong class="title">expansion</strong> de la macro‑définition en remplaçant l'<strong class="defin">expression</strong> par sa <strong class="specialN">chaîne de substitution</strong>, dans laquelle chaque occurrence d'un <strong class="specialT">argument formel</strong> est préalablement remplacée par son <strong class="specialO">argument effectif</strong> correspondant. </p>

<p> Il doit y avoir <strong class="warning">impérativement</strong> le <strong class="defin">même nombre</strong> d'<strong class="specialO">arguments effectifs</strong> dans l'expression d'invocation que d'<strong class="specialT">arguments formels</strong> dans l'expression d'identification de la macro‑définition, faute de quoi le préprocesseur signale une erreur bloquante pour la chaîne de compilation. </p>

<div class="expert">
<p> Néanmoins, dans une expression d'invocation, il reste possible de coder un voire plusieurs <strong class="title">arguments effectifs vides</strong>, du moment que occurrences attendues des séparateurs <code class="prettyprint lang-c">,</code> sont saisies. Mais cette permissivité du préprocesseur ne garantit pas pour autant que le code qu'il génère soit ensuite compilable. </p> 
</div><!-- expert -->

<p> Par ailleurs, si une pseudo‑fonction code dans sa chaîne de substitution une <strong class="warning">affectation</strong> (simple ou composée – cf. chap. C2‑IV <a class="previous" href="../C2-ElementsLangage/Cc2-4_manipulationDonnees.html#compoundOperators" target="_BLANK"></a>) sur un <strong class="specialT">argument formel</strong>, alors son <strong class="specialO">argument effectif</strong> correspondant dans une invocation doit impérativement être une <strong>l‑value</strong>, un peu comme pour une fonction codée en transmission par référence (cf. chap. C4‑I <a class="previous" href="Cc4-1_fonctionsGeneralites.html#transmissionReferenceSyntaxe" target="_BLANK"></a>) mais avec une contrainte de typage moins forte (il suffit que l'affectation soit acceptable par le compilateur). </p>
</div><!-- complement -->


<div class="exemples"><p class="exemples"></p>
<ol class="numbered">
  <li> Dans un fichier source d'un programme pour carte <em class="mark">Arduino</em> (où est par défaut inclus le fichier d'en‑tête <code class="filename">Arduino.h</code> qui comporte la macro‑définition de la pseudo‑fonction <code class="prettyprint lang-c">sq</code> présentée supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#exemplesPseudoFonction"></a>) : </li>
  <ul>
    <li> une expression d'<strong>invocation</strong> comme par exemple <code class="prettyprint lang-c">sq(5.0)</code> serait remplacée par le préprocesseur par l'expression : <br>
    <span class="inline">
      <code class="prettyprint lang-c">((5.0)*(5.0))</code>
    </span> <br>  
    puis serait par défaut compilée comme étant de type <code class="prettyprint lang-c">double</code> (cf. chap. C3‑VI <a class="previous" href="../C3-Numeration/Cc3-6_conversionsTypes.html#promotionsSystematiques" target="_BLANK"></a>) ; </li>

    <li> une expression d'<strong>invocation</strong> comme par exemple <code class="prettyprint lang-c">sq(2 + 3)</code> serait remplacée par le préprocesseur par l'expression : <br>
    <span class="inline">
      <code class="prettyprint lang-c">((2 + 3)*(2 + 3))</code>
    </span> <br>  
    puis serait par défaut compilée comme étant de type <code class="prettyprint lang-c">int</code>.  </li>
  </ul>

  <div class="nobullet"> Dans ces deux cas, ces expressions seront évaluées – soit par le compilateur, soit lors de l'exécution – en prenant l'une comme l'autre la valeur <em class="bold">25</em>. </div>

  <div class="expert">
  <div class="nobullet"> <em class="remark">Remarque</em> : si, dans la chaîne de substitution de <code class="prettyprint lang-c">sq</code>, les occurrences de l'argument formel <code class="prettyprint lang-c">x</code> n'étaient pas encapsulées dans des parenthèses, alors l'expansion de <code class="prettyprint lang-c">sq(2 + 3)</code> donnerait le code : <br>
  <span class="inline">
    <code class="prettyprint lang-c">(2 + 3*2 + 3)</code>
  </span> <br>  
  et serait ensuite évaluée <em class="bold" style="color: red">11</em> ! </div>  
  </div><!-- expert -->   

  <li style="margin-top: 1em;" id="usingSwapValues"> Le programme ci‑dessous invoque la pseudo‑fonction <code class="prettyprint lang-c">swapValues</code> présentée supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#exemplesPseudoFonction"></a>) deux fois, d'abord avec des arguments effectifs de type <code class="prettyprint lang-c">float</code>, puis de type <code class="prettyprint lang-c">int</code>.  </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;

#define swapValues(a, b) do { \
  double c = a; \
  a = b, b = c; \
} while (0) 

int main(void) { 
  float x = 1.0, y = 2.0;
  swapValues(x, y);
  printf("After swap: x = %g   y = %g\n", x, y);
  printf("\n");

  int u = 1, v = 2;
  swapValues(u, v);
  printf("After swap: u = %d   v = %d\n", u, v);
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->
 
  <div class="expert">
  <div class="nobullet"> Il est intéressant de consulter ce que devient la fonction <code class="prettyprint lang-c">main</code> le <strong class="specialSG">fichier prétraité</strong> engendré par la commande <code class="cmd">cpp</code> : </div>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:734">
int main(void) {
  float x = 1.0, y = 2.0;
  do { double c = x; x = y, y = c; } while (0);
  printf("After swap: x = %g   y = %g\n", x, y);
  printf("\n");

  int u = 1, v = 2;
  do { double c = u; u = v, v = c; } while (0);
  printf("After swap: u = %d   v = %d\n", u, v);
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->  

  <div class="nobullet"> À la fin des lignes nº 736 & 741, on observe que, conformément à la syntaxe de la boucle <code class="prettyprint lang-c">do<span class="nocode">…</span> while</code>, un séparateur <code class="prettyprint lang-c">;</code> est bien présent pour compléter l'expansion de la macro‑définition de <code class="prettyprint lang-c">swapValues</code> ou ce séparateur final n'est pas codé. Il provient respectivement des fins de lignes nº 10 & 15 du fichier source (il ne fait pas partie des expressions d'invocation de swapValue, donc il est laissé tel quel dans le fichier prétraité). </div>
  </div><!-- expert -->
</ol><!-- numbered -->
</div><!-- exemple -->

<div class="remarques">
<p class="remarque"> Dès lors qu'une pseudo‑fonction emploie une <strong class="title">donnée locale</strong>, comme la variable tampon <code class="prettyprint lang-c">c</code> déclarée à la ligne nº 4 dans l'exemple <em class="bold">2)</em> supra, sa chaîne de susbtitution doit <strong class="warning">impérativement</strong> être encapsulée dans un <strong class="defin">bloc</strong>. Sinon, la deuxième invocation de cette pseudo‑fonction dans un même bloc va inévitablement produire un code <strong class="cons">non compilable</strong> après expansion, puisque le même identificateur de donnée sera déclaré deux fois. </p>

<p> C'est exactement ce qui se passerait si on codait la pseudo‑fonction <code class="prettyprint lang-c">swapValues</code> comme ci‑dessous, pour tenter maladroitement d'éviter la structure <code class="prettyprint lang-c">do { } while (0)</code> : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:3">
#define swapValues(a, b) \
  double c = a; \
  a = b, b = c   // macro badly coded without braces! 
</pre>
<!---------- ne pas indenter ---------->

<p> Dans le bloc de la fonction <code class="prettyprint lang-c">main</code> du programme précédent, on aurait <strong class="cons">deux déclarations</strong> de la même variable <code class="prettyprint lang-c">double c = <span class="nocode">…</span></code> ce que le compilateur ne manquerait pas de signaler comme une <strong class="warning">erreur</strong>. </p>
</div><!-- remarque -->



<div class="expert">
<h3> Particularités d'expansion d'une macro‑définition de pseudo‑fonction </h3>



<p> On a évoqué supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#syntaxePseudoFonct"></a> le fait que les <strong class="title">règles d'expansion</strong> ne sont <strong class="warning">pas les mêmes</strong> pour une <strong class="defin">pseudo‑fonction</strong> que pour une <strong>pseudo‑constante</strong>. </p>


<div class="complement">
<p> En effet, une <strong class="title">pseudo‑fonction</strong> est un objet potentiellement <strong class="warning">beaucoup plus complexe</strong> qu'une <strong>pseudo‑constante</strong>. </p>

<p class="square"> Tout d'abord, il y a le fait qu'une pseudo‑fonction admet des <strong class="specialT">arguments formels</strong> qui eux‑mêmes font l'objet d'expansion par leurs <strong class="specialO">arguments effectifs</strong> correspondants. </p>

<p> De plus, <em class="remark">sauf en cas d'emploi d'opérateurs spéciaux</em>, si les <strong class="title">arguments effectifs</strong> sont eux‑même composés avec d'autres macro‑définitions, l'expansion de ces dernières est traitée par le préprocesseur <strong class="warning">avant</strong> celle des arguments formels. </p>


<p class="square"> Ensuite, les pseudo‑fonctions bénéficient de <strong class="specialLB">deux opérateurs spéciaux</strong>, codés respectivement par <code class="prettyprint lang-c">#</code> et <code class="prettyprint lang-c">##</code>, qui répondent à des règles d'expansion différentes.  </p>
</div><!-- complement -->


<!-- expert -->
<h4> Invocation d'une pseudo‑fonction sans expansion </h4>
  

<div class="complement">
<p> Une expression d'invocation de <strong>pseudo‑fonction</strong> fait l'objet d'une <strong class="specialLB">expansion</strong> <strong class="warning">seulement</strong> si son identificateur est suivi d'une liste d'arguments effectifs encapsulée <strong class="defin">entre parenthèses</strong> <code class="prettyprint lang-c">( )</code>, sachant que la liste peut éventuellement être vide et séparée de l'identificateur par des espaces. </p>

<p> En revanche, l'<strong class="warning">absence de liste entre parenthèses</strong> codée après l'identificateur conduit le préprocesseur à transmettre ce dernier tel quel au compilateur, c'est‑à‑dire <strong class="title">sans expansion</strong>. </p>
</div><!-- complement -->


<p> Bien évidemment, pour qu'une telle <strong class="title">invocation sans expansion</strong> soit ensuite compilable, il faut que cet identificateur fasse par ailleurs l'objet d'une déclaration. Typiquement, on déclare (et on définit) une <strong class="specialLB">fonction homonyme</strong>, en surchargeant l'identificateur de la pseudo‑fonction (cf. supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#surcharge"></a>). Dès lors, on peut : </p>
<ul>
  <li> soit invoquer cette pseudo‑fonction par son <strong>identificateur suivi de parenthèses</strong> ; le préprocesseur procède alors à l'expansion de la macro‑définition et de ses éventuels arguments comme dans tous les exemples présentés jusqu'ici ;  </li>

  <li> soit appeler sa fonction homonyme par son <strong class="specialG">identificateur</strong> <strong class="title">seul</strong> qui, laissé tel quel par le préprocesseur, est compilé en <strong class="specialM">pointeur de fonction</strong> (cf. chap. C5‑II <a class="external" href="../C5-StructuresPointeurs/Cc5-2_pointeursApplications.html#pointeurFonction" target="_BLANK"></a>). </li>
</ul>


<!-- expert -->
<h4> Opérateur de conversion en chaîne de caractères d'un argument  </h4>


<div class="complement">
<p> Rappelons qu'il n'y a <strong class="defin">pas d'expansion</strong> de l'occurrence d'un <strong class="specialG">identificateur</strong> de macro‑définition codé au sein d'une <strong>chaîne de caractères</strong> <a class="supra" href="Cc4-3_directivesPreprocesseur.html#occurrencesExpansion"></a>. Dans la chaîne de substitution d'une pseudo‑fonction, il en va de même pour un identificateur d'<strong class="specialT">argument formel</strong> : si ce dernier est codé <strong>dans une chaîne de caractères</strong>, il ne sera pas reconnu en qualité d'identificateur par le préprocesseur, mais seulement comme une portion de cette chaîne. </p>

<p> En conséquence, il n'est <strong class="warning">pas possible</strong> de coder comme ci‑dessous la macro‑définition d'une pseudo‑fonction qu'on nommerait par exemple <code class="prettyprint lang-c">str</code> et dont le rôle serait de créér une chaîne de caractères à partir d'un argument : <br> 
<span class="inline">
  <code class="prettyprint lang-c" style="background: lightgrey;">#define str(s) "s" // do not work! </code> 
</span> <br>
parce que dans sa chaîne de substitution <code class="prettyprint lang-c" style="background: lightgrey;">"s"</code>, l'occurence du caractère <code class="cmd" style="background: lightgrey; color: darkorange;">s</code> n'est <strong class="warning">pas reconnue</strong> comme l'<strong class="specialT">argument formel</strong> <code class="prettyprint lang-c" style="background: lightgrey;">s</code> de la pseudo‑fonction. Autrement dit, l'expansion de cette macro‑définition résulterait invariablement en la chaîne de caractères <code class="prettyprint lang-c" style="background: lightgrey;">"s"</code> quel quel soit la valeur de l'<strong class="specialO">argument effectif</strong> correspondant à <code class="prettyprint lang-c" style="background: lightgrey;">s</code> dans une expression d'invocation de cette pseudo‑fonction. </p>
</div><!-- complement -->

<div class="important">
<p> Pour qu'une pseudo‑fonction puisse <strong class="defin">opérer sur une chaîne de caractère</strong>, le préprocesseur met justement à disposition du codeur l'<strong class="title">opérateur unaire</strong> <code class="prettyprint lang-c">#</code> – en anglais <strong>stringizing operator</strong>, difficile à traduire littéralement en français. </p>

<p> Codé devant l'occurrence d'un identificateur d'<strong class="specialT">argument formel</strong> dans la chaîne de subtitution d'une pseudo‑fonction, il conduit le préprocesseur à lui substituer son <strong class="specialO">argument effectif</strong> correspondant dans une expression d'invocation, <strong class="defin">encapsulé</strong> dans une <strong>paire de délimiteurs</strong> <code class="prettyprint lang-c">" "</code>, autrement dit comme une <strong>chaîne de caractère</strong>.  </p>
</div><!-- important -->


<div class="exemples"><p class="exemples"></p>
<ol class="numbered">
  <li> La pseudo‑fonction <code class="prettyprint lang-c">str</code> évoquée ci‑dessus se code tout simplement : <br> 
  <span class="inline">
    <code class="prettyprint lang-c">#define str(s) #s // OK! </code> 
  </span> </li>

  <li> Reprenons le programme d'essai de la pseudo‑fonction <code class="prettyprint lang-c">swapValue</code> proposé supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#usingSwapValues"></a>. Grâce à l'<strong>opérateur</strong> « <strong class="title">stringizing</strong> », plutôt que de répéter l'instruction d'affichage du résultat dans le corps de la fonction <code class="prettyprint lang-c">main</code>, on peut la coder dans la chaîne de substitution de la pseudo‑fonction, comme ci‑dessous à la ligne nº 6 : </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;

#define swapValues(a, b) do { \
  double c = a; \
  a = b, b = c; \
  printf("After swap: %s = %g   %s = %g\n", #a, (double) a, #b, (double) b); \
} while (0) 

int main(void) { 
  float x = 1.0, y = 2.0;
  swapValues(x, y);
  printf("\n");

  int u = 1, v = 2;
  swapValues(u, v);
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

  <div class="nobullet"> Dans la chaîne de format <code class="prettyprint lang-c">"After swap<span class="nocode">…</span>"</code> de l'appel de la fonction <code class="prettyprint lang-c">prinft</code>, les identificateurs des deux variables à permuter sont introduits par des <strong>spécifications de conversion</strong> <code class="prettyprint lang-c">%s</code> de chaînes de caractères avec pour arguments respectifs <code class="prettyprint lang-c">#a</code> et <code class="prettyprint lang-c">#b</code> codés après la chaîne de format. </div>

  <div class="nobullet"> <em class="remark">Remarque</em> : dans cette même ligne, on recourt à la <strong>conversion explicite</strong> (cf. chap. C3‑VI <a class="previous" href="../C3-Numeration/Cc3-6_conversionsTypes.html#cast" target="_BLANK"></a>) dans le type <code class="prettyprint lang-c">double</code> des arguments <code class="prettyprint lang-c">a</code> et <code class="prettyprint lang-c">b</code> pour que leurs valeurs soient systématiquement rendues compatibles avec les spécifications de conversion <code class="prettyprint lang-c">%g</code>. </div>
</ol><!-- numbered -->  
 
</div><!-- exemple -->


<!-- expert -->
<h4> Opérateur de concaténation de tokens </h4>


<p> Rappelons qu'à partir du code source, le préprocesseur transmet au compilateur un <strong class="title">flux de tokens</strong> de <strong>quatre catégories</strong> possibles : identificateurs, nombres, chaînes de caractères et ponctuateurs <a class="supra" href="Cc4-3_directivesPreprocesseur.html#tokenisation" target="_BLANK"></a>. </p>

<div class="important">
<p> Dans la chaîne de susbtitution d'une pseudo‑fonction, le codeur dispose de l'<strong class="title">opérateur binaire</strong> <code class="prettyprint lang-c">##</code> dit de <strong class="title">concaténation</strong> <a class="external" href="https://fr.wikipedia.org/wiki/Concat%C3%A9nation" target="_BLANK">W</a>. Son rôle consiste, dans la mesure du possible, à « assembler » les deux tokens identifiés respectivement à sa gauche et à sa droite pour n'en former qu'<strong class="defin">un seul</strong>, sachant que : </p>
<ul>
  <li> les éventuels <strong>séparateurs blancs</strong> intercalaires codés entre l'opérateur et les deux tokens initiaux sont <strong class="defin">tous supprimés</strong> par le processus de contaténation ; </li>

  <li> si la concaténation ne forme pas un token d'une des quatre catégories admises, le préprocesseur signale une <strong class="warning">erreur</strong> qui bloque la chaîne de compilation. </li>
</ul>
</div><!-- important -->

<div class="complement">
<p> L'emploi de l'opérateur de concaténation n'est pertinent que si au moins l'un des deux tokens est constitué par l'<strong class="specialT">argument formel</strong> de la macro‑définition, sinon la concaténation est statique et peut être codée directement sans cet opérateur. </p>

<p> Avec un argument, on peut notamment <strong class="pros">composer dynamiquement un identificateur</strong> (de donnée, de fonction…), aussi bien dans une déclaration que dans une instruction. Une telle possibilité n'est réalisable avec aucune autre technique de codage en langage <strong>C</strong>. </p>

<p> Et il y a <strong class="pros">beaucoup d'autres applications</strong>. Celle illustrée dans l'exemple ci‑dessous ne donne qu'un tout petit aperçu de la variété d'emplois de l'opérateur de concaténation dans la pratique. </p>
</div><!-- complement -->


<div class="exemples">
<p class="exemple"> Supposons que l'on veuille facilement convertir toutes les constantes littérales décimales d'un programme dans l'un des trois types standards d'encodage <code class="prettyprint lang-c">float</code> (suffixe <code class="prettyprint lang-c">f</code> ou <code class="prettyprint lang-c">F</code>), <code class="prettyprint lang-c">double</code> (type par défaut, pas de suffixe) ou <code class="prettyprint lang-c">long double</code> <code class="prettyprint lang-c">l</code> ou <code class="prettyprint lang-c">L</code>) – cf. chap. C3‑V <a class="previous" href="../C3-Numeration/Cc3-5_typesFlottants.html#suffixe" target="_BLANK"></a>. </p>

<p> Il serait <strong class="cons">difficile</strong> d'effectuer une telle manipulation avec un éditeur de code par une procédure du type <em>rechercher/remplacer</em>. En effet, d'une part les constantes littérales sont potentiellement toutes différentes et d'autre part, une fois codés, les suffixes ne sont pas des symboles isolés. Ils peuvent être confondus avec d'autres usage de leur lettre. </p>

<p> Une <strong class="pros">solution</strong> consiste par exemple à coder, comme ci‑dessous à la ligne nº 3 la <strong>pseudo‑fonction</strong> <code class="prettyprint lang-c">fps</code> (pour <em class="english">floating point suffix</em>) qui concatène le suffixe voulu à droite de son argument : </p>
  
<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;

#define fps(x) x ## F

int main(void) {
  printf("Pi = %.8f\n", fps(3.141592653));
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

<p> Il faut alors invoquer cette pseudo‑fonction à chaque utilisation d'une constante littérale décimale. Ensuite, pour changer le type d'encodage de toutes les constantes dans le programme, il n'y a plus qu'à modifier la chaîne de substitution de <code class="prettyprint lang-c">pfs</code> (pour le type <code class="prettyprint lang-c">double</code> qui n'a pas de suffixe, on code simplement <code class="prettyprint lang-c">x</code>, sans opérateur de concaténation). </p>
</div><!-- exemples -->


<!-- expert -->
<h4> Pseudo‑fonction d'expansion préliminaire </h4>


<p> Considérons une pseudo‑fonction qui applique dans sa chaîne de substitution l'opérateur <code class="prettyprint lang-c">#</code> à une occurrence d'un de ses arguments formels. Si dans une invocation d'une telle pseudo‑fonction, l'argument effectif correspondant est composé avec un identificateur de macro‑définition, cette dernière ne sera <strong class="warning">pas remplacée</strong> par sa chaîne de substitution, mais directement traitée comme une suite de caractères à encapsuler dans des délimiteurs <code class="prettyprint lang-c">" "</code> et ensuite, aucune expansion n'y sera effectuée. </p>

<p> Il en va de même pour les identificateurs situés immédiatement <strong>avant</strong> et <strong>après</strong> l'opérateur <code class="prettyprint lang-c">##</code> dans la chaîne de substitution d'une macro‑définition. Ils ne font <strong class="warning">jamais</strong> l'objet d'une <strong>expansion préalable</strong> au traitement de l'opération de concaténation.  </p>


<div class="exemples"><p class="exemples"></p>

<ol class="numbered">
  <li> Le programme académique ci‑dessous codé pour afficher une approximation du nombre π sous la forme d'une chaîne de caractères :   </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;

#define PI 3.1415926535
#define str(s) #s

int main(void) { 
  printf("Pi = %s\n", str(PI)); // do not work! PI is not expanded :(
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

  <div class="nobullet"> n'est <strong class="warning">pas opérationnel</strong>. En effet, dans le <strong class="specialSG">fichier prétraité</strong> généré par la commande <code class="cmd">cpp</code>, la ligne nº 7 devient : </div>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:731">
  printf("Pi = %s\n", "PI"); 
</pre>
<!---------- ne pas indenter ---------->

  <div class="nobullet"> Par conséquent, même si ce code est compilable, son exécution n'est <strong class="warning">pas satisfaisante</strong> puisqu'on obtient en sortie standard <code class="displayDark">Pi = PI</code>. </div>

 <li> Le programme académique ci‑dessous codé pour afficher une approximation du nombre π encodé dans le type <code class="prettyprint lang-c">float</code> :  </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;

#define PI 3.141592653
#define fps(x) x ## F

int main(void) {
  printf("%.8f\n", fps(PI));
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

  <div class="nobullet"> n'est <strong class="warning">pas compilable</strong>. En effet, dans le <strong class="specialSG">fichier prétraité</strong> généré par la commande <code class="cmd">cpp</code>, la ligne nº 7 devient : </div>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:731">
  printf("Pi = %.8f\n", PIF);
</pre>
<!---------- ne pas indenter ---------->

  <div class="nobullet"> alors qu'on aurait attendu que l'explansion de l'expression <code class="prettyprint lang-c">fps(PI)</code> aboutisse à <code class="prettyprint lang-c">3.141592653F</code>. </div>
</ol><!-- numbered -->
</div><!-- exemples -->

<div class="complement">
<p> Pour surmonter cette difficulté, la solution usuelle consiste à coder une <strong class="title">pseudo‑fonction d'expansion préliminaire</strong> spécifique, dont le rôle est simplement d'<strong class="defin">invoquer la pseudo‑fonction</strong> que l'on souhaite employer pour provoquer l'expansion préalable de ses arguments.  </p> 

<p> Souvent, on préfixe le nom de cette pseudo‑fonction par la lettre <code>x</code> comme abréviation de « expand ». </p>
</div><!-- complement -->


<div class="exemples"><p class="exemples"></p>

<ol class="numbered">
  <li> Supra (même numéro), il suffit de coder par exemple :   </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;

#define PI 3.141592653
#define str(s) #s
#define xstr(s) str(s)

int main(void) { 
  printf("Pi = %s\n", xstr(PI));
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

  <div class="nobullet"> et le programme devient <strong class="pros">opérationnel</strong>. En effet, la pseudo‑fonction <code class="prettyprint lang-c">xstr</code> n'emploie pas l'opérateur <code class="prettyprint lang-c">#</code>, donc le préprocesseur procède à son  expansion en commençant par celle de son argument effectif, comme indiqué ci‑dessous : <br>
  <span class="inline">
    <code class="prettyprint lang-c">xstr(PI)</code>   →   <code class="prettyprint lang-c">xstr(3.14<span class="nocode">…</span>)</code>   →   <code class="prettyprint lang-c">str(3.14<span class="nocode">…</span>)</code>   →   <code class="cmd">#3.14<span class="nocode">…</span></code>   →   <code class="prettyprint lang-c">"3.14<span class="nocode">…</span>"</code>
  </span> </div>


 <li> Supra (même numéro), il suffit de coder par exemple :   </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;

#define PI 3.1415926535
#define fps(x) x ## F
#define xfps(x) fps(x)

int main(void) {
  printf("Pi = %.8f\n", xfps(PI));
  return 0;
}
</pre>
<!---------- ne pas indenter ---------->

  <div class="nobullet"> et le programme devient <strong class="pros">compilable et opérationnel</strong>. L'expansion se déroule de façon similaire à celle de l'exemple précédent :  <br>
  <span class="inline">
    <code class="prettyprint lang-c">xfps(PI)</code>   →   <code class="prettyprint lang-c">xfps(3.14<span class="nocode">…</span>)</code>   →   <code class="prettyprint lang-c">fps(3.14<span class="nocode">…</span>)</code>   →   <code class="cmd">3.14<span class="nocode">…</span> ## F</code>   →   <code class="prettyprint lang-c">3.14<span class="nocode">…</span>F</code>
  </span> </div>
</ol><!-- numbered -->
</div><!-- exemples -->

</div><!-- expert -->



<h3 id="typesArgumentsMacro"> Typage des arguments d'une pseudo‑fonction </h3> 



<div class="complement">
<p> Comme pour une pseudo‑constante (cf. supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#typagePseudoConst"></a>), le codeur dispose d'une <strong class="pros">grande liberté</strong> de <strong class="title">typage</strong>  des <strong>expressions</strong> codées par la <strong class="specialN">chaîne de substitution</strong>. Aucune contrainte syntaxique ne s'imposant a priori, on peut employer des <strong class="defin">conversions explicites</strong> et des <strong class="defin">suffixes</strong> associés aux constantes littérales pour modifier les types déterminés implicitement par le compilateur. </p> 

<p> Il en va de même pour un <strong class="specialT">argument formel</strong> qui accepte a priori <strong class="pros">n'importe quels types</strong> d'<strong class="specialO">arguments effectifs</strong> tant que leur substitution produit des expressions compilables. On peut donc plus facilement coder une pseudo‑fonction polyvalente que s'il s'agissait d'une vraie fonction. </p>

<p> Mais comme pour une pseudo‑constante, cette liberté de typage présente des <strong class="cons">risques</strong> en termes d'erreurs de conception qui peuvent ensuite engendrer des dysfonctionnements inopinés du programme. En effet, il est difficile de tester toutes les possibilités d'exécution quand les valeurs potentiellement prises par des arguments sont aussi variées.  </p>
</div><!-- complement -->

<div class="exemples">
<p class="exemple"> La pseudo‑fonction <code class="prettyprint lang-c">sq</code> du framework <strong class="Arduino">Arduino</strong> opère donc aussi bien sur un <strong class="specialO">argument effectif</strong> de type <strong>entier</strong> ou <strong>décimal</strong> et produit un résultat dans le type par défaut correspondant. Ainsi, après expansion : </p>
<ul>
  <li> l'expression substituée à <code class="prettyprint lang-c">sq(5)</code> est de type <code class="prettyprint lang-c">int</code> par défaut ;</li>

  <li> l'expression substituée à <code class="prettyprint lang-c">sq(5.0)</code> est de type <code class="prettyprint lang-c">double</code> par défaut ;</li>

  <li> l'expression substituée à <code class="prettyprint lang-c">sq(5.0F)</code> est de type <code class="prettyprint lang-c">float</code> grâce au suffixe <code class="prettyprint lang-c">F</code> codé dans l'<strong class="specialO">argument effectif</strong>. </li>
</ul> 

<p> Mais on pourrait très bien lui imposer systématiquement le type <code class="prettyprint lang-c">float</code> par défaut en codant cette pseudo‑fonction comme ci‑dessous : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#define sq(x) ((float)(x)*(x))
</pre>
<!---------- ne pas indenter ---------->
</div><!-- exemple -->

<div class="expert">
<h4 id="macroPlusieursLignes"> Argument descripteur de type </h4>


<div class="complement">
<p> Avec une pseudo‑fonction, grâce au procédé de substitution, il est également possible de coder un <strong class="title">argument</strong> qui ne correspond <strong class="pros">pas à une données</strong>. En particulier, il peut très bien s'agir d'un <strong class="specialG">descripteur de type</strong>. </p>
</div><!-- complement -->


<div class="exemples">
<p class="exemple"> La pseudo‑fonction <code class="prettyprint lang-c">sq</code> pourrait ainsi être codée avec un <strong>deuxième argument formel</strong> nommé <code class="prettyprint lang-c">Type</code> pour imposer une <strong class="defin">conversion explicite</strong> de l'expression à substituer, comme dans la macro‑définition ci‑dessous : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#define sq(x, Type) ((Type)((x)*(x)))
</pre>
<!---------- ne pas indenter ---------->

<p> Dans une expression d'invocation de cette pseudo‑fonction, le deuxième argument effectif coderait alors un type particulier, par exemple : <br>
<span class="inline">
  <code class="prettyprint lang-c">sq(5.0F, float)</code>
</span> <br>
pour que une conversion explicite dans le type <code class="prettyprint lang-c">float</code>. </p>
</div><!-- exemple -->
</div><!-- expert -->



<h3 id="operateurConditionnel"> Emploi de l'opérateur conditionnel <code class="prettyprint lang-c">? :</code>  </h3>



<p> En règle générale, le codage d'une pseudo‑fonctions ne souffre a priori d'<strong class="pros">aucune limitation de longueur de code</strong> puisque, grâce aux sauts de lignes « fictifs », il est possible d'étendre la chaîne de substitution sur autant de lignes que nécessaires pour former n'importe quelle séquence d'instructions, y compris avec des structures de contrôle. </p>

<div class="complement">
<p> Toutefois, les règles de <strong class="title">bonnes pratiques</strong> veulent que l'on réserve le recours aux macro‑définition pour coder des <strong>petites routines</strong> dont la chaîne de substitution se limite si possible à une <strong>expression</strong>, suffisamment simple pour ne poser a priori aucun problème, ni de fonctionnement, ni de compréhension. </p>
</div><!-- complement -->

<div class="important">
<p> Dans cette perspective, il est quand même utile de pouvoir coder des commandes conditionnelles, et pour cela, les langages <strong>C</strong> et <strong>C++</strong> disposent de l'<strong class="title">opérateur conditionnel</strong> (déjà mentionné au chap. C2‑V <a class="previous" href="../C2-ElementsLangage/Cc2-5_structuresControle.html#expressionAbregee" target="_BLANK"></a>). Il permet justement de composer une <strong class="defin">expression conditionnelle</strong> de la forme : <br>
<span class="inline">	
	<code class="prettyprint lang-c"> 
		<span class="nocode"><strong class="specialLB">condition</strong></span> ? 
		<span class="nocode"><strong class="specialLG">affirmative</strong></span> : 
		<span class="nocode"><strong class="specialMg">négative</strong></span> 
	</code>
</span> <br>
où <strong class="specialLB">condition</strong>, <strong class="specialLG">affirmative</strong> et <strong class="specialMg">négative</strong> sont également <strong>trois expressions</strong>. </p>

<p> Lors de son <strong class="title">évaluation</strong>, cette expression conditionnelle prend : </p>

<ul>
	<li> la valeur de l'expression <strong class="specialLG">affirmative</strong> si l'expression <strong class="specialLB">condition</strong> est évaluée <strong>vraie</strong> ;  </li>

	<li> la valeur de l'expression <strong class="specialMg">négative</strong> si l'expression <strong class="specialLB">condition</strong> est évaluée <strong>fausse</strong>. </li>
</ul>
</div><!-- important -->

<div class="expert">
<p> En d'autres termes, l'expression conditionnelle prend la même valeur que celle que retournerait une fonction dont le corps de définition serait codé de la forme : </p>

<div class="inline" style="background: white; padding-left: 0.7em; width: 17em; text-indent: 0em;"><code class="prettyprint lang-c" style="">if (<span class="nocode"><strong class="specialLB">condition</strong></span>) return <span class="nocode"><strong class="specialLG">affirmative</strong></span>;<br>else return <span class="nocode"><strong class="specialMg">négative</strong></span>; </code>
</div><!-- inline -->
</div><!-- expert --> 

<div class="exemples" id="exemplesMacros"><p class="exemples"></p>
<p> La plupart des <strong class="defin">fonctions mathématiques</strong> (cf. chap. C2‑IV <a class="previous" href="../C2-ElementsLangage/Cc2-4_manipulationDonnees.html#fonctionsMathArduino" target="_BLANK"></a>) définies dans le fichier <code class="filename">Arduino.h</code> pour cartes à cœur <strong><em class="sigle">AVR</em></strong> sont en fait des <strong>pseudo‑fonctions</strong> codées à l'aide de l'<strong class="title">opérateur conditionnel</strong> : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:92">
#define min(a, b) ((a)<(b) ? (a) : (b))
#define max(a, b) ((a)>(b) ? (a) : (b))
#define abs(x)    ((x)>0   ? (x) : -(x))
#define constrain(amt,low,high) ((amt)<(low) ? (low) : ((amt)>(high) ? (high) : (amt)))
#define round(x)  ((x)>=0 ? (long)((x) + 0.5) : (long)((x) - 0.5))
</pre>
<!---------- ne pas indenter ---------->

<p> Ainsi, <code class="prettyprint lang-c">min</code> est une pseudo‑fonction dont la chaîne de substitution est une expression qui code le <strong>minimum</strong> (le plus petit) de ses deux arguments formels. Une invocation comme par exemple <code class="prettyprint lang-c">min(5, 2)</code> sera remplacée par le préprocesseur par <code class="prettyprint lang-c">((5)<(2) ? (5) : (2))</code>. Et comme la <strong class="specialLB">condition</strong> <code class="prettyprint lang-c">(5)<(2)</code> est <strong>fausse</strong>, cette expression prendra la valeur de la <strong class="specialMg">négative</strong> <code class="prettyprint lang-c">(2)</code>, c'est‑à‑dire la valeur entière <em class="bold">2</em> qui est bien le plus petit des deux arguments effectifs codés dans l'invocation. </p>

<p style="margin-top: 1em"> <em class="remark">Remarque</em>. L'opérateur conditionnel <code class="prettyprint lang-c">? :</code> peut, comme tous les opérateurs, être <strong>composé</strong> avec d'<strong>autres opérateurs</strong>, en particulier avec <strong>lui‑même</strong> (cf. la macro <code class="^prettyprint lang-c">constrain</code> codé à la ligne nº 95). </p>
</div><!-- exemples -->



<div class="expert">
<h3 id="sideEffectOnMacros"> Attention aux pseudo‑fonctions non‑sûres !  </h3>


<div class="complement">
<p> On l'a vu supra, le procédé de substitution par lequel une pseudo‑fonction « transmet la valeur » d'un argument effectif à son argument formel correspondant est très commode (pas de contrainte de typage) et très puissant (l'argument ne correspond pas forcément à une donnée). </p>

<p> Mais ce procédé présente néanmoins un <strong class="warning">inconvénient majeur</strong> dont les codeurs débutants n'ont pas forcément conscience, lorsque la chaîne de substitution d'une pseudo‑fonction comporte <strong class="cons">plusieurs occurrences</strong> d'un <strong class="specialT">même argument formel</strong>. Dans une invocation, l'expression de son <strong class="specialO">argument effectif</strong> correspondant sera <strong class="specialLB">évaluée autant de fois</strong>, ce qui peut poser un problème si cette expression emploie un opérateur à <strong class="warning">affectation composée</strong> (cf. chap. C2‑IV <a class="previous" href="../C2-ElementsLangage/Cc2-4_manipulationDonnees.html#compoundOperators" target="_BLANK"></a>) ou plus généralement une fonction à <strong class="warning">effet de bord</strong> ! On parle de <strong class="title">macro‑définition non sûre</strong> (unsafe macro <a class="external" href="https://gcc.gnu.org/onlinedocs/cpp/Duplication-of-Side-Effects.html" target="_BLANK"></a>). </p>


<p> Les <strong class="warning">risques</strong> de dysfonctionnement sont élevés même pour un <strong>codeur expérimenté</strong> s'il emploie <strong class="cons">sans le savoir</strong> des pseudo‑fonctions non‑sûres (parce qu'il ne les a pas lui‑même développées et qu'il n'a pas pris le temps de lire leur code). Il est donc impératif qu'elles soient <strong class="pros">signalées</strong> comme telles dans leur documentation. </p>

<p> Ainsi, toutes les <strong>pseudo‑fonctions mathématiques</strong> <strong class="Arduino">Arduino</strong> présentées supra <a class="external" href="Cc4-3_directivesPreprocesseur.html#exemplesMacros"></a>, qui sont autant d'exemples de macro‑définition <strong class="warning">non‑sûres</strong>, font l'objet d’avertissement – cf. le cas de <code class="prettyprint lang-c">min</code> <a class="external" href="https://www.arduino.cc/reference/en/language/functions/math/min/" target="_BLANK">A</a>. </p>
</div><!-- complement -->


<div class="exemples">
<p class="exemple"> Pour illustrer les risques de dysfonctionnement, considérons le programme ci‑dessous qui tente <strong class="cons">maladroitement</strong> d'afficher le carré d'un nombre incrémenté puis la valeur de ce dernier. À la ligne nº 7, la pseudo‑fonction <code class="prettyprint lang-c">sq</code> non‑sûre est composée avec l'opérateur <code class="prettyprint lang-c">++</code> : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:1">
#include &lt;stdio.h&gt;

#define sq(x) ((x)*(x))    // warning: unsafe macro

int main(void) {
  int a = 2;
  printf("%d\n", sq(a++)); // 6!!
  printf("%d\n", a);       // 4!
  return 0;
}  
</pre>
<!---------- ne pas indenter ---------->

<p> À l'exécution, on obtient en sortie standard successivement les valeurs <code class="displayDark">6</code> (qui n'est pas un carré !) et <code class="displayDark">4</code>. En effet, après expansion par le préprocesseur, l'expression d'invocation <code class="prettyprint lang-c">sq(a++)</code> devient <code class="prettyprint lang-c">((a++)*(a++))</code>. Il en résulte que, conformément aux règles de priorité et de sens d'associativité des opérateurs (cf. chap. C2‑IV <a class="previous" href="../C2-ElementsLangage/Cc2-4_manipulationDonnees.html#priorites" target="_BLANK"></a>) :  </p>
<ul>
  <li> l'évaluation du premier terme <code class="prettyprint lang-c">(a++)</code> conduit au remplacement de la variable <code class="prettyprint lang-c">a</code> par sa <strong>valeur initiale</strong> <code class="prettyprint lang-c">2</code> puis à son incrémentation ; </li>

  <li> l'évaluation du deuxième terme <code class="prettyprint lang-c">(a++)</code> conduit au remplacement de la variable <code class="prettyprint lang-c">a</code> par sa <strong>nouvelle valeur</strong> <code class="prettyprint lang-c">3</code> puis encore à son incrémentation ;  </li>

  <li> le produit <code class="prettyprint lang-c">(a++)*(a++)</code> devient donc <code class="prettyprint lang-c">2*3</code> et la variable <code class="prettyprint lang-c">a</code> vaut alors <code class="prettyprint lang-c">4</code> !  </li>
</ul>

<p> La <strong class="pros">bonne pratique</strong> consiste évidemment à ne pas coder une telle composition mais procéder en <strong class="defin">deux étapes</strong>, comme par exemple ci‑dessous : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:5">
int main(void) {
  int a = 2;
  a++;
  printf("%d\n", sq(a));  // 9
  printf("%d\n", a);      // 3
  return 0;
}  
</pre>
<!---------- ne pas indenter ---------->
</div><!-- exemple -->

<div class="remarques"><p class="remarques"> Dans l'exemple précédent : </p>
<ul>
  <li> le résultat est « <strong class="cons">moins grave</strong> » si l'on code l'expression d'invocation <code class="prettyprint lang-c">sq(++a)</code>. La variable <code class="prettyprint lang-c">a</code> étant incrémentée avant toute évaluation, on obtient successivement les valeurs <code class="displayDark">16</code> et <code class="displayDark">4</code> ; néanmoins, le problème de la double incrémentation perdure… </li>

  <li> le résultat devient <strong class="pros">satisfaisant</strong> si, en plus de l'amélioration ci‑dessus, à la ligne nº 3, on remplace le code de <code class="prettyprint lang-c">sq</code> par celui d'une <strong>vraie fonction</strong> comme ci‑dessous : </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:3">
int sq(int x) {return x*x;}
</pre>
<!---------- ne pas indenter ---------->

  <div class="nobullet"> car on obtient alors les valeur <code class="displayDark">9</code> et <code class="displayDark">3</code>. </div>
</ul> 
</div><!-- remarques -->
</div><!-- expert -->



<h3> Comparaison avec l'emploi d'une vraie fonction </h3>



<div class="complement">
<p> On a comparé supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#comparaisonConstante" target="_BLANK"></a> l'emploi d'une pseudo‑constante avec une vraies constante. Il est pertinent de procéder de même entre une <strong class="title">pseudo‑fonction</strong> et une <strong>« vraie » fonction</strong>. Encore une fois, plusieurs aspects sont à considérer. </p>

<ul>
  <li> Le <strong class="specialLB">coût mémoire</strong> est cette fois potentiellement <strong class="cons">bien plus important</strong> avec une pseudo‑fonction, puisque sa définition, au lieu d'être stockée une seule fois dans le segment <code class="cmd">.text</code> du code exécutable, y est copiée <strong>autant de fois</strong> que ce dernier comporte d'<strong>invocations</strong> de cette pseudo‑fonction. </li>

  <li> La <strong class="specialLB">vitesse d'exécution</strong> est, en revanche, a priori <strong class="pros">meilleure</strong> puisque qu'il n'est pas nécessaire à chaque appel de la pseudo‑fonction de procéder à l'allocation d'un espace mémoire dans la pile avant d'exécuter ses instructions.  </li>

  <li> Quant à la <strong class="specialLB">souplesse de typage</strong> des arguments, elle peut être vue comme un avantage en termes de <strong class="pros">polyvalence du code</strong> à tous types d'arguments, mais un inconvénient en termes de  <strong class="cons">vulnérabilité aux erreurs</strong> qui pourraient être détectées dès la compilation par un typage plus strict. </li>
  
  <div class="expert">
  <li> Enfin, la <strong class="specialLB">polyvalence du code</strong> peut trouver, dans le cas d'une pseudo‑fonction, une <strong class="cons">limite d'emploi</strong> pour des arguments à <strong class="warning">effets de bord</strong> — limite qui n'existe pas avec une vraie fonction. Il faut alors le plus souvent utiliser une <strong>variable intermédiaire</strong> pour dissocier l'opération à effet de bord de l'appel de la pseudo‑fonction. </li>
  </div><!-- expert -->
</ul>
</div><!-- complement -->


<div class="expert">
<h4> Retour d'expérience sur l'emploi des pseudo‑fonctions </h4>  


<p> En langage <strong class="title">C</strong> — et même parfois en <strong>C++</strong>, comme par exemple dans le framework <strong class="Arduino">Arduino</strong> — surtout au regard des avantages en termes de souplesse de typage, les pseudo‑fonctions restent <strong class="defin">très utilisées</strong>. Tant que le code de ces dernières reste <strong>court</strong> et <strong>simple</strong>, et tant que les utilisateurs sont conscients de la limite d'emploi avec des arguments à effet de bord, cette pratique ne pose a priori pas de problème. </p>

<div class="complement">
<p>	Cependant, comme pour les pseudo‑constantes, les spécialistes du <strong class="title">C++</strong> sont en général beaucoup plus <strong class="cons">réticents</strong> à utiliser les <strong>pseudo‑fonctions</strong>. D'ailleurs, on a vu que ce langage met à disposition du codeur d'autres concepts pour produire des fonctions polyvalentes : <strong class="defin">arguments optionnels</strong>, <strong class="defin">surcharge d'identificateur</strong> – cf. chap. C4‑I <a class="previous" href="Cc4-1_fonctionsGeneralites.html#particularites" target="_BLANK"></a>. </p>

<p> De plus, il existe aussi un moyen pour diminuer le temps d'exécution d'une fonction : l'<strong class="title">extension</strong> <code class="prettyprint lang-c">inline</code> (qui fait aussi partie du langage <strong>C</strong>). </p> 
</div><!-- complement -->


<h4> Alternative aux pseudo‑fonctions : l'extension <code class="prettyprint lang-c">inline</code> </h4>


<div class="complement">
<p> Une <strong>fonction</strong> dont l'<strong class="defin">en‑tête de définition</strong> est précédée du <strong class="title">mot‑clef</strong> <code class="prettyprint lang-c">inline</code> <a class="external" href="https://fr.wikipedia.org/wiki/Extension_inline" target="_BLANK">W</a> n'est a priori <strong class="warning">pas</strong> compilée qu'<strong>une seule fois</strong> dans le segment <code class="cmd">.text</code> comme l'est usuellement une fonction. </p>

<p> Si le compilateur tient compte de cette extension, il développe le code exécutable de cette fonction à la place de <strong class="defin">chacun de ses appels</strong>, en y transposant à chaque fois les arguments effectifs aux arguments formels correspondants. </p>
</div><!-- complement -->

<p>  Mise en en œuvre par le <strong>compilateur</strong> et non pas par le préprocesseur, l'<strong class="title">extension</strong> <code class="prettyprint lang-c">inline</code> partage avec la notion de macro‑définition : </p>

<ul>
	<li> le même avantage en termes de <strong class="pros">diminution du temps d'exécution</strong>, </li>

	<li> le même inconvénient en termes d'<strong class="cons">augmentation du volume de stockage</strong> du code exécutable. </li>
</ul>

<p> Toutefois, comme la spécification de classe d'allocation <code class="prettyprint lang-c">register</code> (cf. chap. C4-II <a class="previous" href="Cc4-2_porteeDonnees.html#register" target="_BLANK"></a>), l'extension <code class="prettyprint lang-c">inline</code> n'est pas garantie. La décision est laissé « à l'appréciation du compilateur », c'est‑à‑dire au gré des algorithmes d'optimisation qu'il met en œuvre. Il faut donc aller regarder le code assembleur généré par le compilateur pour vérifier au cas par car si l'extension <code class="prettyprint lang-c">inline</code>  est mise en œuvre (cf. chap. C4-IV <a class="previous" href="Cc4-4_chaineCompilation.html" target="_BLANK"></a>). </p>
</div><!-- expert -->


















<h2 id="compilCondi"> Directives de compilation conditionnelle </h2>



<h3 id="principeCompilCond"> Principe </h3>



<p> Durant de la conception d'un programme, on est parfois tenté de <strong class="specialLGr">mettre en commentaire</strong> une <strong>partie du code source</strong> parce que l'on ne souhaite pas, <strong class="defin">temporairement</strong> ou en certaines <strong class="defin">circonstances</strong>, l'inclure dans la production du code exécutable. Mais cette pratique est <strong class="cons">malcommode</strong>, ne serait‑ce qu'avec l'impossibilité d'encapsuler les blocs de commentaires les uns dans les autres (cf. chap. C2‑II <a class="previous" href="../C2-ElementsLangage/Cc2-2_syntaxeFondamentale.html#commentaires" target="_BLANK"></a>). On est donc contraint d'ajouter un séparateur <code class="prettyprint lang-c">//</code> au début de chaque ligne et, même avec un bon éditeur de code, de telles manipulations deviennent fastidieuses lorsqu'il faut les répéter fréquemment. </p>


<div class="important">
<p> Une <strong class="title">directive de compilation conditionnelle</strong> consiste justement à indiquer au préprocesseur qu'une <strong>partie du code source</strong> doit  être <strong class="defin">compilée seulement si</strong> une <strong class="specialMg">condition</strong> est vérifiée. Dans la négative, lors du traitement de cette directive, le préprocesseur ne transmet pas cette partie du code au compilateur. </p>
</div><!-- important -->



<h3> Syntaxe générale </h3>



<div class="important">
<p> Une <strong class="title">directive de compilation conditionnelle</strong> adopte une structure similaire à celle d'une bifurcation <code>if</code> (cf. chap. C2‑V <a class="previous" href="../C2-ElementsLangage/Cc2-5_structuresControle.html#testIf" target="_BLANK"></a>), mais avec une <strong>syntaxe spécifique</strong> à l'aide de <strong class="defin">plusieurs lignes de contrôle</strong> <a class="supra" href="Cc4-3_directivesPreprocesseur.html#ligneControle"></a>. </p>
</div><!-- important -->

<div class="complement">
<p> Typiquement, on code une  telle directive de la forme :  </p>

<div class="inline" style="background: white; padding-left: 0.7em; width: 19em; text-indent: 0em;"><code class="prettyprint lang-c">#if <span class="nocode"><strong class="specialMg">condition 1</strong></span><br>
<span class="nocode"><strong> code contrôlé 1</strong><br><span style="font-weight: normal">(compilé seulement si <em>condition 1</em> est vraie)</span></span><br>#elif <span class="nocode"><strong class="specialMg">condition 2</strong></span><br>
<span class="nocode"><strong> code contrôlé 2</strong><br><span style="font-weight: normal">(compilé seulement si <em>condition 2</em> est vraie)</span></span><br>#elif <span class="nocode"><strong>…</strong></span><br><br>#else<br>
<span class="nocode"><strong> code contrôlé n</strong><br><span style="font-weight: normal">(compilé dans tous les autres cas)</span></span><br>#endif // condition 1  </code>
</div><!-- inline -->

<p> où : </p>

<ul>
  <li> toutes les <strong class="specialMg">conditions</strong> sont des <strong>expressions</strong> à destination du préprocesseur ; leur codage est régi par une <strong class="warning">syntaxe restreinte</strong> détaillée infra <a class="infra" href="Cc4-3_directivesPreprocesseur.html#pseudoExpression" target="_BLANK"></a> ; </li>

  <li> la <strong>première ligne de contrôle</strong> <code class="prettyprint lang-c">#if</code> peut être aussi être codée <code class="prettyprint lang-c">#ifdef</code> ou <code class="prettyprint lang-c">#ifndef</code> si la première condition exprime le fait qu'un <strong class="specialG">identificateur</strong> de macro‑définition est <strong class="defin">antérieurement défini ou non</strong> (cf. infra <a class="infra" href="Cc4-3_directivesPreprocesseur.html#ifdef"></a>) ; </li>

  <li> les <strong>autres lignes de contrôle</strong> <code class="prettyprint lang-c">#elif</code> (mot réservé signifiant par abréviation « <em>else if</em> ») et <code class="prettyprint lang-c">#else</code> sont <strong class="defin">facultatives</strong> ; elles permettent de coder autant que nécessaire d'<strong>alternatives</strong> à la première condition ; </li>

  <li> la <strong>dernière ligne de contrôle</strong> <code class="prettyprint lang-c">#endif</code> est <strong class="defin">obligatoire</strong> pour clôturer la directive dans le <strong>fichier source où elle débute</strong> ; le <strong class="specialLGr">commentaire</strong> (évidemment facultatif) ajouté à sa suite est <strong class="pros">vivement recommandé</strong> pour la bonne lisibilité du code. </li>
</ul>
</div><!-- complement -->



<h3> Régles d'indentation </h3>



<div class="important">
<p> Comme pour les autres directives, les <strong class="title">lignes de contrôle</strong> de compilation conditionnelle ne sont soumis à <strong class="pros">presque aucune contrainte de format</strong> (cf. supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#contraintesFormat"></a>). Elles peuvent donc être <strong>indentées à souhait</strong>, sachant que l'indentation peut être placée <strong>avant ou après</strong> le symbole <code class="prettyprint lang-c">#</code>. </p>

<p> Pourtant, en règle générale, cette possibilité n'est <strong>pas systématiquement exploitée</strong> comme pour les instructions. </p>
</div><!-- important -->

<div class="complement">
<p> Une <strong class="pros">bonne pratique</strong> consiste à : </p>  
<ul>
  <li>  <strong class="defin">ne pas indenter</strong> ces lignes de contrôle même si elles s'insèrent dans une partie de code déjà indentée ; </li>

  <li> <strong class="warning">ne pas modifier l'indentation normale du code contrôlé</strong> sauf s'il ne s'agit que de lignes de contrôle d'autres directives ; </li>
</ul>

<p> Ainsi, le <strong class="specialSG">fichier prétraité</strong> éventuellement généré par le préprocesseur se présente comme un code source usuel. </p>

<p> De plus, lorsqu'une directive s'étend sur une <strong class="title">grande partie de code</strong> (typiquement, lorsqu'elle dépasse la taille d'affichage d'un moniteur) ou lorsqu'il y a <strong class="specialLB">plusieurs directives imbriquées</strong> les unes dans les autres sans indentation, des <strong class="specialLGr">commentaires</strong> placés en <strong>fin des lignes de contrôle</strong> sont bienvenus faciliter la lecture du code. </p>
</div><!-- complement -->

<div class="exemples" id="exempleDirectivesIf"> <p class="exemples"> Les fichiers d'en‑tête du framework <strong class="Arduino">Arduino</strong> fournissent de nombreux exemples de directives de compilation conditionnelle. En revanche, ils ne sont pas indentés selon des règles systématiques. Ainsi, dans le fichier <code class="filename">HardwareSerial.h</code> <a class="external" href="https://github.com/arduino/ArduinoCore-avr/blob/master/cores/arduino/HardwareSerial.h" target="_BLANK">G</a> pour cartes à cœur <strong><em class="sigle">AVR</em></strong>, on trouve :  </p>

<ul>
  <li> deux directives imbriquées l'une dans l'autre qui permettent de définir la pseudo‑constante <code class="prettyprint lang-c">SERIAL_TX_BUFFER_SIZE</code> (laquelle détermine la taille du buffer d'émission de l'objet <code class="prettyprint lang-c">Serial</code> – cf. chap. C3‑X <a class="previous" href="../C3-Numeration/Cc3-10_moniteurSerie.html#buffersSerial" target="_BLANK"></a>) : </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:42">
#if !defined(SERIAL_TX_BUFFER_SIZE)
#if ((RAMEND - RAMSTART) < 1023)
#define SERIAL_TX_BUFFER_SIZE 16
#else
#define SERIAL_TX_BUFFER_SIZE 64
#endif
#endif
</pre>
<!---------- ne pas indenter ---------->

  <div class="nobullet"> qu'il aurait d'ailleurs été plus clair de coder et d'indenter comme ci‑dessous : </div>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:42">
#ifndef SERIAL_TX_BUFFER_SIZE
#  if (RAMEND - RAMSTART) < 1023
#    define SERIAL_TX_BUFFER_SIZE 16
#  else
#    define SERIAL_TX_BUFFER_SIZE 64
#  endif
#endif
</pre>
<!---------- ne pas indenter ---------->

  <li> une directive pour définir le type <code class="prettyprint lang-c">tx_buffer_index_t</code> des variables d'indexation de ce buffer en fonction de sa taille : </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:56">
#if (SERIAL_TX_BUFFER_SIZE>256)
typedef uint16_t tx_buffer_index_t;
#else
typedef uint8_t tx_buffer_index_t;
#endif
</pre>
<!---------- ne pas indenter ---------->
  
  <div class="nobullet"> sachant qu'ici, l'absence d'indentation est satisfaisante car il n'y a que des instructions dans le code contrôlé (dans le <strong class="specialSG">fichier prétraité</strong> généré par la commande <code class="prettyprint lang-c">cpp</code>, seule l'une des deux instructions <code class="prettyprint lang-c">typedef</code> serait présente, et sans indentation inutile).  </div>
</ul>

</div><!-- exemples -->



<h3 id="expressionCond"> Expressions de compilation conditionnelles </h3>



<div class="important">
<p> L'<strong class="title">expression de compilation conditionnelle</strong> codée dans une ligne de contrôle <code class="prettyprint lang-c">#if</code> est <strong class="defin">évaluée par le préprocesseur</strong>. Elle est similaire à une expression composée en langage <strong>C</strong>, mais avec des <strong class="warning">restrictions syntaxiques</strong> importantes. </p>
</div><!-- important -->

<div class="complement">
<p> Une <strong class="title">expression de compilation conditionnelle</strong> et les sous‑expressions qui la composent sont évaluées dans <strong class="defin">le plus grand type entier standard signé</strong> reconnu par le compilateur  – donc, en règle générale, sur <strong>64 bits</strong>. </p>

<p> Selon le même principe que pour toutes les expressions en langage <strong>C</strong>, la <strong class="specialMg">condition</strong> exprimée est analysée par le préprocesseur <strong>CPP</strong> comme : </p>

<ul>
  <li> <strong style="color: red">fausse</strong> si l'évaluation est <strong>égale à</strong> <code class="cmd" style="color: red">0</code> ; </li>

  <li> <strong style="color: green">vraie</strong> sinon. </li>
</ul>
</div><!-- complement -->

<p> Une expression de compilation conditionnelle ne nécessite <strong class="defin">pas d'encapsulation dans des parenthèses</strong> (contrairement à celle de condition  d'une structure de contrôle <code class="prettyprint lang-c">if</code>). Une telle encapsulation est simplement <strong>sans effet</strong>. </p>


<h4> Restrictions syntaxiques </h4>


<div class="complement">
<p> Une <strong class="title">expression de compilation conditionnelle</strong> se compose <strong class="warning">exclusivement</strong> avec : </p>

<ul>
  <li> des <strong class="specialLB">atomes</strong> (éléments non décomposables) qui ne peuvent être que : </li>

  <ul>
    <li> des <strong>constantes littérales entières</strong> (<em class="remark">ex</em>. : <code class="prettyprint lang-c">1</code>, <code class="prettyprint lang-c">2</code>, etc.) – et donc, <strong class="warning">pas décimales</strong> ;  </li>

    <li> des <strong>constantes littérales de type caractère</strong> (<em class="remark">ex</em>. : <code class="prettyprint lang-c">'A'</code>, <code class="prettyprint lang-c">'B'</code>, etc.) , mais <strong class="warning">pas de type chaîne de caractères</strong> (car non évaluable comme valeur entière) ; </li>

    <li> des <strong>identificateurs</strong>, qu'il soient <strong>définis ou non</strong> par des directives antérieures, sachant que les identificateurs <strong class="warning">non définis</strong> prennent la valeur <code class="cmd" style="color: red">0</code> par défaut ; </li>
  </ul>
  
  <li> des <strong class="specialLB">opérateurs</strong> qui ne peuvent être que : </li>
  <ul>
    <li> les <strong>opérateurs élémentaires</strong> du langage <strong>C</strong> (cf. chap. C2‑IV <a class="previous" href="../C2-ElementsLangage/Cc2-4_manipulationDonnees.html#operators" target="_BLANK"></a>) – donc à l'exclusion de l'opérateur <em>trois voies</em> <code class="prettyprint lang-c"><=></code> qui est spécifique au <em class="mark">C++</em> ;   </li>

    <li> l'opérateur d'<strong>élévation de rang de priorité</strong><code class="prettyprint lang-c">( )</code> et l'<strong>opérateur conditionnel</strong> <code class="prettyprint lang-c">? :</code> (cf. supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#operateurConditionnel"></a>) ; </li>

    <li> l'<strong>opérateur unaire</strong> <code class="cmd" style="color: crimson">defined</code> qui est <strong class="defin">spécifique au préprocesseur</strong> ; appliqué à un <strong class="specialG">identificateur</strong>, il donne la valeur <code class="prettyprint lang-c">1</code> si ce dernier est défini par une directive antérieure, <strong>sinon</strong> la valeur <code class="cmd" style="color: red">0</code> ;   </li>

    <div class="nobullet"> autrement dit, <code class="prettyprint lang-c">#if defined</code> est équivalent à <code class="prettyprint lang-c">#ifdef</code> (de même que <code class="prettyprint lang-c">#if !defined</code> est équivalent à <code class="prettyprint lang-c">#ifndef</code>) ; </div> 
  </ul>

  <li> des <strong class="specialLB">invocations</strong> de pseudo‑fonctions, qui doivent évidemment en respecter la syntaxe (parenthèses, nombre d'arguments, etc. – cf. supra <a class="supra" href="Cc4-3_directivesPreprocesseur.html#invocation"></a>). </li>  
</ul>
</div><!-- complement -->


<div class="exemples">
<p class="exemple"> Toujours dans le fichier <code class="filename">HardwareSerial.h</code> <a class="external" href="https://github.com/arduino/ArduinoCore-avr/blob/master/cores/arduino/HardwareSerial.h" target="_BLANK">G</a> du framework <strong class="Arduino">Arduino</strong> pour cartes à cœur <strong><em class="sigle">AVR</em></strong>, on trouve notamment :   </p>

<ul>
  <li> à la ligne nº 43, l'expression <code class="prettyprint lang-c">((RAMEND - RAMSTART) < 1023)</code>, sachant que <code class="prettyprint lang-c">RAMEND</code> et <code class="prettyprint lang-c">RAMSTART</code> sont deux <strong>pseudo‑constantes entières</strong> définies dans un autre fichier d'en‑tête préalablement inclus (notons au passage que les parenthèses externes sont inutiles) ; </li>

  <div class="expert">
  <div class="nobullet"> pour être plus précis, ces deux pseudo‑constantes donnent respectivement l'adresse de fin et de début de la mémoire <em class="sigle">RAM</em> sur la carte cible (cf. les lignes nº 883 & 884 du fichier <code class="filename">avr/iom328p.h</code> pour les cartes à microcontrôleur <em class="mark">ATmega328p</em> <a class="external" href="https://github.com/vancegroup-mirrors/avr-libc/blob/master/avr-libc/include/avr/iom328p.h" target="_BLANK"></a>) ; </div>
  </div><!-- expert -->

  <li> à la ligne nº 142, l'expression <code class="prettyprint lang-c">defined(UBRRH) || defined(UBRR0H)</code> ; ici, le recours à l'opérateur <code class="cmd" style="color: crimson">defined</code> est indispensable (on ne peut pas composer deux lignes de contrôle <code class="prettyprint lang-c">#ifdef</code> avec l'opérateur <code class="prettyprint lang-c">||</code>). </li>

  <div class="expert">
  <div class="nobullet"> pour être plus précis, les deux pseudo‑constantes <code class="prettyprint lang-c">UBRRH</code> et <code class="prettyprint lang-c">UBRR0H</code> correspondent potentiellement à des adresses de registres du microcontrôleur sur la carte cible (ainsi, pour le <em class="mark">ATmega328p</em>, on a <code class="prettyprint lang-c">UBRR0H</code> qui est définie à ligne nº 781 du fichier <code class="filename">avr/iom328p.h</code>). </div>
  </div><!-- expert -->
</ul>
</div><!-- exemples -->


<div class="remarques"><p class="remarques"></p> 

<ol class="littered">
  <li>   Dans une directive de la forme : <br>
  <span class="inline">
    <code class="prettyprint lang-c">#if <span class="nocode"><strong>pseudo‑constante</strong></span></code>
  </span> <br>
  si la <strong>pseudo‑constante</strong> est bien préalablement <strong class="defin">définie</strong> mais vaut <code class="cmd" style="color: red">0</code>, la condition est évaluée <strong style="color: red">fausse</strong>. </li>

  <div class="nobullet">Il faut donc <strong class="warning">ne pas confondre</strong> avec une directive de la forme : <br>
  <span class="inline">
    <code class="prettyprint lang-c">#ifdef <span class="nocode"><strong>pseudo‑constante</strong></span></code>
  </span> <br>
  qui serait, elle, évaluée <strong style="color: green">vraie</strong> <em class="remark">quelle que soit la valeur</em> de la <strong>pseudo‑constante</strong>, dès lors que cette dernière est <strong class="defin">définie</strong>. </div>


  <li> Le préprocesseur évaluant ses expressions dans le type entier standard le plus grand possible (cf. supra <a class="supra" href="http://www.lycee-ferry-versailles.fr/snir/ModuleC/C4-Fonctions/expressionCond"></a>), il ne procède à <strong class="title">aucune analyse ni conversion de type</strong>. Tout emploi d'un <strong>suffixe</strong> de typage ou d'un opérateur de <strong>cast</strong> (cf. chap. C3‑VI <a class="previous" href="../C3-Numeration/Cc3-6_conversionsTypes.html#cast" target="_BLANK"></a>) y est donc aussi <strong class="cons">inutile</strong> qu'<strong class="warning">erroné</strong>. </li>
</ol>
</div><!-- remarque -->



<div class="expert">
<h3> Directives de diagnostic de prétraitement </h3>



<div class="important">
<p> Le préprocesseur <strong>CPP</strong> admet <strong class="title">deux directives</strong> qui permettent d'<strong class="defin">interférer sur le processus de prétraitement</strong> d'un programme :   </p>
<ul>
  <li> <code class="prettyprint lang-c">#warning</code> qui émet un <strong class="specialO">message</strong> – typiquement, un <strong>avertissement</strong> – dans le compte‑rendu de compilation ; </li>

  <li> <code class="prettyprint lang-c">#error</code> qui, en plus émettre un <strong class="specialO">message</strong>, déclenche une <strong class="warning">erreur</strong> et fait donc échouer la compilation. </li>
</ul>

<p> Tout élément codé après <code class="prettyprint lang-c">#warning</code> ou <code class="prettyprint lang-c">#error</code> dans la ligne de contrôle de la directive est reconnu par le préprocesseur comme la <strong>chaîne de caractères</strong> constituant le <strong class="specialO">message</strong> à afficher, sans qu'il soit nécessaire de l'encapsuler entre guillemets doubles <code class="prettyprint lang-c">" "</code> (même si cette pratique existe). Il ne fait l'objet d'<strong>aucune expansion</strong>. </p>  
</div><!-- important -->


<div class="complement">
<p> Dans la pratique, ces lignes de contrôle sont <strong class="title">employées</strong> dans le cadre de <strong class="defin">directives de compilation conditionnelle</strong>, sinon leur intervention serait systématique. Elles permettent notamment d'<strong>avertir l'utilisateur d'un code source</strong> lorsqu'il tente une compilation pour un environnement qui présente une <strong class="warning">incompatibilité</strong> avec le programme. </p>

<p> Elles peuvent également être utilisée pour la <strong class="defin">mise au point</strong> des directives d'un programme, notamment si l'on veut vérifier qu'un identificateur est défini, qu'une pseudo‑constante prend telle ou telle valeur, etc. </p>
</div><!-- complement -->

<div class="exemples"><p class="exemples"> Les fichiers du framework <strong class="Arduino">Arduino</strong> utilisent occasionnellement des directives <code class="prettyprint lang-c">#warning</code> et <code class="prettyprint lang-c">#errror</code>. Les exemples ci‑dessous en donnent un aperçu.  </p>
<ol class="numbered">
  <li> Dans le fichier d'implémentation <code class="filename">WInterrupts.c</code> <a class="external" href="https://github.com/arduino/ArduinoCore-avr/blob/master/cores/arduino/WInterrupts.c" target="_BLANK">G</a> pour cartes à cœur <strong><em class="sigle">AVR</em></strong>, on trouve plusieurs directives <code class="prettyprint lang-c">#warning</code>, notamment :  </li>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:39">
#if EXTERNAL_NUM_INTERRUPTS > 8
  #warning There are more than 8 external interrupts. Some callbacks may not be initialized.
</pre>
<!---------- ne pas indenter ---------->  
  
  <div class="nobullet"> Codée dans la déclaration d'un tableau de pointeurs de fonctions à appeler en cas d'interruption, elle avertit l'utilisateur du code que ce tableau ne sera pas complètement initialisé si la pseudo‑constante <code class="prettyprint lang-c">EXTERNAL_NUM_INTERRUPTS</code> est supérieure à <code class="prettyprint lang-c">8</code>. </div>

  <li> Dans le fichier d'implémentation <code class="filename">HardwareSerial0.cpp</code> <a class="external" href="https://github.com/arduino/ArduinoCore-avr/blob/master/cores/arduino/HardwareSerial0.cpp" target="_BLANK">G</a> pour cartes à cœur <em class="sigle">AVR</em>, on trouve plusieurs directives <code class="prettyprint lang-c">#error</code>, notamment à la ligne nº 46 :  </li>


<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:39">
#if defined(USART_RX_vect)
  ISR(USART_RX_vect)
#elif defined(USART0_RX_vect)
  ISR(USART0_RX_vect)
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
</pre>
<!---------- ne pas indenter ---------->  
  
  <div class="nobullet"> Cette directive déclenche une erreur de compilation si aucune des trois pseudo‑constantes <code class="prettyprint lang-c">USART_RX_vect</code>, <code class="prettyprint lang-c">USART0_RX_vect</code> ou <code class="prettyprint lang-c">USART_RXC_vect</code> n'est définie. </div>
</ol>
</div><!-- exemple -->
</div><!-- expert -->  



<h3> Principales applications des directives de compilation conditionnelle </h3>



<div class="important">
<p> Les <strong>directives de compilation conditionnelle</strong> ont pour <strong class="title">principale application</strong> de produire : </p>
<ul>
  <li> des <strong class="defin">programmes portables</strong> sur divers environnements (machines cibles, systèmes d'exploitation…), en adaptant le code source à des variables d'environnement définies comme des pseudo‑constantes ;  </li>

  <li> de <strong class="defin">programmes évolutifs</strong> où le code source contient <strong>plusieurs versions</strong> sectionnables via une ou plusieurs pseudo‑constantes dont la définition peut même être saisie dans la commande système de compilation. </li>
</ul>
</div><!-- important -->


<div class="complement">
<p> Mais il existe aussi d'<strong class="title">autres applications</strong> très courantes, notamment :  </p>

<ul>
  <li> la <strong class="specialLB">protection d'un fichier source</strong> <strong>contre les inclusions multiples</strong> ; </li>

  <li> la <strong class="specialLB">mise en hors compilation</strong> d'une <strong>partie de code</strong>, comme on serait tenté de le faire par une <strong class="specialLGr">mise en commentaire</strong>, mais sans les problèmes que pose cette « astuce ». </li>
</ul>

<p> Ces deux applications sont détaillées ci‑après. </p>
</div><!-- complement -->


<h4 id="prevDoubleInclusion"> Protection d'un fichier source contre les inclusions multiples </h4>


<p> Dans le cadre de développement d'un programme comportant <strong class="title">plusieurs fichiers sources</strong> (problématique qui sera abordée dans les chapitres suivants de la partie <span class="partie">C4</span> du module), il est usuel que certains d'entre eux requièrent l'<strong class="defin">inclusion d'un même fichier</strong>. Or cela pose inévitablement des <strong class="warning">conflits de déclaration</strong> lors de la compilation, puisque tous les éléments déclarés dans ce fichier le seront plusieurs fois.  </p>

<div class="complement">
<p> Pour éviter un tel problème, lorsqu'on développe un <strong class="defin">fichier modulaire</strong> (fichier d'en‑tête ou autre…) destiné à être inclus dans divers programmes, il est d'usage d'encapsuler l'intégralité de son code source dans une <strong>directive de compilation conditionnelle</strong> de <strong class="title">protection contre les inclusions multiples</strong>. Cette directive prend la forme suivante : </p>

<div class="inline" style="background: white; padding-left: 0.7em; width: 19em; text-indent: 0em;"><code class="prettyprint lang-c">#ifndef <span class="nocode"><strong class="specialV">pseudo‑constante spécifique</strong></span><br>
#define <span class="nocode"><strong class="specialV">pseudo‑constante spécifique</strong></span><br><br><span class="nocode"><strong> code intégral à inclure</strong></span><br><br>#endif </code>
</div><!-- inline -->

<p> Elle consiste donc : </p>
<ul>
  <li> à <strong class="defin">vérifier</strong> que la <strong class="specialV">pseudo‑constante spécifique</strong> au fichier source n'est <strong class="warning">pas définie</strong> ; </li>

  <li> et dans ce cas seulement, à <strong class="defin">définir</strong> cette <strong class="specialV">pseudo‑constante</strong> (sans chaîne de substitution car la seule utilité de cette pseudo‑constante est de pouvoir vérifier le fait qu'elle est définie ou non) et encapsuler tout le code du fichier. </li>
</ul>

<p> Donc, lorsque le préprocesseur traite cette directive, si cette <strong class="specialV">pseudo‑constante</strong> est <strong class="defin">déjà définie</strong>, cela signifie que le fichier est <strong>déjà inclus</strong>. Son code source est alors ignoré, pour ne pas être à nouveau inclus. </p>

<div class="expert">
<p> En règle générale, l'<strong class="specialG">identificateur</strong> de la pseudo‑constante spécifique reprend le <strong>nom du fichier source (extension comprise)</strong>. Le suffixe <code class="prettyprint lang-c">_H</code> (pour évoquer l'extension <code class="filename">.h</code>) ou tout autre ajout comme <code class="prettyprint lang-c">_INCLUDED</code> est bienvenu pour éviter un risque de conflit avec un éventuel identificateur qu'un programme utilisateur du fichier pourrait employer.  </p>
</div><!-- expert -->
</div><!-- complement -->

<div class="exemples">
<p class="exemples"> Tous les fichiers d'en‑tête de bibliothèques, standards ou non, en langage <strong>C</strong> ou <strong>C++</strong>, sont protégés par une directive de la forme ci‑dessus (ou éventuellement un peu plus complexe). Ceux du framework <strong class="Arduino">Arduino</strong> ne dérogent pas à la règle. Le fichier <code class="filename">Arduino.h</code> <a class="external" href="https://github.com/arduino/ArduinoCore-avr/blob/master/cores/arduino/HardwareSerial.cpp" target="_BLANK">G</a> pour les cartes à cœur <em class="sigle">AVR</em> en donne un exemple typique. On y trouve <strong>dès la première ligne de code</strong> (après le bloc de commentaires en préambule) :  </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:20">
#ifndef Arduino_h
#define Arduino_h
</pre>
<!---------- ne pas indenter ---------->  

<p> et <strong>tout à la fin</strong>, la ligne de contrôle de clôture de cette directive : </p>

<!---------- ne pas indenter ---------->
<pre class="prettyprint lang-c linenums:260">
#endif 
</pre>
<!---------- ne pas indenter ---------->  
</div><!-- exemple -->


<h4> Mise hors compilation d'une partie de code source </h4>


<div class="complement">

<p> Rappelons que lorsque l'on souhaite qu'une <strong>partie du code</strong> d'un programme ne soit <strong class="title">pas compilée</strong> tout en restant <strong class="title">enregistrée</strong> dans le fichier, il est envisageable – mais néanmoins <strong class="cons">malcommode</strong> – de mettre en <strong class="specialLGr">commentaires</strong> de cette partie de code (cf. chap. C2‑II <a class="previous" href="../C2-ElementsLangage/Cc2-2_syntaxeFondamentale.html#commentaires" target="_BLANK"></a>). </p>

<p> La <strong class="pros">bonne pratique</strong> consiste plutôt à encapsuler la partie de code dans une <strong class="defin">directive de compilation conditionnelle</strong> de la forme :  </p>

<div class="inline" style="background: white; padding-left: 0.7em; width: 19em; text-indent: 0em;"><code class="prettyprint lang-c">#if 0 <br><br><span class="nocode"><strong class="specialLGr">code à exclure de la compilation</strong></span><br><br>#endif // #if 0</code>
</div><!-- inline -->

<p> La condition <code class="prettyprint lang-c">0</code> étant <strong style="color: red">toujours fausse</strong>, toute la partie de code jusqu'à la ligne de contrôle <code class="prettyprint lang-c">#endif</code> n'est <strong class="defin">jamais transmise au compilateur</strong>. Automatiquement, tout bon éditeur de code octroie à cette partie de code la même <strong>coloration syntaxique</strong> qu'un <strong class="specialLGr">commentaire</strong> pour repérer au premier coup d'œil qu'elle est inopérante. </p>
</div><!-- complement -->

<div class="expert">
<p> Cette méthode présente plusieurs <strong class="pros">avantages</strong> sur une véritable mise en commentaire : </p>

<ul>
  <li> être opérationnelle quel que soit le contenu du code encapsulé, même s'il s'y trouve des blocs de commentaires (on rappelle en effet qu'on peut pas utiliser les délimiteurs <code class="prettyprint lang-c">/* */</code> pour encapsuler une partie de code qui contient déjà ces délimiteurs)  ; </li>

  <li> ne pas gêner la lecture de cette partie de code avec un séparateur <code class="prettyprint lang-c">//</code> au début de chaque ligne ; </li>

  <li> ne pas requérir la sélection de toute la partie de code à « commenter » ou « décommenter » (ce qui n'est pas très commode lorsque cette partie est grande) ; il suffit juste d'ajouter ou supprimer les deux lignes de contrôle <code class="prettyprint lang-c">#if 0</code> et <code class="prettyprint lang-c">#endif</code>.  </li>
</ul>
</div><!-- expert -->





</section>

</div><!-- #scrollingFrame -->

</div><!-- #mainFrame -->

</body>

</html>
